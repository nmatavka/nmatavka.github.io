<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>PaigeManual</title>
<link rel="stylesheet" href="style.css">
</head>
<body><div>[TOC]</div>
<h1 id='1-introduction'>1 Introduction</h1>
<h2 id='11-purpose-of-this-document'>1.1 Purpose of this document</h2>
<p>The purpose of this document is to provide initial programming information for the HERMES Paige developers. Comments are welcome, as are useful example code submissions. Questions and answers from HERMES Paige developers may be used in subsequent editions of the manual.</p>
<h2 id='12-how-to-use-this-manual'>1.2 How to use this manual</h2>
<p>The HERMES Paige technology is quite extensive, so we recommend that you do not simply dive into the middle of this manual and start implementing complex features.</p>
<p>Our advice is to implement this software by following these gradient steps:</p>
<ol start='' >
<li>Follow the information in chapter 2, &quot;Up and Running&quot;. During this phase, ignore all other information in the manual.</li>
<li>Follow chapter 3, &quot;Beyond the Defaults&quot;, which discusses implementation of additional, common features above and beyond the bare minimum covered in #1 above.</li>
<li>If you need to implement virtual memory, do that by following chapter 4, &quot;Virtual Memory&quot;.</li>
<li>Implement all remaining simple functionality not covered in #1 or #2 above, such as text formatting (fonts and styles), paragraph formatting (indents and justification) and possibly tab settings and color. See chapter 8, &quot;Style Basics&quot;.</li>
<li>Depending on what you wish to accomplish with HERMES Paige, find section(s) that deal with your particular requirements — we have tried to break down this manual into the most likely application requirements.</li>

</ol>
<p>You should also consult the index to locate the topic(s) of interest quickly.</p>
<p>Generally, we have placed the parts of HERMES Paige that most users will want and that are the most straight forward in the front. As you move to the back of the manual, the functionality will become more complex.</p>
<h4 id='caution'>CAUTION</h4>
<p>It is important to remember that no user will need the entire functionality. If you are contemplating a complex feature, or one in which you will need detailed knowledge of HERMES Paige or working in the chapters toward the rear of the manual, please contact HERMES Paige Tech Support via electronic mail for an evaluation and suggestions on how you can easily accomplish your goal. We can often suggest the easiest way to do something if we are consulted before you are buried in buggy code. Also knowing what you are doing and why you are doing it &quot;that way&quot; helps us to build better features.</p>
<h2 id='13-implementation-tips--hints'>1.3 Implementation Tips &amp; Hints</h2>
<!-- very out of date -->
<ul>
<li>If you are a Word Solution Engine customer: the HERMES Paige technology is very different than DataPak&#39;s Word Solution Engine. We therefore recommend strongly to &quot;forget&quot; all you know about Word Solution in order to understand the implementation of HERMES Paige.</li>
<li>Use the index to find small items, and Summary of Functions for quick-reference to function syntax.</li>
<li>Consult the demo program. The HERMES Paige package you received includes all the source files for the &quot;demo&quot; which contains a wealth of information and examples. If you think something does not work correctly, before reporting a bug or otherwise reach an impasse, consult that area of the demo against the way you have implemented the code. One of the first questions we will ask when you contact our Technical Support is, &quot;Does it work correctly in the demo?&quot;</li>

</ul>
<h4 id='note-windows-users'>NOTE (WINDOWS USERS)</h4>
<p>If you are using the HERMES Paige API directly, consult the source files in the Control directory (the &quot;demo&quot; simply uses the HERMES Paige Custom Control; the Custom Control source files show how to access the API).</p>
<h4 id='note'>NOTE</h4>
<p>You may contact our Technical Support service if the above suggestions fail to help. However, we do not accept any telephone support questions whatsoever. All questions must be submitted by email; we will always attempt to handle your questions as quickly and as thoroughly as possible. You can email your support questions to <!--support@HERMES Paige.com-->.</p>
<h2 id='14-certain-conventions'>1.4 Certain Conventions</h2>
<p>Since HERMES Paige is designed to be a multi-platform, multi-application processing editing library, we have had to make certain conventions in how the functions are described.</p>
<h3 id='far-pointers'>&quot;FAR&quot; Pointers</h3>
<p>Certain platforms require pointers which are outside the current segment to be designated as <code>far</code> pointers, such as Windows. Other platforms, such as the Macintosh do not require this. For the Macintosh, <code>PG_FAR</code> has been declared as nothing and these differences can be ignored.</p>
<h3 id='pascal-keyword'><code>pascal</code> keyword</h3>
<p>The <code>pascal</code> keyword has been left out of the function definitions in this document; the actual header file(s) will contain that keyword. All external HERMES Paige functions are declared using the Pascal calling conventions.</p>
<h3 id='redefinition-of-types'>Redefinition of types</h3>
<p>To maintain compatibility across all platforms, certain new types have been declared as follows:</p>
<h4 id='unicode-version'>Unicode Version</h4>
<figure class='table-figure'><table>
<thead>
<tr><th style='text-align:left;' >HERMES Paige Type</th><th style='text-align:left;' >Typedef&#39;d From</th></tr></thead>
<tbody><tr><td style='text-align:left;' ><code>pg_short_t</code></td><td style='text-align:left;' >unsigned short</td></tr><tr><td style='text-align:left;' ><code>pg_char</code></td><td style='text-align:left;' >unsigned short</td></tr><tr><td style='text-align:left;' ><code>pg_char_ptr</code></td><td style='text-align:left;' >pointer to <code>pg_char</code></td></tr><tr><td style='text-align:left;' ><code>pg_bits8</code></td><td style='text-align:left;' >unsigned char</td></tr><tr><td style='text-align:left;' ><code>pg_bits8_ptr</code></td><td style='text-align:left;' >pointer to <code>pg_bits8</code></td></tr><tr><td style='text-align:left;' ><code>pg_boolean</code></td><td style='text-align:left;' >short</td></tr><tr><td style='text-align:left;' ><code>pg_error</code></td><td style='text-align:left;' >short (for error codes)</td></tr><tr><td style='text-align:left;' ><code>memory_ref</code></td><td style='text-align:left;' >unsigned long</td></tr><tr><td style='text-align:left;' ><code>PGSTR</code></td><td style='text-align:left;' ><code>pg_char_ptr</code></td></tr></tbody>
</table></figure>
<h4 id='non-unicode-version'>Non-Unicode Version</h4>
<figure class='table-figure'><table>
<thead>
<tr><th style='text-align:left;' >HERMES Paige Type</th><th style='text-align:left;' >Typedef&#39;d From</th></tr></thead>
<tbody><tr><td style='text-align:left;' ><code>pg_short_t</code></td><td style='text-align:left;' >unsigned short</td></tr><tr><td style='text-align:left;' ><code>pg_char</code></td><td style='text-align:left;' >unsigned char</td></tr><tr><td style='text-align:left;' ><code>pg_char_ptr</code></td><td style='text-align:left;' >pointer to <code>pg_char</code></td></tr><tr><td style='text-align:left;' ><code>pg_bits8</code></td><td style='text-align:left;' >(same as <code>pg_char</code>)</td></tr><tr><td style='text-align:left;' ><code>pg_bits8_ptr</code></td><td style='text-align:left;' >(same as <code>pg_char_ptr</code>)</td></tr><tr><td style='text-align:left;' ><code>pg_boolean</code></td><td style='text-align:left;' >short</td></tr><tr><td style='text-align:left;' ><code>pg_error</code></td><td style='text-align:left;' >short (for error codes)</td></tr><tr><td style='text-align:left;' ><code>memory_ref</code></td><td style='text-align:left;' >unsigned long</td></tr><tr><td style='text-align:left;' ><code>PGSTR</code></td><td style='text-align:left;' ><code>pg_char_ptr</code></td></tr></tbody>
</table></figure>
<h3 id='null-reference'>NULL Reference</h3>
<p>Frequent use of the term <code>M_NULL</code> exists throughout this manual. This is a HERMES Paige macro that simply expands to (value of) zero. It is used for indicating a &quot;null&quot; for a HERMES Paige memory reference.</p>
<h3 id='machine-definitions'>Machine Definitions</h3>
<p>A single header file, <code>cpudefs.h</code> controls basic definitions for the platform in which the source files are intended.</p>
<h2 id='15-debug-mode'>1.5 Debug Mode</h2>
<p>Windows users can ignore the &quot;debug mode&quot; libraries described below. This method of debugging applies only to Macintosh versions.</p>
<p>HERMES Paige is compiled in both &quot;debug&quot; and &quot;non debug&quot; modes. Two sets of libraries are provided for this purpose.</p>
<p>When you use the &quot;debug&quot; libraries, you must also include <code>pgdebug.c</code> in your project. This lets you break into a source-level debugger to learn why HERMES Paige is raising an exception. To use the HERMES Paige debugger, open <code>pgdebug.c</code> and place a break point at the suggested spot (source comments indicate the spot).</p>
<p>If you break into the debugger, the message parameter is a <code>pascal</code> string.</p>
<p>Source code users: Debug mode is controlled by a single <code>#define</code> in <code>CPUDefs.h</code>, <code>#define PG_DEBUG</code>.</p>
<p>Debug mode slows the performance down substantially. It is recommended to use HERMES Paige in debug mode during your development, but to turn it off for your final release, if for no other reason than increased performance.</p>
<h1 id='2-up-and-running'>2 Up and Running</h1>
<h2 id='21-hermes-paige-custom-control'>2.1 HERMES Paige Custom Control</h2>
<!-- these documents are missing so this section is invalid -->
<p>If you are using HERMES Paige for a new application, or integrating HERMES Paige for the first time, it would be wise to consider implementing the HERMES Paige Custom Control. Documentation for this subset of HERMES Paige is contained in a separate, smaller manual.</p>
<p>The Custom Control can potentially save you substantial amounts of development time, particularly to get &quot;up and running&quot; quickly. To make this decision, consider the following:</p>
<ul>
<li>Using the Control immediately eliminates the need to know very little — or any — of the detailed information in this Programmer&#39;s Guide.</li>
<li>Most of the samples we provide use the Control (not the direct API).</li>
<li>You can still call the HERMES Paige API directly, when and if you need to.</li>

</ul>
<p>If you decide to use the HERMES Paige Custom Control, you do not need to read this manual any further! Immediately proceed to the HERMES Paige Control manual; use this (larger) Programmer&#39;s Guide only when/if you need to call the API directly.</p>
<h2 id='22-bare-necessities'>2.2 Bare necessities</h2>
<p>This section provides the bare minimum code to get up and running with HERMES Paige. This minimum functionality assumes one single default font and style, a single rectangle for display and word wrapping, no scrolling, nothing fancy.</p>
<h4 id='caution-2'>CAUTION</h4>
<p>Be sure to consult the release note and individual installation instructions included in each release. HERMES Paige installation will change with versions and even interim releases. This makes checking the latest notes on the disk critical.</p>
<h2 id='23-libraries--headers'>2.3 Libraries &amp; Headers</h2>
<p>Regardless of whether you are a source code user or an object-code-only user, all source files in your application that call HERMES Paige functions must include, at a minimum:</p>
<pre><code class='language-c' lang='c'>#include &quot;Paige.h&quot;
</code></pre>
<p>As for the HERMES Paige software itself, the minimum configuration is given below.</p>
<h3 id='windows'>Windows</h3>
<p>The Windows version provides several library options; choose the appropriate libraries based upon the information provided below.</p>
<h4 id='note-2'>NOTE</h4>
<p>Most libraries include the option between DLL(s) and static libraries.</p>
<h4 id='windows-31'>Windows 3.1</h4>
<p>Multilingual (will handle double-byte codes such as Kanji)</p>
<pre><code>(DLL Version Only)

PGML16.DLL (Main HERMES Paige)
PGMLCT16.DLL (Custom control)
</code></pre>
<p>Non-Multilingual (no requirements for double-byte codes)</p>
<pre><code>DLL Libraries
^^^^^^^^^^^^^
PAIGE.DLL (Main HERMES Paige)
PGCNTL.DLL (Custom control)

Static Libraries
^^^^^^^^^^^^^^^^
PG16LIB.LIB (Main HERMES Paige)
PGCTL16.LIB (Custom control)
</code></pre>
<h4 id='windows-nt-xp-10-11'>Windows NT (XP, 10, 11)</h4>
<h5 id='unicode'>Unicode</h5>
<pre><code>DLL Libraries
^^^^^^^^^^^^^
PGUNICOD.DLL (Main HERMES Paige)
PGUNICTL.DLL (Custom control)

Static Libraries
^^^^^^^^^^^^^^^^
PGUNILIB.LIB (Main HERMES Paige)
PGUNCTLB.LIB (Custom control)
</code></pre>
<h5 id='non-unicode'>Non-Unicode</h5>
<pre><code>DLL Libraries
^^^^^^^^^^^^^
Paige32.DLL (Dynamic Linked Library for main (HERMES Paige)
Pgentl32.DLL (Dynamic Linked Library for custom control)

Static Libraries
^^^^^^^^^^^^^^^^
PGLIB32.LIB (Main HERMES Paige)
PGCTLLIB.LIB (Custom control)
</code></pre>
<h5 id='multilingual'>Multilingual</h5>
<p>All versions for Windows 95 and NT are multilingual-compatible.</p>
<h5 id='borland-libraries-dll-libraries-only'>Borland Libraries (DLL libraries only)</h5>
<pre><code>Single Thread
^^^^^^^^^^^^^
PAIGE32B.DLL (Main HERMES Paige)
PGCTL32B.DLL (Custom Control)

Multithread
^^^^^^^^^^^
PG32BMT.DLL (Main HERMES Paige)
PGC32BMT.DLL (Custom control)
</code></pre>
<h3 id='program-linking-with-dll-libraries'>Program Linking with DLL Libraries</h3>
<p>When using any of the DLL libraries, add the file with the same name plus the <code>.LIB</code> extension. For example, if using <code>PAIGE.DLL</code> for the runtime library, add <code>PAIGE.LIB</code> to your project.</p>
<h3 id='macintosh'>Macintosh</h3>
<h3 id='macintosh-object-code-users'>Macintosh Object Code Users</h3>
<p>If you are using Think C or Metrowerks CodeWarrior, add all libraries to your project from the &quot;Debug Libraries&quot; OR &quot;Runtime Libraries&quot; folder (not both). Running in debug mode is suggested for general development, while non-debug is suggested for performance testing (for speed) and/or for final release of your product. Debug mode will reduce the program&#39;s performance substantially.</p>
<p>If you are using Metrowerks CodeWarrior, you must be sure to remove all previous versions of header files. Compiler complaints may be the result of CodeWarrior finding the incorrect header or object file.</p>
<p>The source code package includes &quot;make&quot; files for building HERMES Paige libraries with MSVC++. If you need to create your own project file to build an HERMES Paige library, the following information may prove useful:</p>
<ol start='' >
<li>Include <code>.C</code> files from the <code>pgsource</code> directory. None of them should be excluded.</li>
<li>Include <code>pgdebug</code> from the <code>pgdebug</code> directory. (<strong>NOTE:</strong> This file compiles to zero bytes of code unless <code>#define PG_DEBUG</code> is present in <code>CPUDEFS.H</code> [see “Compiler Options&quot; below].)</li>
<li>Include the following <code>.C</code> files from <code>pgplatfo</code> regardless of the target platform: <code>pgio.c</code>, <code>pgmemmgr.c</code>, <code>pgosutl.c</code>, <code>pgscrap.c</code>.</li>
<li>Depending upon your target platform, include the following files from <code>pgplatfo</code>: <code>pgwin.c</code> and <code>pgdll.c</code> (the latter if compiling as a DLL) for Windows, and <code>pgmac.c</code> and <code>pgmacput.c</code> for Macintosh.</li>
<li>For <strong>Windows 3.1</strong> you may be asked to include a <code>.DEF</code> file. With MSVC 1.5x you can ask to generate a default <code>.DEF</code>, in which case you should choose to do so and rebuild.</li>
<li>The HERMES Paige source code is not always friendly to certain C++ compilers due to <code>void*</code> type casting (or lack thereof). In most cases, you can work around this problem by compiling your project as straight C with an output for static or dynamically-linked library, then include that library in your main project. For Metrowerks CodeWarrior (Macintosh) you can work around this problem by turning OFF the option, &quot;Invoke C++ Compiler&quot;.</li>
<li>To compile for Unicode, define <code>UNICODE</code> and <code>_UNICODE</code> in the preprocessor option(s). Do not define these constants in the header file(s) or you won&#39;t necessary achieve an accurate Unicode library.</li>
<li>If you compile for <strong>Windows 3.1-Multilingual</strong>, you must also include the following Windows library (for National Language Support): <code>OLENLS.LIB</code>.</li>

</ol>
<h3 id='compiler-options'>Compiler Options</h3>
<p>All options for different target platforms and library types are controlled in <code>CPUDEFS.H</code>. Generally, only the first several lines in <code>CPUDEFS.H</code> need to be changed to compile for different platforms. The following guidelines should be followed:</p>
<h4 id='compiling-for-windows-31'>Compiling for Windows 3.1</h4>
<pre><code>#define WIN16_COMPILE (should be ON)
#define WIN32_COMPILE (should be OFF)
</code></pre>
<h4 id='compiling-for-windows-31-multilingual-double-byte'>Compiling for Windows 3.1-Multilingual (double-byte)</h4>
<p>In addition to above:</p>
<pre><code class='language-c' lang='c'>#define WIN_MULTILINGUAL // should be added to the file or preprocessor
</code></pre>
<h4 id='compiling-for-windows-nt-7-8-10-11'>Compiling for Windows NT (7, 8, 10, 11)</h4>
<pre><code class='language-c' lang='c'>#define WIN16_COMPILE // should be OFF
#define WIN32_COMPILE // should be ON
</code></pre>
<h5 id='note-3'>NOTE</h5>
<p>There are other miscellaneous options that may imply a requirement to be enabled (by their names) such as <code>WIN95_COMPILE</code>. Do not turn these on, regardless of platform! Enable only <code>WIN32_COMPILE</code> for all 32-bit versions.</p>
<p>You do not need to define anything other than <code>WIN32_COMPILE</code> to support double-byte multilingual editing for Windows NT and Windows 95; that support is generated automatically.</p>
<p>For Unicode, you must define <code>UNICODE</code> and <code>_UNICODE</code> in your preprocessor options of the compiler. (If no preprocessor option, <code>#define UNICODE</code> somewhere in your sources or headers to allow all system header files to recognize the Unicode option).</p>
<h4 id='dll-versus-static-library-all-platforms'>DLL versus Static Library (all platforms)</h4>
<p>To compile as a DLL:</p>
<pre><code class='language-c' lang='c'>#define CREATE_MS_DLL // should be ON
</code></pre>
<p>If compiling as a static library or non-DLL:</p>
<pre><code class='language-c' lang='c'>#define CREATE_MS_DLL // should be OFF
</code></pre>
<h4 id='debug-versus-runtime'>Debug versus Runtime</h4>
<p>HERMES Paige has a built-in debugger which can be enabled by compiling with the following:</p>
<pre><code class='language-c' lang='c'>#define PG_DEBUG // HERMES Paige debugger compiles if ON
</code></pre>
<p>When this is defined, all HERMES Paige exceptions or debugging errors jump into the code in <code>pgdebug.c</code>.</p>
<h5 id='note-4'>NOTE</h5>
<p>Compiling with <code>PG_DEBUG</code> will dramatically reduce the performance!</p>
<h4 id='special-resource-macintosh-only'>Special Resource (Macintosh only)</h4>
<p>A special resource has been provided on your HERMES Paige disc which the Macintosh-specific code within HERMES Paige uses to initialise default character values (such as arrow keys, backspace characters, invisible symbols, etc.). You may copy and paste this resource into your application&#39;s resource and you may modify its contents if you want different defaults.</p>
<p>This resource is not required to use HERMES Paige successfully. If it is missing, initialisation simply sets a hard-coded set of defaults.</p>
<p>See also <a href='#38-changing-globals'>Changing Globals</a>.</p>
<h3 id='24-software-startup'>2.4 Software Startup</h3>
<p>Some place early in your application you need to initialise the HERMES Paige software; the recommended place to do so is after all other initialisations have been performed for the main menu, Mac Toolbox, etc. To initialise, you need to reserve a couple blocks of memory that HERMES Paige can use to store certain global variables (HERMES Paige does not use any <code>globals</code> and therefore requires you to provide areas it can use to store required global structures).</p>
<p>To initialise HERMES Paige you must call two functions in the order given:</p>
<pre><code class='language-c' lang='c'>#include &quot;Paige.h&quot;
(void) pgMemStartup (pgm_globals_ptr mem_globals, long max_memory);
(void) pgInit (pg_globals_ptr globals, pgm_globals_ptr mem_globals);
</code></pre>
<p>Calling <code>pgMemStartup</code> initialises HERMES Paige&#39;s allocation manager. This call must be made first before <code>pgInit</code>. The <code>mem_globals</code> parameter must be a pointer to an area of memory which you provide. The usual (and easiest) method of doing this is to define a global variable that will not relocate or unload during the execution of your program, such as the following:</p>
<pre><code class='language-c' lang='c'>pgm_globals 	memrsrv; // &lt;--somewhere that will NOT unload
</code></pre>
<p>You do not need to initialise this structure to anything—<code>pgMemStartup</code> initialises this structure appropriately.</p>
<p><code>max_memory</code> should contain the maximum amount of memory HERMES Paige is allowed to use before purging memory allocations. If you want HERMES Paige to have access to all available memory (which is <em>strongly recommended</em>), pass 0 for <code>max_memory</code>.</p>
<p>For example, suppose you only wanted to use 200 kB of memory for all HERMES Paige documents, combined. In this case, you would pass 200000 to pgInit. If you don&#39;t care, or want it to use all memory available, you would pass 0.</p>
<p>After <code>pgMemStartup</code>, call <code>pgInit</code>, which initialises every other part of HERMES Paige.</p>
<p><code>globals</code> is a pointer to an area of memory which you provide. The usual (and easiest) method of doing this is to define a global variable that will not relocate or unload during the execution of your program, such as the following:</p>
<pre><code class='language-c' lang='c'>pg_globals	paigersrv; // &lt;-- somewhere that will NOT unload
</code></pre>
<p>The structure <code>pg_globals</code> is defined in <code>paige.h</code> (and shown in section 3.8, <a href='#38-changing-globals'>Changing Globals</a>). You do not need to initialise this structure to anything—HERMES Paige will initialise the globals structure as required. It is only necessary that you provide the space for this structure and pass a pointer to it in <code>pgInit</code>.</p>
<p><code>mem_globals</code> parameter in <code>pgInit</code> must be a pointer to the same structure passed to <code>pgMemStartup</code>.</p>
<h5 id='mfc-note'>MFC NOTE</h5>
<p>The best place to initialise HERMES Paige in the constructor of the <code>CWinApp</code> derived class. Also the best place to put the HERMES Paige globals and memory globals is in the <code>CWinApp</code> derived class.</p>
<h5 id='example'>EXAMPLE</h5>
<pre><code class='language-c' lang='c'>(.H)

class MyWinApp : public CWinApp
{
	...
	public:
	pgm_globals m_MemoryGlobals;
	pg_globals m_Globals;
	...
}

(.CPP)

MyWinApp::MyWinApp()
{
	pgMemStartup(&amp;m_MemoryGlobals, 0);
	pgInit(&amp;m_Globals, &amp;m_MemoryGlobals);
	...
}
</code></pre>
<h4 id='tech-note'>TECH NOTE </h4>
<blockquote><blockquote><p><code>pgInit</code> crashes</p>
</blockquote>
</blockquote>
<p>It is possible to crash in <code>pgInit</code>. This is very rare however. Here are the main possibilities:</p>
<ul>
<li>A wrong library is linked in, i.e. version mismatch. (This includes all &quot;updates&quot; from compiler vendors who have changed the format of their object code libraries).</li>
<li>It is called without calling <code>MemStartup</code>.</li>
<li>You are out of memory. HERMES Paige can require up to 60 kB to build itself and get ready to accept text.</li>
<li><strong>Windows 3.1 platform only</strong>: you are building a DLL with a memory model mismatch. The PAIGE DLL was built for large modal; try building your DLL the same.</li>

</ul>
<h3 id='25-hermes-paige-shutdown'>2.5 HERMES Paige Shutdown</h3>
<p>For applications that require a <code>shutdown</code> of all allocations it has created, call the following functions, in the order shown, before terminating your application:</p>
<pre><code>(void) pgShutdown (pg_globals_ptr globals);
(void) pgMemShutdown (pgm_globals_ptr mem_globals);
</code></pre>
<p><code>globals</code> and <code>mem_globals</code> parameters must be pointers to the same structures given to <code>pgInit</code> and <code>pgMemStartup</code>, respectively. After <code>pgShutdown</code>, you must not call any HERMES Paige functions (except for <code>pgInit</code>). After <code>pgMemShutdown</code>, all allocations placed in globals are de-allocated.</p>
<h5 id='caution-3'>CAUTION</h5>
<p>All <code>pg_ref</code>s and all memory references allocated anywhere by HERMES Paige become invalid after <code>pgShutdown</code>, so make sure this is the very last HERMES Paige function you call.</p>
<h5 id='caution-windows-users'>CAUTION (WINDOWS USERS)</h5>
<p>Be sure to call both <code>pgShutdown</code> and <code>pgMemShutdown</code>, in that order, before <code>EXIT</code>, or you will have memory leaks and resources that are never released.</p>
<h5 id='notes'>NOTES</h5>
<ul>
<li><p><code>pgShutdown</code> and <code>pgMemShutdown</code> actually dispose every memory allocation made by HERMES Paige since <code>pgMemStartup</code>; you therefore don&#39;t really need to dispose any <code>pg_ref</code>s, <code>shape_ref</code>s or other HERMES Paige allocations.</p>
</li>
<li><p>You must not call either shutdown function if you are using the HERMES Paige Control.</p>
</li>
<li><p>For Macintosh applications, the shutdown procedure is completely unnecessary if you will be doing an <code>ExitToShell</code> using the app version. Mac developers working with code resource libraries will still need to call <code>pgShutdown</code> and <code>pgMemShutdown</code>.</p>
</li>
<li><p>For Microsoft Foundation Class applications, the appropriate method to shut down HERMES Paige is to override <code>CxxAppxExitInstance()</code> and call <code>::pgShutdown</code> and <code>::pgMemShutdown</code>.</p>
</li>
<li><p>The best place to shutdown HERMES Paige is in the destructor of the <code>CWinApp</code> derived class. Example:</p>
<pre><code>(.CPP)
MyWinApp::~MyWinApp()
{
	...
	pgShutdown(&amp;m_Globals);
	pgMemShutdown(m_MemoryGlobals);
}
</code></pre>
</li>

</ul>
<p>&nbsp;</p>
<h3 id='26-creating-an-hermes-paige-object'>2.6 Creating an HERMES Paige Object</h3>
<p>By &quot;HERMES Paige object&quot; is meant a single item that can edit, display and otherwise manipulate a block of text, large or small.</p>
<p>Calling <code>pgNew</code>, below, returns a reference of type <code>pg_ref</code>. This <code>pg_ref</code> can then be passed to all the other functions given in this manual.</p>
<pre><code>(pg_ref) pgNew (pg_globals_ptr globals, generic_var def_device, shape_ref vis_area, shape_ref page_area, shape_ref exclude_area, long attributes);
</code></pre>
<p>The above function returns a new <code>pg_ref</code>; the <code>pg_ref</code> can then be passed to other functions to insert text and edit text.</p>
<p><code>globals</code> parameter must be a pointer to the same <code>pg_globals</code> structure you passed to <code>pgInit</code> at startup time.</p>
<p>Attributes are described in sections 2.8, <a href='#28-attribute-settings'>Attribute Settings</a>, and 3.1, <a href='#31-changing-attributes'>Changing Attributes</a>, but can be set here as well.</p>
<p><code>def_device</code> parameter defines what graphics port this HERMES Paige object should draw to by default; what is actually passed to <code>def_device</code> can slightly vary between platforms as follows:</p>
<h4 id='macintosh--powerpc'>Macintosh &amp; PowerPC</h4>
<p>If <code>def_device</code> is <code>NULL</code> then current <code>GrafPort</code> is used as the default device; if <code>def_device</code> is non-<code>NULL</code> and not &quot;-1&quot; it is assumed to be a <code>GrafPtr</code> and that port is used for subsequent drawing.</p>
<h4 id='windows-pc'>Windows (PC)</h4>
<p>If <code>def_device</code> is <code>0L</code> then the current window of focus is used as the default window where drawing will occur (e.g., <code>GetFocus</code> is used to determine the window); if <code>def_device</code> is non-<code>NULL</code> and not <code>-1</code> it is assumed to be type <code>HWND</code> and that window is used for subsequent drawing.</p>
<p>This <code>HWND</code> in the <code>def_device</code> <em>is not</em> a Device Context.</p>
<p>Essentially, the <code>dev_device</code> should be the window (or child window) that is receiving the message to create the HERMES Paige object, e.g. <code>WM_CREATE</code>.</p>
<h5 id='caution-4'>CAUTION</h5>
<p>If you pass <code>MEM_NULL</code> to <code>def_device</code>, HERMES Paige will obtain the window of current focus. You should only use this method if your document window is known to be the window of focus, otherwise passing <code>MEM_NULL</code> can result in a crash.</p>
<h4 id='microsoft-foundation-classes-mfc'>Microsoft Foundation Classes (MFC)</h4>
<p>The best place to put <code>pgNew()</code> is in the <code>OnCreate()</code> member of the <code>CView</code> derived class. It is important to call the <code>CView::OnCreate()</code> <strong>before</strong> calling <code>pgNew()</code>. Examples follow:</p>
<pre><code>(.H)
class MyView : public CView
{
...
public:
	pg_ref m_Paige;
...
}

(.CPP)
int MyView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	pgm_globals_ptr memory_globals = ((MyWinApp*)AfxGetApp()) -&gt; m_MemoryGlobals;
	int return_value = 0;
	CRect client_rect;
	rectangle client_paige_rect;
	if(CView::OnCreate(lpCreateStruct == -1)
		return -1;
	ASSERT(m_hWnd);
	ASSERT(isWindow(m_hWind));
	
	// Non-HERMES Paige initialisation here!
	
GetClientRect(&amp;client_rect);
RectToRectangle(&amp;client_rect, &amp;client_paige_rect);

shape_ref window = pgRectToShape(AfxGetMemoryGlobals(), &amp;rect);

PG_TRY(AfxGetApp() -&gt; m_MemoryGlobals // See Chapter 19 of the HERMES Paige manual.
{
	m_Paige = pgNew(AfxGetApp() -&gt; m_Globals,(generic_var)(LPVOID)m_hWnd, window, window, MEM_NULL, 0);
};

PG_CATCH
{
	return_value = -1;
};

	PG_ENDTRY;

	pgDisposeShape(window);

	return return_value;
}
</code></pre>
<h4 id='all-platforms'>All Platforms</h4>
<p>If <code>def_device</code> is <code>-1</code> then no device is assumed (which implies you will not be drawing anything and/or will specify a drawing port later). If you need to pass <code>-1</code> for the <code>def_device</code> parameter, you can use the following predefined macro:</p>
<pre><code>#define USE_NO_DEVICE (generic_var) -1 // pgnew is with no device
</code></pre>
<p>If <code>def_device</code> is neither <code>-1</code> nor a null pointer it is assumed to be an HERMES Paige drawing port to be used for the default (see <code>graf_device</code>, <code>pgSetDefaultDevice</code>).</p>
<p>For &quot;Up and Running&quot;, pass a null pointer for <code>def_device</code> (for Macintosh and PowerPC) or the <code>HWND</code> associated with the current message for Windows-PC.</p>
<p>Parameters <code>vis_area</code>, <code>page_area</code> and <code>exclude_area</code> define the literal shapes for which text will display, wrap and jump over, respectively. Each of these define how the text will appear within the HERMES Paige object as follows:</p>
<p><code>vis_area</code> defines the visible area that shows text, or the &quot;hole&quot; in which it displays. This area may be physically smaller than the document containing the text; any physical area of the screen that is outside the boundary of <code>vis_area</code> will <em>clip</em> (mask) the text from view.</p>
<p><code>page_area</code> defines the container in which text will wrap and flow. It is referred to as the <code>page</code> area since it literally defines the <code>page</code> size of your document. The width of <code>page_area</code> also defines the boundaries for which text must wrap. The <code>page_area</code> can be any size, larger or smaller than <code>vis_area</code>.</p>
<p><code>exclude_area</code> is an optional shape which defines an area or areas in which text must avoid. In other words, if a line of text were to intersect any part of the <code>exclude_area</code>, it must jump over that area in some way to avoid it.</p>
<p>For <code>pgNew</code>, you can pass <code>MEM_NULL</code> for <code>exclude_area</code>, but you must pass a valid <code>shape_ref</code> for <code>vis_area</code> and <code>page_area</code>.</p>
<p>See section 2.7, <a href='#27-up-and-running-shapes'>Up and Running Shapes</a> how to create a <code>shape_ref</code>.</p>
<p><code>attribute</code>s can contain different bit settings which define specific characteristics for the HERMES Paige object. For the purpose of getting &quot;Up and Running&quot; quickly, pass 0 for this parameter (or see section 3.1, <a href='#31-changing-attributes'>Changing Attributes</a>).</p>
<p>The initial font and text format used by the <code>pg_ref</code> returned from <code>pgNew</code> will be taken from <code>pg_globals</code>. To change what font, style or paragraph format that a new <code>pg_ref</code> assumes, set the appropriate information in <code>pg_globals</code> after calling <code>pgNew</code>.</p>
<p><img src="figs/fig1.jpg" referrerpolicy="no-referrer"></p>
<h4 id='memnull-definition'>MEM_NULL Definition</h4>
<p>The value <code>MEM_NULL</code> is a defined value in HERMES Paige header files that you should use to imply a &quot;null&quot; <code>shape_ref</code> or <code>memory_ref</code>—see &quot;The Allocation Manager&quot; on page 25-1.</p>
<h5 id='error-checking-pgnew'>Error checking <code>pgNew</code> </h5>
<p>HERMES Paige provides excellent error checking for <code>pgNew</code>. See &quot;Exception Handling&quot; on page 26-1.</p>
<h2 id='27-up-and-running-shapes'>2.7 Up and Running: Shapes</h2>
<p>To avoid a lengthy discussion at this time regarding HERMES Paige shapes, we will assume at this time you wish to display text within a simple rectangle (as opposed to some other non-rectangular shape or multiple &quot;container&quot; rectangles).</p>
<h4 id='creating-a-shape-using-rectangle'>Creating a shape using rectangle</h4>
<p>The easiest way to create a new shape is to use the following function:</p>
<pre><code>(shape_ref) pgRectToShape (pgm_globals_ptr mem_globals, rectangle_ptr rect);
</code></pre>
<p>This returns a new <code>shape_ref</code> (which can be passed to one of the <code>area</code> parameters in <code>pgNew</code>). The globals parameter must be a pointer to the same structure given in <code>pgInit</code> and <code>pgNew</code>.</p>
<p>The <code>rect</code> parameter is a pointer to a structure consisting of a top-left and bottom-right coördinate that encloses a rectangle. The coördinate and rectangle definitions are as follows:</p>
<pre><code class='language-c' lang='c'>typedef struct
{
	long	v;	// vertical position
	long	h;	// horizontal position
}
co_ordinate;

typedef struct
{
	co_ordinate	top_left;	// Top-left of rect
	co_ordinate	bot_right;	// Bottom-right of rect
}
rectangle, *rectangle_ptr;
</code></pre>
<p>Hence, if you set a rectangle to the desired dimensions and pass a pointer to that rectangle in <code>pgRectToShape</code>, a new memory reference is returned which contains a shape of that rectangle.</p>
<h5 id='note-5'>NOTE</h5>
<p>The reason <code>pgNew</code> requires a <code>shape_ref</code> instead of rectangles is that an HERMES Paige object can have non-rectangular shapes for any of its three areas.</p>
<p>For further information regarding shapes, particularly non-rectangular shapes, see &quot;All About Shapes&quot; on page 12-1.</p>
<h4 id='disposing-a-shape'>Disposing a Shape</h4>
<p>The <code>pgNew</code> function makes a copy of the shape you pass to its parameters. Once you have received a new <code>pg_ref</code> you can dispose the shape. To do so, call:</p>
<pre><code class='language-c' lang='c'>void pgDisposeShape (shape_ref the_shape);
</code></pre>
<h4 id='rect-to-rectangle'>Rect to Rectangle</h4>
<p>Two utilities exist that make it easier to create HERMES Paige rectangles:</p>
<pre><code class='language-c' lang='c'>#include &quot;pgTraps.h&quot;
(void) RectToRectangle (Rect PG_FAR *r, rectangle_ptr pg_rect);
(void) RectantleToRect (rectangle_ptr pg_rect, co_ordinate_ptr offset, Rect PG_FAR *r);
</code></pre>
<p><code>RectToRectangle</code> converts <code>Rect r</code> to rectangle <code>pg_rect</code>. The <code>pg_rect</code> parameter must be a pointer to a rectangle variable you have declared in your code.</p>
<p><code>RectangleToRect</code> converts <code>pg_rect</code> to <code>r</code>. Also, if offset is non-null, the resulting <code>Rect</code> is offset by the amounts of the <code>co_ordinate</code> (for example, if <code>offset.h</code> and <code>offset.v</code> were 10, -5 the resulting <code>Mac Rect</code> would be the values in <code>pg_rect</code> with left and right amounts offset by 10 and top and bottom amounts offset by -5.</p>
<h5 id='note-windows'>NOTE (Windows)</h5>
<p>Type <code>Rect</code> is identical to type <code>RECT</code>, and both can be used interchangeably.</p>
<h5 id='note-macintosh'>NOTE (Macintosh)</h5>
<p>Since a <code>Mac Rect</code> has a ±32K limit for all four sides, HERMES Paige rectangle sides larger than 32K will be intentionally truncated to about 30K.</p>
<h4 id='about-windows-graphic-ports-and-origins'>About Windows, Graphic Ports and Origins</h4>
<p>Although HERMES Paige is designed to be platform-independent, is does assume a target graphics device that all drawing is transferred to.</p>
<p><strong>When a <code>pg_ref</code> is created, the default target device is set to whatever is appropriate for the running platform.</strong> For Macintosh, the default device is the current <code>GrafPort</code> set when <code>pgNew</code> is called.</p>
<h5 id='note-word-solution-engine-for-macintosh'>NOTE (Word Solution Engine for Macintosh)</h5>
<p>Unlike WSE, HERMES Paige &quot;remembers&quot; what port it should draw to and all subsequent drawing will occur in that port unless you specifically override it.</p>
<p>For the purpose of getting &quot;Up and Running&quot;, just make sure you create your window first and have it set as the current port before calling <code>pgNew</code>. In subsequent sections, we will provide different ways to change the target port.</p>
<h4 id='origins'>Origins</h4>
<p>HERMES Paige does not care what a window&#39;s origin is set to (top-left <code>co_ordinate</code> values). HERMES Paige only cares about the <code>area</code> parameters you provide for <code>pgNew</code>; remember, HERMES Paige doesn&#39;t really know what a window is and doesn&#39;t know anything about origins. HERMES Paige simply and only follows the coördinates you have set for <code>vis_area</code>, <code>page_area</code> and <code>exclude_area</code>. If your <code>page_area</code> shape passed to <code>pgNew</code>, for instance, had a top-left of -10000,-9999, the first character of the first line will be drawn at that coördinate location regardless of where the top-left of your window might physically exist. In other words, HERMES Paige coördinates are always relative to the associated window&#39;s coördinates.</p>
<h3 id='28-attribute-settings'>2.8 Attribute Settings</h3>
<p>As mentioned earlier, <code>pgNew</code> will accept certain characteristics defined in the &quot;attributes&quot; parameter. The current version supports the following:</p>
<pre><code class='language-c' lang='c'>#define NO_WRAP_BIT					0x00000001	// Wraps only on &lt;CR&gt; or &lt;LF&gt;
#define NO_LF_BIT						0x00000002	// Do not add font
#define NO_DEFAULT_LEADING	0x00000004	// Do not add font leading
#define NO_EDIT_BIT					0x00000008	// No editing (display only)
#define EXTERNAL_SCROLL_BIT	0x00000010	// App controls scrolling
#define COUNT_LINES_BIT			0x00000020	// Keep track of line, para count
#define NO_HIDDEN_TEXT_BIT	0x00000040	// Do not display hidden text
#define SHOW_INVIS_CHAR_BIT	0x00000080	// Show control characters
#define SMART_QUOTES_BIT		0x00000800	// Do &quot;smart quotes&quot;
#define NO_SMART_CUT_BIT		0x00001000	// Do not do &quot;rt cut/paste&quot;
#define NO_SOFT_HYPHEN_BIT	0x00002000	// Ignore soft hyphens
#define NO_DUAL_CARET_BIT		0x00004000	// Do not show dual carets
#define SCALE_VIS_BIT				0x00008000	// Scale vis_area when scaling
#define BITMAP_ERASE_BIT		0x00010000	// Erase page(s) with bitmap drawing
#define TABS_ARE_WIDTHS_BIT	0x10000000	// Fixed-width tab characters
#define LINE_EDITOR_BIT			0x40000000	// Document is line editor mode
</code></pre>
<p><code>NO_WRAP_BIT</code> turns off word wrapping (which means a line of text will continue horizontally until a carriage-return or line-feed character is encountered).</p>
<p><code>NO_LF_BIT</code> causes HERMES Paige to ignore line-feed characters. The usual purpose of this setting is for imported text that contains both CR and LF at the end of every line; setting the <code>NO_LF_BIT</code> attribute will cause LF characters to be invisible and have no effect of any kind.</p>
<p><code>NO_DEFAULT_LEADING</code> prevents any extra leading reported by the system for font attributes. In Windows, <em>extra leading</em> is the external leading value reported by <code>GetTextMetrics</code>; in Macintosh, it is the leading value reported by <code>GetFontInfo</code>. By default, HERMES Paige adds the extra leading to every line unless this attribute is set.</p>
<p><code>NO_EDIT_BIT</code> disables editing. In effect, if <code>NO_EDIT_BIT</code> is set, the &quot;caret&quot; will not blink and the user can&#39;t insert characters.</p>
<p><code>EXTERNAL_SCROLL_BIT</code> tells HERMES Paige that your application will control all scrolling. (This fairly complex subject is discussed elsewhere.)</p>
<p><code>COUNT_LINES_BIT</code> tells HERMES Paige to keep track of line and paragraph numbers, in which case you can use the line and paragraph numbering features in HERMES Paige (see section 24.8, <a href='#248-line-and-paragraph-numbering'>Line and Paragraph Numbering</a>). Please note that constantly counting lines and paragraphs, particularly if the document is large and contains wordwrapping with style changes, can consume considerable processing time. Hence, <code>COUNT_LINES_BIT</code> has been provided to enable/disable this feature.</p>
<p><code>NO_HIDDEN_TEXT_BIT</code> suppresses the display of all text that is &quot;hidden&quot; (HERMES Paige will accept a hidden text attribute as a style). If this bit is not set, hidden text is displayed with a grey strike-through line; if it is set, the text is completely invisible and ignored for line width computations.</p>
<p><code>SHOW_INVIS_CHAR_BIT</code> causes all invisible characters (control codes such as CR and LF) to be displayed using special character symbols. These symbols are defined in <code>pg_globals</code> (see section 3.8, <a href='#38-changing-globals'>Changing Globals</a>).</p>
<p><code>EX_DIMENSION_BIT</code> tells HERMES Paige to include the exclusion area as part of the &quot;document height&quot;.</p>
<p><code>NO_WINDOW_VIS_BIT</code> – Do not respect window&#39;s clipped area.</p>
<p><code>SMART_QUOTES_BIT</code> – Do &quot;smart quotes&quot; (curly quotation marks).</p>
<p><code>NO_SMART_CUT_BIT</code> – Do not do &quot;smart cut/paste&quot;</p>
<p><code>NO_SOFT_HYPHEN_BIT</code> – Ignore soft hyphens</p>
<p><code>NO_DUAL_CARET_BIT</code> – Do not show dual carets</p>
<p><code>SCALE_VIS_BIT</code> tells HERMES Paige to scale the <code>vis_area</code> along with the text when scaling has been enabled. By default, the <code>vis_area</code> is left alone when an HERMES Paige document is scaled, leaving the text &quot;behind&quot; the visual boundaries reduced or enlarged. In certain cases—particularly when employing multiple <code>pg_ref</code>s into the same document as &quot;edit boxes&quot;—you need this attribute set; for single <code>pg_ref</code> documents that fill all or most of the window, you generally do not want this attribute set.</p>
<p><code>BITMAP_ERASE_BIT</code> tells HERMES Paige to erase area(s) on the page using offsetting bitmap drawing, otherwise the same portions of the screen are erased directly. The purpose of this attribute is to draw &quot;background&quot; graphics in the window when/if HERMES Paige needs to erase the screen.</p>
<p><code>TABS_ARE_WIDTHS_BIT</code> causes all <TAB> characters to display as no more or less than &quot;wide&quot; blanks. For example, if this attribute is not set, a <TAB> character aligns the character(s) that follow to the next logical tab stop; if this attribute is set, the a tab character is simply a fixed-width space (the default tab spacing per HERMES Paige globals).</p>
<p><code>LINE_EDITOR_BIT</code> tells HERMES Paige that you intend to maintain the document as a &quot;line editor&quot;, defined as one where words will not wrap and all lines remain the same height. If HERMES Paige knows this in advance, it can bypass the usual &quot;pagination&quot; functions and you can achieve substantially increased performance for line editors.</p>
<h5 id='note-6'>NOTE</h5>
<p>If you set <code>LINE_EDITOR_BIT</code>, you must not set any attributes to wrap the text, nor should you vary the point size(s) or attempt any irregular page shapes or page breaks. You can still produce multi-styled text as long as the text height(s) are consistently the same.</p>
<p>Any (or all) of the above settings can exist at once.</p>
<h5 id='note-7'>NOTE</h5>
<p>You can always change these attributes after an HERMES Paige object is created (see section 3.1, <a href='#31-changing-attributes'>Changing Attributes</a>).</p>
<h4 id='example----pgnew'>Example – <code>pgNew</code></h4>
<pre><code>/* This creates a new HERMES Paige object */
#include &lt;Paige.h&gt;
#include &quot;pgTraps.h&quot;
extern pg_globals paige_rsrv;

// Routine: Open_Window
// Purpose: Open our window
/* Note: the window has already been made and will be shown and selected immediately after this function */
	
void Open_Window(WindowPtr win_ptr)
{
	if (win_ptr!=nil) /* See if opened OK */
	{
	pg_ref result;
	shape_ref vis, wrap;
	rectangle rect;
	
	/* this sets vis_area and wrap_area to the shape of the window itself */
		
	RectToRectangle(win_ptr-&gt;portRect, &amp;rect);
	vis = pgRectToShape(&amp;paige_rsrv, &amp;rect);
	wrap = pgRectToShape(&amp;paige_rsrv, &amp;rect);
	result = pgNew(&amp;paige_rsrv, NULL, vis, wrap, NULL, EX_DIMENSION_BIT);
	}		/* End of IF */
}
</code></pre>
<h3 id='29-disposing-an-hermes-paige-object'>2.9 Disposing an HERMES Paige Object</h3>
<p>Once you are completely through with a <code>pg_ref</code> (e.g., user closes the window), dispose it with:</p>
<pre><code>(void) pgDispose (pg_ref pg);
</code></pre>
<p>This function disposes all data structures within <code>pg</code>; the <code>pg_ref</code> will no longer be valid.</p>
<p>Be certain you have not shut down the HERMES Paige library before disposing a <code>pg_ref</code>, or you will crash.</p>
<h5 id='note-microsoft-foundation-classes'>NOTE (Microsoft Foundation Classes)</h5>
<p>The best place to destroy the HERMES Paige object is in the OnDestroy() member of your <code>CView</code> derived class. Example:</p>
<pre><code>(.CPP)

void PGView::OnDestroy()
{
	pgDispose(m_Paige);
	CView::OnDestroy();
}
</code></pre>
<h3 id='210-getting-the-globals-pointer'>2.10 Getting the &quot;Globals&quot; Pointer</h3>
<p>If you need to obtain the pointer to <code>pg_globals</code> (originally given to <code>pgInit</code> and to <code>pgNew</code>), you can get it from a <code>pg_ref</code> using the following:</p>
<pre><code>(pg_globals_ptr) pgGetGlobals (pg_ref pg);
</code></pre>
<p>The typical use for <code>pgGetGlobals</code> is to obtain a pointer to <code>pgGlobals</code> in places where the original global structure, given to <code>pg_init</code>, is not easily accessible.</p>
<p><strong>FUNCTION RESULT:</strong> This function returns the globals pointer as saved in pg.</p>
<p>To change globals, see section 3.8, &quot;Changing Globals&quot;.</p>
<h2 id='211-displaying'>2.11 Displaying</h2>
<p>To draw the text in a <code>pg_ref</code> to a window, use the following function:</p>
<pre><code>(void) pgDisplay (pg_ref pg, graf_device_ptr target_device, shape_ref vis_target, shape_ref wrap_target, co_ordinate_ptr offset_extra, short draw_mode);
</code></pre>
<p>The <code>pg_ref</code>&#39;s contents are drawn to the <code>target_device</code>. If, however, you pass a null pointer to <code>target_device</code> the text will be drawn to the default device set during <code>pgNew</code>. (For the purposes of getting &quot;Up and Running&quot;, we will assume you want to draw to the default device, which will typically be a window that was created prior to <code>pgNew</code>, so pass a null pointer).</p>
<p><code>vis_target</code> and <code>wrap_target</code> parameters are optional shapes which will temporarily redefine the HERMES Paige object&#39;s <code>vis_area</code> and <code>wrap_area</code>, respectively. Using these two parameters, you can temporarily control and/or change the way an HERMES Paige object will display. Text gets clipped to <code>vis_target</code>, or, if <code>vis_target</code> is a null pointer, to the original <code>vis_area</code>, and text will wrap within <code>wrap_target</code>, or, if <code>wrap_target</code> is <code>MEM_NULL</code>, within the original <code>wrap_area</code>. (For the purposes of getting &quot;Up and Running&quot;, pass MEM_NULL for these two parameters.)</p>
<p>If <code>offset_extra</code> is <code>non-null</code>, all drawing is offset by the amounts in that coördinate (all text is offset horizontally by <code>offset_extra -&gt; h</code> and vertically by <code>offset_extra -&gt; v</code>. If <code>offset_extra</code> is a null pointer, no extra offset is added to the text.</p>
<p>The <code>draw_mode</code> parameter defines the way text should be transferred to the target device. The <code>draw_mode</code> selections are shown below.</p>
<p>See section 16.9, <a href='#169-display-proc'>Display Proc</a>, about how to add ornaments to the text display.</p>
<h5 id='note-8'>NOTE</h5>
<p>You do not need to specify any drawing device for <code>pgDisplay</code> if you intend to display in the window given to <code>pgNew</code>. In this case, just pass NULL to the <code>target_device</code> parameter.</p>
<p>If for some reason you need to redirect the display to some other window or device (such as a bitmap), you can create a <code>graf_device</code> record for that purpose and pass a pointer to that structure for the <code>target_device</code>.</p>
<p>Creating a <code>graf_device</code> for this purpose is the same as the <code>graf_device</code> record used for <code>pgPrintToPage</code>. See <a href='#printing-in-windows'>Printing in Windows</a> under section 16.5.</p>
<h4 id='draw-modes'>Draw Modes</h4>
<pre><code class='language-c' lang='c'>typedef enum
{
	draw_none,				// Do not draw at all
	best_way,					// Use most efficient method(s)
	direct_copy,			// Directly to screen, overwrite
	direct_or,				// Directly to screen, &quot;OR&quot;
	direct_xor,				// Directly to screen, &quot;XOR&quot;
	bits_copy,				// Copy offscreen
	bits_or,					// Copy offscreen in &quot;OR&quot; mode
	bits_xor,					// Copy offscreen in &quot;XOR&quot; mode
	bits_emulate_copy	// Copy &quot;fake&quot; offscreen
	bits_emulate_or		// &quot;Fake&quot; offscreen in &quot;OR&quot; mode
	bits_emulate_xor	// &quot;Fake&quot; offscreen in &quot;XOR&quot; mode
};
</code></pre>
<h4 id='bits-emulate-mode'>&quot;Bits-emulate&quot; Mode</h4>
<p>The drawing modes <code>bits_emulate_copy</code>, <code>bits_emulate_or</code>, and <code>bits_emulate_xor</code> are identical to <code>bits_copy</code>, <code>bits_or</code> and <code>bits_xor</code> save that no bitmaps are used and the drawing is directly to the screen. Unlike the non-bitmap drawing modes, however, HERMES Paige&#39;s standard callback hooks are called to allow modification to its &quot;bitmap&quot;, which in this case is the direct screen. Bitmap modification is typically used to render background images, patterns, and other forms of graphics.</p>
<h5 id='note-9'>NOTE</h5>
<p>Unless you need to create a special or unusual effect, always pass <code>direct_or</code> or <code>bits_emulate_or</code> when responding to <code>WM_PAINT</code> (Windows) or an update
event (Macintosh), and <code>best_way</code> for all other functions requiring a <code>draw_mode</code>.</p>
<p><img src="figs/fig2.jpg" referrerpolicy="no-referrer"></p>
<p>Additional draw modes require the developer to use the custom draw hook and draw his own. See &quot;<code>text_draw_proc</code>&quot;<!-- on page 27-17--> for information on how to do custom drawing.</p>
<p>A value of <code>draw_none</code> will disable all drawing and visual scrolling. In other words, if the HERMES Paige document changes in some way, nothing would change on the screen until the application re-displayed the HERMES Paige text contents. The &quot;draw nothing&quot; feature is used only for special cases where an application wants to change without drawing anything yet.</p>
<h5 id='responding-to-wmpaint-event-windows'>Responding to <code>WM_PAINT</code> Event (Windows)</h5>
<pre><code class='language-c' lang='c'>{
PAINTSTRUCT ps;
BeginPaint(hWnd, &amp;ps);
pgDisplay(pg, NULL, MEM_NULL, MEM_NULL, NULL, direct_or);
}
EndPaint(hWnd, &amp;ps);
</code></pre>
<p>To display the HERMES Paige object in MFC, use <code>OnPaint()</code>. Do not try to use <code>OnDraw()</code> or it will not draw correctly.</p>
<h4 id='example-2'>EXAMPLE</h4>
<pre><code class='language-c++' lang='c++'>(.CPP)

void PGView::OnPaint()
{
CWnd::OnPaint();

// If you don&#39;t use the OnEraseBkgnd() member of the MFC class, 
// you must erase the background of the window first.

pgDisplay(m_Paige, NULL, MEM_NULL, MEM_NULL, NULL, bits_emulate_or);
}
</code></pre>
<h2 id='212-key-insertion'>2.12 Key Insertion</h2>
<p>HERMES Paige actually makes very little distinction between keyboard entry and any other text insertion, and in both cases the following function is used:</p>
<pre><code class='language-c' lang='c'>(pg_boolean) pgInsert (pg_ref pg, pg_char_ptr data, long length, long position, short insert_mode, short modifiers, short draw_mode);
</code></pre>
<p>This function will insert length bytes pointed to by data. The insertion will occur at byte offset position if it is positive or zero; if position is <code>CURRENT_POSITION</code> (a <code>#define</code>d constant of -1), the insertion occurs at the current insertion point.</p>
<p>The <code>insert_mode</code> parameter defines the type of data being inserted, which can be any of the following:</p>
<pre><code class='language-c' lang='c'>typedef enum
{
	key_insert_mode,		// Typing insertion
	key_buffer_mode,		// Typing-buffer insertion
	data_insert_mode,		// Raw data insertion
}
</code></pre>
<p>For keyboard entry, pass <code>key_insert_mode</code> or <code>key_buffer_mode</code>; for any other data insertion, pass <code>data_insert_mode</code>.</p>
<p>The difference between the two &quot;key&quot; insert modes and <code>data_insert_mode</code> is that a key insertion can contain special controls such as arrow keys and backspace (delete). For <code>data_insert_mode</code>, the bytes will be inserted as is.</p>
<p>If <code>key_insert_mode</code> is used, the new character(s) will draw immediately if <code>draw_mode</code> is nonzero.</p>
<p>If <code>key_buffer_mode</code> is used, character(s) will be buffered (temporarily saved) and drawn later by HERMES Paige; the purpose of this mode is to avoid &quot;getting ahead&quot; of keyboard entry on complex document entry. It is also useful for Macintosh double-byte script entry, in which the text is entered all at once from a floating palette window.</p>
<h5 id='note-windows-2'>NOTE (Windows)</h5>
<p>The <code>key_buffer_mode</code> is usually meaningless in the Windows environment; instead, you should always use <code>key_insert_mode</code> when processing keyboard characters. Using <code>key_buffer_mode</code> (where chars are stored and inserted later) requires a call to <code>pgIdle</code> which, under the Windows messaging system, would require you to set up a &quot;timer&quot; message that occurs every few milliseconds, which is probably not implemented in most applications.</p>
<p>If keys are buffered, HERMES Paige will display the new text during the first <code>pgIdle</code> function call (see section 2.15, <a href='#215-blinking-carets-and-mouse-selections'>Blinking Carets and Mouse Selections</a>).</p>
<h5 id='note-10'>NOTE</h5>
<p>&quot;Arrows&quot; and other control codes are defined (and changeable) in the <code>pg_globals</code> record (see section 3.8, <a href='#38-changing-globals'>Changing Globals</a>); these special controls will be processed correctly for <code>key_insert_mode</code> and <code>key_buffer_mode</code> only.</p>
<p>The <code>modifiers</code> parameter can change the way the <code>pg_ref</code> will respond to special control characters for <code>key_insert_mode</code> (<code>modifiers</code> is ignored for the other insertion modes). In the current version, the following value is supported:</p>
<pre><code class='language-c' lang='c'>#define EXTEND_MOD_BIT 0x0001	// Extend the selection
</code></pre>
<p>If <code>modifiers</code> is <code>EXTEND_MOD_BIT</code>, the selection range is extended if an arrow key is &quot;inserted.&quot; Other selection modifier bits are explained in <a href='#215-blinking-carets-and-mouse-selections'>Modifiers</a> under section 2.15, &quot;Blinking Carets and Mouse Selections&quot;.</p>
<p>The <code>draw_mode</code> for <code>pgInsert</code> performs identically to <code>pgDisplay</code> and can be any of the verbs defined for drawing. If you just want to insert but not display, pass <code>draw_none</code> for <code>draw_mode</code>. If <code>key_buffer_mode</code> is used for insertion, the <code>draw_mode</code> is saved and used later when the text is displayed.</p>
<p>For keyboard insertions, the recommended <code>draw_mode</code> is <code>best_way</code>.</p>
<h5 id='caution-macintosh'>CAUTION (Macintosh)</h5>
<blockquote><p>Mac developers should not confuse these modifier bits with the modifiers given in the event record. There is no similarity. The modifiers shown here are the ones HERMES Paige supports.</p>
</blockquote>
<h5 id='note-11'>NOTE</h5>
<p>The insertion will assume either the text format of the current insertion point OR the format of the last style/font/format change, whichever is more recent. This is true even if you specify an insert position other than the current point. If you want to force the insertion to be a particular font or style, simply call the appropriate function to change the text format prior to your insertion.</p>
<h5 id='function-result'>FUNCTION RESULT</h5>
<p>The function returns <code>TRUE</code> if the text and/or highlighting in <code>pg</code> changed in any way. Note that no change occurs only if <code>key_buffer_mode</code> is passed as the insert mode, in which case the characters are stored and not drawn until the next call to <code>pgIdle</code>. Another situation that will not change anything visually is passing <code>draw_none</code> as the <code>draw_mode</code>. In both cases, <code>pgInsert</code> would return <code>FALSE</code>. The purpose of this function result is for the application to know whether or not it should update scrollbar values or scroll to the insertion point, etc. (i.e., it is a waste of processing time to check or change scroll positions if nothing changed on the screen).</p>
<h4 id='running-unicode'>Running Unicode</h4>
<p>If you are using the Unicode-enabled HERMES Paige library, the &quot;data&quot; to be inserted is expected to be one or more 16-bit characters. The data size in this case is assumed to be a character count (not a byte count). This is due to the fact that if UNICODE is defined in your preprocessor or header files (which it should be for a true Unicode-enabled application), a <code>pg_char_ptr</code> changes from a byte pointer to a 16-bit character pointer.</p>
<p>For example, to insert the Unicode value 0x0041 (letter &quot;A&quot;) you would pass the value of 1 in the <code>length</code> parameter even though the character size is technically 2 bytes long.</p>
<h4 id='tech-note-insert-positions'>TECH NOTE: Insert Positions</h4>
<p>The specified insertion position is a zero-relative byte offset. Note that this is a byte—not a &quot;character&quot; offset (characters in HERMES Paige can be more than one byte), rather a byte offset from the beginning of all text in <code>pg</code>, starting at zero.</p>
<p><strong>EXCEPTION:</strong> The pure Unicode version measures everything as 16 bit characters. Hence, the insertion point in this case is a character position.</p>
<p>If one or more characters are currently selected (selection range ≥ one character), those characters are deleted before the insertion occurs. Note that if the specified insertion position were <code>CURRENT_POSITION</code>, the insertion will occur to the immediate left of the previously selected text (which will have been deleted).</p>
<p>After the insertion, the new insertion position in <code>pg</code> is advanced to length <code>bytes</code> from the original specified position. Example: If 100 bytes were inserted at text position 500 when <code>pgInsert</code> returns the current insertion position will be 600.</p>
<h5 id='applied-styles-and-insertion'>APPLIED STYLE(S) AND INSERTION</h5>
<p>If <code>pgInsert</code> occurs at the current insertion point, whatever the last style and/or font that was applied to that insertion point will be applied to the next insertion.</p>
<p>For example, suppose all text in <code>pg</code> is currently &quot;Helvetica&quot; font, and <code>pg</code> has a single insertion point (not a selected range of characters). Before inserting new text, a call is made to <code>pgSetFontInfo</code> with &quot;Times Roman&quot; font; the very next subsequent <code>pgInsert</code> would apply Times Roman—not Helvetica—to the new text.</p>
<p>However, if the insertion occurs somewhere other than the current insertion, the font/style that is applied will be whatever font/style applies to that position in text.</p>
<p>Hence, to implement the insertion of specific, multi-stylized text, the logic to perform should be as follows:</p>
<pre><code>pgSetStyleInfo(...) - and/or - pgSetFontInfo(...); 
pgInsert(..., CURRENT_POSITION,...); 
pgSetStyleInfo(...) - and/or - pgSetFontInfo(...); 
pgInsert(..., CURRENT_POSITION,...); etc.
</code></pre>
<p><strong>NOTE:</strong> For repetitive insertions, the insertion point will automatically advance the number of bytes you insert, so normally you should not need to set a new position if you are doing repetitive, sequential insertions.</p>
<p><strong>WARNING:</strong> If you need to apply a specific font or style to a text insertion (such as in the logic above), do not set the insertion point after you set the style/font or that style/font attribute may be lost. If you must set position, do so BEFORE calling pgSetFont/nfo or pgSetStyleInfo.</p>
<h5 id='example-3'>EXAMPLE </h5>
<p>WRONG WAY:</p>
<pre><code class='language-c' lang='c'>pgSetStyleInfo(...);
pgSetSelection(pg, 0, 0); //&lt;-- previous style setting is lost!
pgInsert(...);
</code></pre>
<p>RIGHT WAY:</p>
<pre><code class='language-c' lang='c'>pgSetSelection(pg, 0, 0);
pgSetStyleInfo(...); // &lt;-- Style gets applied to next insertion 
pgInsert(...);
</code></pre>
<h4 id='tech-note-nothing-happens'>TECH NOTE: Nothing happens</h4>
<blockquote><blockquote><p>Nothing seems to happen when I insert text.</p>
</blockquote>
</blockquote>
<p>If you are doing inserts with <code>key_insert_mode</code>, HERMES Paige won&#39;t do anything if the <code>pg_ref</code> is deactivated. That might be the problem. If so, you need to use <code>data_insert_mode</code>, not <code>key_insert_mode</code>, and it will then work; <code>pgInsert</code> does nothing.</p>
<h2 id='213-keyboard-editing-with-mfc-windows'>2.13 Keyboard Editing with MFC (Windows)</h2>
<p>To get <em>Up and Running</em> with basic keyboard editing you must add the following code to your MFC view class:</p>
<pre><code class='language-c++' lang='c++'>(.H) 
// Declare the following private variables. 
short m_KeyModifiers;

(.CPP)

// Respond to the windows message WM_KEYDOWN... 
void PGView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
pg_globals globals = ((MyWinApp*)AfxGetApp()) -&gt; m_Globals;
pg_short_t verb;

	switch(nChar)
	{
		case VK_SHIFT:
			m_KeyModifiers != EXTEND_MOD_BIT;
			break;
		case VK_CONTROL:
			m_KeyModifiers != CONTROL_MOD_BIT;
			break;
		case VK_LEFT:
			SendMessage(WM_CHAR, globals -&gt; left_arrow_char);
			break;
		case VK_UP:
			SendMessage(WM_CHAR, globals -&gt; up_arrow_char);
			break;
		case VK_RIGHT:
			SendMessage(WM_CHAR, globals -&gt; right_arrow_char);
			break;
		case VK_DOWN:
			SendMessage(WM_CHAR, globals -&gt; down_arrow_char);
			break;
		case VK_HOME:
			verb = begin_line_caret;
			if(m_KeyModifiers &amp; CONTROL_MOD_BIT)
				verb = home_caret;
			if(m_KeyModifiers &amp; EXTEND_MOD_BIT)
				verb != EXTEND_CARET_FLAG;
			pgSetCaretPosition(mPaige, verb, TRUE);
			pgScrollToView(m_Paige, CURRENT_POSITION, 0, 0, TRUE, bits_emulate_or;
			break;
		case VK_END:
			verb = end_line_caret;
			if(m_KeyModifiers &amp; CONTROL_MOD_BIT)
				verb = doc_bottom_caret;
			if(m_KeyModifiers &amp; EXTEND_MOD_BIT)
				verb != EXTEND_CARET_FLAG;
			pgSetCaretPosition(m_Paige, verb, TRUE);
			pgScrollToView(m_Paige, CURRENT_POSITION, 0, 0, TRUE, bits_emulate_or;
			break;
		case VK_PRIOR:
			SendMessage(WM_VSCROLL, SB_PAGEUP);
			break;
		case VK_DELETE:
			if(m_KeyModifiers &amp; EXTEND_MOD_BIT)
			{
				long start, end;
				pg_ref scrap;
				pgGetSelection(m_Paige, &amp;start, &amp;end);
				if(start == end)
					return;
				scrap = pgCut(m_Paige, &amp;start, &amp;end);
				assert(scrap);
				OpenClipboard();
				pgPutScrap(scrap, 0, pg_void_scrap);
				CloseClipboard();
				pgDispose(scrap);
				scrap = MEM_NULL;
				SetChanged();
			}
			else
			{
				SendMessage(WM_CHAR, globals-&gt;fwd_delete_char);
			}
		case VK_NEXT:
			SendMessage(WM_VSCROLL, SB_PAGEDOWN);
			break;
			pgScrollToView(m_Paige, CURRENT_POSITION, 0, 0, TRUE, bits_emulate_or);
			break;
	}
}
			break;
		case VK_INSERT:
		{
		if(m_Key_Modifiers &amp; CONTROL_MOD_BIT
			{
				long start, end;
				pg_ref scrap;
				pgGetSelection(m_Paige, &amp;start, &amp;end);
				if(start == end)
					return;
				scrap = pgCopy(m_Paige, NULL);
				assert(scrap);
				OpenClipboard();
				pgPutScrap(scrap, 0, pg_void_scrap);
				CloseClipboard();
				pgDispose(scrap);
			}
		else if(m_KeyModifiers &amp; EXTEND_MOD_BIT)
			{
				pg_ref scrap = MEM_NULL;
				OpenClipboard();
				scrap = pgGetScrap(globals, 0, HookEmbedProc);
				CloseClipboard();
				if scrap
				{
					pgPaste(m_Paige, scrap, CURRENT_POSITION, false, best_way);
					pgDispose(scrap)
				}
			}
		}
		pgScrollToView(m_Paige, CURRENT_POSITION, 0, 0, TRUE, bits_emulate_or);
		break;
	}
}

// Respond to the Windows message WM_KEYUP...
void MyView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	switch(nChar)
	{
		case VK_SHIFT:
			m_KeyModifiers &amp;= (~EXTEND_MOD_BIT);
			break;
		case VK_CONTROL:
			m_KeyModifiers &amp;= (~CONTROL_MOD_BIT);
			break;
	}
}

// Respond to the Windows message WM_CHAR...
void MyView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	pg_char the_char = (pg_char)nChar;
	pgInsert(mPaige, &amp;the_char, 1, CURRENT_POSITION, key_insert_mode, m_KeyModifiers, best_way);
	pgScrollToView(m_Paige, CURRENT_POSITION, 0, 0, TRUE, bits_emulate_or);
}
</code></pre>
<h2 id='214-pending-buffer-insertions'>2.14 Pending Buffer Insertions</h2>
<p>As mentioned in <code>pgInsert</code>, if <code>key_buffer</code> mode is used, the characters get stored in an internal buffer and get inserted during the next <code>pgIdle</code>.</p>
<p>There might be an occassion, however, that requires immediate insertion of anything pending in this buffer. To do so, call the following:</p>
<pre><code class='language-c' lang='c'>(pg_boolean) pgInsertPendingKeys (pg_ref pg);
</code></pre>
<p>Calling this function will immediately &quot;empty&quot; any pending characters, inserting and displaying them as appropriate. If there aren&#39;t any pending characters, <code>pgInsertPendingKeys</code> does nothing. The function returns <code>TRUE</code> if one or more characters were inserted.</p>
<h5 id='note-12'>NOTE</h5>
<p>The display mode used when HERMES Paige displays the pending buffer will be the original display mode passed to <code>pgInsert</code>.</p>
<h2 id='215-blinking-carets-and-mouse-selections'>2.15 Blinking Carets and Mouse Selections</h2>
<h3 id='caret-blinking-macintosh-only'>Caret blinking (Macintosh only)</h3>
<p>To cause the &quot;caret&quot; to blink in a <code>pg_ref</code>, call the following as often as possible:</p>
<pre><code class='language-c' lang='c'>(pg_boolean) pgIdle (pg_ref pg);
</code></pre>
<h5 id='note-macintosh-2'>NOTE (Macintosh): </h5>
<p><code>pgIdle</code> should be called repeatedly while you are waiting for an event.</p>
<p>The <code>pg</code> parameter must be a valid <code>pg_ref</code> (can not be a null pointer).</p>
<p><strong>FUNCTION RESULT:</strong> The function returns <code>TRUE</code> if character(s) were inserted and displayed that were stored previously from <code>pgInsert</code> calls with <code>key_buffer_mode</code>. This will only happen if you had called <code>pgInsert</code>, passing <code>key_buffer_mode</code> as the data transfer parameter. A result of <code>TRUE</code> or <code>FALSE</code> from <code>pgIdle</code> can help your application know whether or not it should update scrollbar values (since new text has been inserted). For Windows <code>key_buffer_mode</code> is not usually necessary (see section 2.12, <a href='#212-key-insertion'>Key Insertion</a>).</p>
<h5 id='note-windows-3'>NOTE (Windows)</h5>
<p>You do not need to call <code>pgIdle()</code> since the blinking caret is maintained by the OS. Needlessly calling <code>pgIdle</code>, however, is harmless.</p>
<h3 id='clicking--dragging'>Clicking &amp; Dragging</h3>
<p>Clicking and dragging is accomplished by using the following function:</p>
<pre><code class='language-c' lang='c'>(long) pgDragSelect (pg_ref pg, co_ordinate_ptr location, short verb, short modifiers, long track_refcon, short auto_scroll);
</code></pre>
<p>To change the insertion point in a <code>pg_ref</code> (i.e., in response to a mouse click), call <code>pgDragSelect</code> with the <code>location</code> parameter set to the location of the &quot;click.&quot; The coördinate values must be local to the window&#39;s coördinate system (relative to the top-left window origin).</p>
<p>For <strong>Macintosh</strong>, location should be the same as the &quot;where&quot; member of the <code>EventRecord</code>, converted to local coördinates.</p>
<p>For <strong>Windows</strong>, location is usually the coördinates given to you in <code>lParam</code> when responding to <code>WM_LBUTTONDOWN</code>, <code>WM_LBUTTONDBLCLK</code>, or <code>WM_MOUSEMOVE</code>.</p>
<p>The <code>verb</code> parameter defines what action should occur, which must be one of the following:</p>
<pre><code class='language-c' lang='c'>enum
{
	mouse_down,		// First-time click
	mouse_moved,	// Mouse moved
	mouse_up,			// Mouse button released
}
</code></pre>
<p><strong>NOTE:</strong> <code>pgDragSelect()</code> does not retain control at any time—it always returns control immediately regardless of what <code>verb</code> is passed.</p>
<p>For the first click, pass <code>mouse_down</code> in verb.</p>
<p>In a <em>Macintosh-specific</em> application, while the user is holding down the mouse button, wait for the mouse location to change and, if it does, call <code>pgDragSelect</code> with the new location but with <code>verb</code> as <code>mouse_moved</code>.</p>
<p>In a <em>Windows-specific</em> application, call <code>pgDragSelect(mouse_moved)</code> in response to a <code>WM_MOUSEMOVE</code> if the mouse button is still down.</p>
<p>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; When the mouse button is released, pass the final location and <code>mouse_up</code> for <code>verb</code>.</p>
<h5 id='note-13'>NOTE</h5>
<p>It is important to call <code>pgDragSelect</code> with <code>mouse_up</code> after the user releases the mouse button <em>even if the mouse never moved from its original location</em>. This is because HERMES Paige performs certain housekeeping chores when <code>mouse_up</code> is given.</p>
<p>The <code>modifiers</code> parameter controls the way text is selected. For &quot;normal&quot; click/drag, pass zero for this parameter; for added effects (such as responding to double-clicks, shift-clicks, etc.), see [Modifiers][#2.15-Blinking-Carets-&amp;-Mouse-Selections] under section 2.15, &quot;Blinking Carets and Mouse Selections&quot;.</p>
<p>If <code>auto_scroll</code> is <code>TRUE</code>, HERMES Paige will automatically scroll the document if <code>pgDragSelect</code> (with <code>verb</code> as <code>mouse_moved</code>) has gone beyond the <code>vis_area</code>. See chapter 11, <a href='#11-all-about-scrolling'>All About Scrolling</a>. For getting &quot;Up and Running&quot;, you can pass <code>TRUE</code> for this parameter.</p>
<p><code>track_refcon</code> is used when and if HERMES Paige makes a call to the track-control-callback function. If a style is a &quot;control&quot; (the control bit set for the style class bits field), HERMES Paige calls the tracking control function hook and passes the <code>track_refcon</code> to the app. In other words, this value is application-defined and HERMES Paige does nothing with it. For getting &quot;Up and Running&quot;, you can pass 0 for this parameter.</p>
<h5 id='function-result-2'>FUNCTION RESULT</h5>
<p>For &quot;normal&quot; mouse tracking, ignore the function result of <code>pgDragSelect</code>. The only time the function result is significant is when you have customised a style to be a &quot;control&quot; (information is available on &quot;control&quot; styles under &quot;Customising HERMES Paige”). If you have not customised HERMES Paige in any way, <code>pgDragSelect</code> will always return zero.</p>
<h3 id='modifiers'>Modifiers</h3>
<p>The following bit settings are supported for the <code>modifiers</code> parameter in this release:</p>
<pre><code class='language-c' lang='c'>#define EXTEND_MOD_BIT		0x0001	// Extend the selection
#define WORD_MOD_BIT			0x0002	// Select whole words only
#define PAR_MOD_BIT				0x0004	// Select whole paragraphs only
#define LINE_MOD_BIT			0x0008	// Highlight whole lines
#define VERTICAL_MOD_BIT	0x0010	// Allow vertical selection
#define DIS_MOD_BIT				0x0020	// Enable discontinuous selection
#define STYLE_MOD_BIT			0x0040	// Select whole style range
#define WORD_CTL_MOD_BIT	0x0080	// Select &quot;words&quot; delimited by ctrl chars
#define NO_HALF_CHARS_BIT	0x0100	// Do not go left/right on half chars
#define CONTROL_MOD_BIT		0x0200	// Word advance for arrows
</code></pre>
<p>Various combinations of these bits can generally be set to create the desired effect such as word selections, paragraphs selections, etc., save that vertical selection does not work with the other modifiers. If misused regardless, it will produce unpredictable results.</p>
<p>The following is a description of how text is highlighted in response to each of these bits:</p>
<p><code>EXTEND_MOD_BIT</code> will extend the selection for <code>verb</code> of <code>mouse_down</code> (otherwise the previous selection is removed). For Macintosh, this is the same as &quot;shift-click&quot; (but you need to determine that from your application and set this bit).</p>
<p><code>WORD_MOD_BIT</code> will select whole words, otherwise only single characters are selected.</p>
<p><code>PAR_MOD_BIT</code> will select whole paragraphs.</p>
<p>This is different than <code>LINE_MOD_BIT</code> (below) since a paragraph could contain several lines if word wrapping exists.</p>
<p><code>LINE_MOD_BIT</code> will select whole lines. This differs from <code>PAR_MOD_BIT</code> since a paragraph might consist of many lines.</p>
<p><code>VERTICAL_MOD_BIT</code> allows vertical selection. This bit really causes a rectangular region that selects all characters intersecting that region and will not follow any particular character. <code>VERTICAL_MOD_BIT</code> is mainly useful for tables and tabular columns.</p>
<p><code>DIS_MOD_BIT</code> allows discontinuous selections. If this bit is set, the previous selection remains and a new selection range is started (HERMES Paige can have multiple selection ranges).</p>
<p><code>STYLE_MOD_BIT</code> causes whole style ranges to become selected. This is similar to word/paragraph/line highlighting except style changes are considered the delimiters (which also means the whole document could be selected in one click if only one style exists).</p>
<p><code>WORD_CTL_MOD_BIT</code> causes text between control characters to be selected. This is similar to word/paragraph/line highlighting except control codes are considered the delimiters.</p>
<blockquote><p><strong>NOTE:</strong> In HERMES Paige &quot;control codes&quot; or &quot;control characters&quot; are not necessarily limited to standard ASCII symbols. Control characters in the HERMES Paige context are defined in <code>pg_globals</code> (see &quot;Changing Globals”<!-- on page 3-21-->).</p>
</blockquote>
<p><code>NO_HALF_CHARS_BIT</code> controls whether or not dragging can change the selection point half way into a character. Normally, if this bit is not set, once the mouse moves half way into a character, that character is considered to be &quot;selected&quot; (or unselected if moving in the opposite direction). Setting this bit, however, instructs <code>pgDragSelect</code> not to select the character until it has completely crossed over its area.</p>
<p><code>CONTROL_MOD_BIT</code> is used mainly with arrow keys. This causes the selection to advance to the next word (right arrow) or to the previous word (left arrow).</p>
<p>For additional information about highlighting and selection range(s), see chapter 10, <a href='#10-all-about-selection'>All About Selection</a>.</p>
<h2 id='216-click--drag-using-microsoft-foundation-classes-windows'>2.16 Click &amp; Drag using Microsoft Foundation Classes (Windows)</h2>
<p>To get Up and Running with simple mouse drag select in MFC, use the following code as a starting point:</p>
<pre><code class='language-c' lang='c'>(.H)
/* Declare the following private variables. Make sure to set m_Dragging to FALSE in the construct to avoid the unintialized variable bug!! */

short m_MouseModifiers;
BOOL m_Dragging;

(.CPP)
// Respond to the Windows message WM_LBUTTONDOWN...
void MyView::OnLButtonDown(UINT nFlags, CPoint point)
{
	CView::OnLButtonDown(nFlags, point);
	co_ordinate mouse { point.y, point.x };
	SetCapture();
	m_Dragging $=$ TRUE;
	if(nFlags &amp; MK_SHIFT)
		m_MouseModifiers != EXTEND_MOD_BIT;
	if(nFlags &amp; MK_CONTROL)
		m_MouseModifiers != PAR_MOD_BIT;
		pgDragSelect(m_Paige, &amp;mouse, mouse_down, m_MouseModifiers, 0, TRUE);
}

// Respond to the Windows WM_MOUSEMOVE message...
void MyView::OnMouseMove(UINT nFlags, CPoint point)
{
	CView::OnMouseMove(nFlags, point);
	co_ordinate pg_mouse = {point.y, point.x};
	if(m_Dragging)
	{
		pgDragSelect(m_Paige, &amp;mouse, mouse_up, m_MouseModifiers, 0, FALSE);
		m_MouseModifiers = 0;
		ReleaseCapture();
		m_Dragging = FALSE;
	}
}
</code></pre>
<h4 id='responding-to-windows-mouse-events'>Responding to Windows mouse events</h4>
<pre><code class='language-c' lang='c'>case WM_LBUTTONDBLCLK:
pg_modifiers = pg_modifiers = WORD_MOD_BIT;

// fall through to WM_LBUTTONDOWN

case WM_LBUTTONDOWN:
if(pgRef)
{
		co_ordinate pg_mouse;
		mouse_contact = TRUE;
		SetCapture(hWnd);
		pg_mouse.h = lParam &amp; OxFFFF;
		pg_mouse.v = ((lParam &amp; OxFFFF0000) &gt;&gt; 16);
	
	if (wParam &amp; MK_SHIFT)
	pg_modifiers != EXTEND_MOD_BIT;
	
	if (wParam &amp; MK_CONTROL)
	pg_modifiers != DIS_MOD_BIT;
	pgDragSelect(pgRef, &amp;pg_mouse, mouse_down, pg_modifiers, 0, TRUE);
}
return 0 ;

case WM_LBUTTONUP:
	if(pgRef)
	{
		co_ordinate pg_mouse;
		pg_mouse.h = lParam &amp; OxFFFF;
		pg_mouse.v = ((lParam &amp; OxFFFF0000) &gt;&gt; 16);
		mouse_contact = FALSE;
		pgDragSelect(pgRef, &amp;pg_mouse, mouse_up, pg_modifiers, 0, FALSE);
		pg_modifiers = 0;
		ReleaseCapture();
	}
return 0;

case WM_MOUSEMOVE:
	if(mouse_contact)
		pgDragSelect(pgRef, &amp;pg_mouse, mouse_moved, pg_modifiers, 0, TRUE);
	else
	{
		pg_view = pgPtInView(pgRef, &amp;pg_mouse, NULL);
		
		if (pg_view &amp; WITHIN_TEXT)
			SetCursor(LoadCursor(NULL, IDC_IBEAM));
		else
			SetCursor(LoadCursor(MULL, IDC_ARROW));
	}
}
return 0;
</code></pre>
<h3 id='tech-note-turn-automatic-scroll-off'>TECH NOTE: Turn automatic scroll off</h3>
<p>To prevent selecting/scrolling you would simply pass FALSE for <code>pgDragSelect</code> so it doesn&#39;t try to auto-scroll. As far as not letting the user select text outside the visual area, I would simply check to see if the coördinate that will get passed to <code>pgDragSelect</code> is outside of the view area and if it is, just force it to some other point that is within the view area.</p>
<p>In fact, you wouldn&#39;t even need to turn off auto-scroll if you forced the coördinate to always be within the visual area. Remember, you have complete control over <code>pgDragSelect</code> (control always comes back to you unlike, say, <code>TrackControl</code> on Macintosh) so there is no reason you can&#39;t adjust the &quot;mouse&quot; point for each pass.</p>
<h3 id='tech-note-problems-with-mouse-clicks--1-mac-only'>TECH NOTE: Problems with mouse clicks -1 (Mac only)</h3>
<blockquote><p>I have big troubles handling mouse clicks in the HERMES Paige object within my class library. If I get a click (with <code>GetMouse(&amp;hitPt)</code>) and do the following (testing a response to a simple click)...</p>
</blockquote>
<p>Your test code sample should work. Therefore, I have to conclude there is something wrong with the mouse point you obtain with <code>GetMouse()</code>.</p>
<p>I would guess that you are doing a <code>GetMouse()</code> without regards to the current <code>GrafPort</code>. Since <code>GetMouse()</code> returns a <code>LOCAL</code> point (based on current port&#39;s coördinates), if you don&#39;t have the correct <code>GrafPort</code> set you will get some other coördinate system. Worst case, you are getting &quot;global&quot; coördinates which will be completely different than what you expect.</p>
<p>Or, another possibility might have to do with the window&#39;s &quot;origin&quot;. I know that some class libraries muck with this to create scrolling effects.</p>
<p>What you need to do is to check what the actual values of <code>point.h</code> and <code>point.v</code> really are. I know that <code>pgDragSelect</code> works; in fact, you should see the caret immediately appear at the point you give for <code>mouse_down</code> verb.</p>
<p>BTW, the usual (best) way for dragging the mouse in a <code>pg_ref</code> is to get the click right out of the <code>EventRecord.where</code> field (first doing a <code>GlobalToLocal</code> on it). That is by far the most accurate -- but I do not know if that <code>EventRecord</code> is easily available in your class library.</p>
<h2 id='217-activatedeäctivate'>2.17 Activate/Deäctivate</h2>
<p>To deäctivate a <code>pg_ref</code> (to cause highlighting or the &quot;caret&quot; to disappear), call the following function:</p>
<pre><code>(void) pgSetHiliteStates (pg_ref pg, short front_back_state, short perm_state, pg_boolean show_hilite);
</code></pre>
<p>In a &quot;window&quot; environment, where different windows can overlap, it is usually desirable to disable any HERMES Paige objects that are not contained in the front most window. To do so, <code>pgSetHiliteState</code> can be called to turn off the highlighting or the &quot;caret.&quot;</p>
<p>An HERMES Paige object, however, contains two highlight states, one for &quot;front/back&quot; activate and deactivate and one to disable a <code>pg_ref</code> in both states. For &quot;normal&quot; applications, you will only be changing the front/back highlight state (activate or deactivate a <code>pg_ref</code> according to its window position). The purpose of the alternate highlight state is to provide a way to disable a <code>pg_ref</code> completely regardless of its window position.</p>
<p>The <code>front_back_state</code> should be one of the following values:</p>
<pre><code>typedef enum
{
	no_change_verb,	// State stays the same
	activate_verb,	// Set to activate mode
	deactivate_verb,	// Set to deactivate mode
}
</code></pre>
<p>The <code>perm_state</code> parameter provides an alternate highlight state setting; this parameter can also be any of the above. For getting &quot;Up and Running,&quot; however, pass <code>no_change_verb</code> for this parameter.</p>
<p>If <code>show_hilite</code> is <code>TRUE</code>, the highlighting (or caret) will redraw according to <code>pg</code>&#39;s new state. A <code>FALSE</code> value will activate or deactivate <code>pg</code> internally (by setting special flags within the <code>pg_ref</code>) but the highlighting or caret will remain unchanged. For getting &quot;Up and Running&quot;, always pass TRUE for <code>should_draw</code>.</p>
<p>See also &quot;Additional Selection Support&quot; <!-- on page 10-4--> and &quot;Activate/Deactivate with shape of selection still showing&quot;<!-- on page 10-13-->.</p>
<h3 id='responding-to-wmsetfocus-and-wmkillfocus-messages'>Responding to <code>WM_SETFOCUS</code> and <code>WM_KILLFOCUS</code> messages</h3>
<pre><code>{
case WM_KILLFOCUS:
	pgSetHiliteStates(pgRef, deactivate_verb, no_change_verb, TRUE);

case WM SETFOCUS:
	pgSetHiliteStates(pgRef, activate_verb, no_change_verb, TRUE);
}
</code></pre>
<h3 id='getting-the-highlight-state'>Getting the Highlight State</h3>
<p>If you want to know what state a <code>pg_ref</code> is in, call the following:</p>
<pre><code>(void) pgGetHiliteStates (pg_ref pg, short PG_FAR *front_back_state, short PG_FAR *perm_state);
</code></pre>
<p>The front/back highlight state will be returned in <code>front_back_state</code> and the alternate state in <code>perm_state</code>. Both parameters will be set to either <code>activate_verb</code> or <code>deactivate_verb</code>.</p>
<h5 id='notes-2'>NOTES</h5>
<ol start='' >
<li>If the highlight status is already set to what is specified in your parameters (e.g., if you are deactivating a <code>pg_ref</code> that is already deactivated or vice versa), this function does nothing.</li>
<li>A <code>pg_ref</code> returned from <code>pgNew</code> is set to an active state.</li>
<li>If a <code>pg_ref</code> is in a deactivate state, the caret will not blink even if you call pgIdle and highlighting will not draw.</li>

</ol>
<h3 id='tech-note-2'>TECH NOTE</h3>
<blockquote><p>Why two activate states?</p>
</blockquote>
<p>One is for regular activate/deactivate for a window; the other is to FORCE deactivation regardless of the window&#39;s front/behind state. Haven&#39;t you ever been in a situation where you want to deactivate selections but the window is still in front? Using two possible states, it becomes easier to do that. The two states are logically &quot;AND&#39;d&quot; logic for activation: both must be true or the document is deactivated.</p>
<h4 id='mfc-note-2'>MFC NOTE </h4>
<p><strong>IMPORTANT:</strong> You must activate and deactivate the HERMES Paige object in the MFC OnSetFocus() and OnKillFocus() before any of the functions in this chapter will work.</p>
<h4 id='example-4'>Example:</h4>
<pre><code>(.CPP)

// Respond to Windows message WM_SETFOCUS...
void MyView::OnSetFocus(CWnd* pOldWnd)
{
	CView::OnSetFocus(pOldWnd);
	pgSetHiliteStates(m_Paige, activate_verb, no_change_verb, TRUE);
}

// Respond to Windows message WM_KILLFOCUS...
void MyView::OnKillFocus(CWnd* pNewWnd)
{
	pgSetHiliteStates(m_Paige, deactivate_verb, no_change_verb, TRUE);
	CView::OnKillFocus(pNewWnd);
}
</code></pre>
<p>	</p>
<h1 id='3-beyond-the-defaults'>3 BEYOND THE DEFAULTS</h1>
<p>The purpose of this section is to explain some of the more common additions and/or changes to the &quot;bare minimum&quot; implementation discussed in the previous section, &quot;Up and Running.&quot;</p>
<h2 id='31-changing-attributes'>3.1 Changing Attributes</h2>
<p>There will be situations where you want to change the attributes of an HERMES Paige object after it is created (these are the bits initially passed to <code>pgNew</code> for the &quot;attributes&quot; parameter). There are also situations where you want to examine the current attributes (to tick a menu item, for instance). To do so, use the following:</p>
<pre><code class='language-c' lang='c'>(long) pgGetAttributes (pg_ref pg);
(pg_boolean) pgSetAttributes (pg_ref pg, long attributes);
</code></pre>
<p>To obtain the current attribute bits, call <code>pgGetAttributes</code>.</p>
<p><strong>FUNCTION RESULT:</strong> The function result will be the current setting(s) of pg.</p>
<p>To change the attributes, call <code>pgSetAttributes</code> with attributes set to the new bit value(s).</p>
<p>HERMES Paige &quot;attributes&quot; are defined as bit settings which can be a combination of any bit values shown below:</p>
<pre><code class='language-c' lang='c'>#define NO_WRAP_BIT					0x00000001	// Wraps only on CR or LF
#define NO_LF_BIT						0x00000002	// &lt;LF&gt; char ignored
#define NO_DEFAULT_LEADING	0x00000004	// Do not add font leading
#define NO_EDIT_BIT					0x00000008	// No editing (display only)
#define EXTERNAL_SCROLL_BIT	0x00000010	// App controls scrolling
#define COUNT_LINES_BIT			0x00000020	// Track line/para count
#define NO_HIDDEN_TEXT_BIT	0x00000040	// Do not display hidden text
#define SHOW_INVIS_CHAR_BIT	0x00000080	// Show invisible character(s)
#define EX_DIMENSION_BIT		0x00000100	// Exclude width/height
#define NO_WINDOW_VIS_BIT		0x00000200	// Do not respect clipped area
#define SMART_QUOTES_BIT		0x00000800	// Do &quot;smart&quot; quotes
#define NO_SMART_CUT_BIT		0x00001000	// Do not do &quot;smart&quot; cut/paste
#define NO_SOFT_HYPHEN_BIT	0x00002000	// Ignore soft hyphens
#define NO_DUAL_CARET_BIT		0x00004000	// Do not show dual carets
#define SCALE_VIS_BIT				0x00008000	// Scale vis_area when scaling
#define BITMAP_ERASE_BIT		0x00010000	// Erase page(s) with bitmap drwg
#define TABS_ARE_WIDTHS_BIT	0x10000000	// Tab chars are merely wides
#define LINE_EDITOR_BIT			0x40000000	// Doc is line editor mode
</code></pre>
<p>These are described in section 2.8, <a href='#28-attribute-settings'>Attribute Settings</a>.</p>
<p><strong>FUNCTION RESULT:</strong> After calling <code>pgSetAttributes</code>, the function result will be <code>TRUE</code> if <code>pg</code> should be redrawn. The only time <code>TRUE</code> is returned is when one or more attributes have been set that will affect the way text is drawn or the way word wrap is computed.</p>
<p><strong>WARNING:</strong> Before setting attributes, first get the current settings from the function <code>pgGetAttributes</code> and change the bits you require and pass that whole long value to <code>pgSetAttributes</code>. Otherwise, the <code>view only</code> bits will get changed erroneously.</p>
<p>Additional attributes can be set for more advanced features using the following <code>set</code> and <code>get</code> functions:</p>
<pre><code class='language-c' lang='c'>(pg_boolean) pgSetAttributes2 (pg_ref pg, long attributes); (long) pgGetAttributes2 (pg_ref pg);
</code></pre>
<p>To obtain the current, extended attribute bits, call <code>pgGetAttributes2</code>.</p>
<p><strong>FUNCTION RESULT:</strong> The function result will be the current setting(s) of the extended attributes of <code>pg</code>.</p>
<p>To change the extended attributes, call <code>pgSetAttributes2</code> with attributes set to the new bit value(s).</p>
<p>HERMES Paige &quot;extended attributes&quot; are defined as bit settings which can be a combination of any of the following.</p>
<pre><code class='language-c' lang='c'>#define KEEP_READ_STYLES		0x00000200	// Keep existing style_infos for pgReadDoc()
#define KEEP_READ_PARS			0x00000400	// Keep existing par_infos for pgReadDoc()
#define KEEP_READ_FONTS			0x00000800	// Keep existing font_infos for pgReadDoc()
#define CHECK_PAGE_OVERFLOW	0x00002000	// Constantly check page overflow
#define NO_HAUTOSCROLL			0x00080000	// Do not autoscroll horizontally
#define NO_VAUTOSCROLL			0x00100000	// Do not autoscroll vertically
</code></pre>
<p><code>KEEP_READ_STYLES</code> tells HERMES Paige to not remove existing <code>style_info</code> records from the <code>pg_ref</code> when a file is read. Normally, all existing style records are replaced with the styles read from an HERMES Paige file. This attribute is used to retain the existing styles.</p>
<p><code>KEEP_READ_PARS</code> tells HERMES Paige to not remove existing <code>par_info</code> records from the <code>pg_ref</code> when a file is read. Normally, all existing paragraph records are replaced with the paragraph records read from an HERMES Paige file. This attribute is used to retain the existing paragraph records.</p>
<p><code>KEEP_READ_FONTS</code> tells HERMES Paige to not remove existing <code>font_info</code> records from the <code>pg_ref</code> when a file is read. Normally, all existing font records are replaced with the fonts read from an HERMES Paige file. This attribute is used to retain the existing fonts.</p>
<p><code>CHECK_PAGE_OVERFLOW</code> tells HERMES Paige to constantly test the position of the last character in the document and, if it overflows the bottom of the <code>page_area</code>, sets an internal field to the number of characters that have overflowed. The purpose of this attribute is to allow an application to implement features that require &quot;page overflow checking&quot;, but since this requirement requires constant pagination and extra processing, set this attribute only when absolutely necessary.</p>
<p><code>NO_HAUTOSCROLL</code>, <code>NO_VAUTOSCROLL</code> tells HERMES Paige not to automatically scroll horizontally or vertically, respectively, when <code>pgDragSelect()</code> is called.</p>
<h2 id='auto-checking-page-overflow'>&quot;Auto-checking&quot; page overflow</h2>
<p>Setting <code>CHECK_PAGE_OVERFLOW</code> with <code>pgSetAttribute2()</code> causes HERMES Paige to continuously check the situation where character(s) flow below the boundaries of the page area. If this attribute is set, the <code>overflow_size</code> member within the <code>pg_ref</code> get set to the number of characters that overflow the page.</p>
<p>Or, if <code>overflow_size</code> is set to -1, a single carriage return is causing the overflow (i.e., the text overflows but the overflow is a &quot;blank&quot; line).</p>
<p><strong>NOTE:</strong> The auto-checking for page overflow is meaningless if your <code>pg_ref</code> is set for repeating pages, or if your <code>pg_ref</code> is set to a variable page size. The only time overflow checking will work (or make any sense) is for fixed-size, nonrepeating page shapes.</p>
<h2 id='checking-page-overflow'>Checking page overflow</h2>
<p><strong>NOTE:</strong> You should not implement this code if your <code>pg_ref</code> is set for repeating pages, or if your <code>pg_ref</code> is set for a variable document height.</p>
<pre><code>/* Call the function below after doing anything that can change the size of the document. This included insertions, deletions, style and font changes (which can cause new word wrapping) and page size changes. This function returns the number of characters that are overflowing the page area of pg. */

/* Note: CHECK_PAGE_OVERFLOW must be set with pgSetAttributes2(pg). */

long CheckPageOverflow (pg_ref pg)
{
	paige_rec_ptr pg_rec;
	long_overflow_amount;
	
	pg_rec = UseMemory(pg);
	overflow_amount = pg_rec-&gt;overflow_size;
	UnuseMemory(pg);
	
	return overflow_amount;
}
</code></pre>
<h3 id='tech-note-carriage-returnline-feeds-causing-problems'>TECH NOTE: Carriage return/line feeds causing problems</h3>
<p>Regarding LF/CR characters, HERMES Paige handles both of them as a &quot;new line&quot; except a CR. It also starts a new paragraph, but for LF it just does a line feed.</p>
<p>Note that lines that terminate both in LF and CR will cause <em>two</em> lines on the screen — at least in HERMES Paige default mode.</p>
<p>You can turn that off, however, if you want LF/CR to be treated as only one líne feed.&#39; To do so, just set <code>NO_LF_BIT</code> in the HERMES Paige attribute flags during <code>pgNew</code>. When this attribute is set, HERMES Paige ignores all LFs embedded in the text (they become invisible).</p>
<p>Note that I haven&#39;t mentioned what the values are for LF and CR, because those are whatever values sit in HERMES Paige globals. Also as mentioned, MPW will compile <code>\r</code> etc. differently than Symantec so watch out for that. See technical note <a href='#tech-note-crlf-conversion'>CR/LF Conversion</a> and section 3.8, <a href='#38-changing-globals'>Changing Globals</a>.</p>
<h2 id='33-a-different-default-font-style-paragraph'>3.3 A Different Default Font, Style, Paragraph</h2>
<p>Any time a new <code>pg_ref</code> is created, HERMES Paige sets the initial <code>style_info</code>, <code>font_info</code> and <code>par_info</code> (style, font and paragraph format) to whatever exists in the corresponding field from <code>pg_globals</code>.</p>
<p>Hence, to set default style, font or paragraph format, simply change the respective information in <code>pg_globals</code> (see example below).</p>
<p>To change the default style information, change field(s) in <code>pg_globals.def_style</code>; to change the default font, change field(s) in <code>pg_globals.def_font</code>; to change the default paragraph format, change field(s) in <code>pg_globals.def_par</code>.</p>
<p>You can also set the default low-level callback &quot;hook&quot; functions for style or paragraph records, and even the general HERMES Paige functions by placing a pointer to the new function in the respective <code>pg_globals</code> field. See chapter 27, <a href='#27-customising-hermes-paige'>Customising HERMES Paige</a>.</p>
<p>For example, if you wanted to override the draw-text callback function always for all styles, you would change the default draw-text function in the default style found in <code>pg_globals</code> before your first call to <code>pgNew</code> (but after <code>pgInit</code>:</p>
<pre><code>pg_globals.def_style.procs.draw = myTextDrawProc;
</code></pre>
<p>... where <code>myTextDrawProc</code> is a low-level callback to draw text (see &quot;Setting Style Functions”<!-- on page 27-4-->). If you did this, every new <code>style_info</code> record created by HERMES Paige will contain your callback function.</p>
<p>The default hooks for general callbacks not related to styles or paragraph formats are in <code>pg_globals.def_hooks</code>.</p>
<p>See a complete description of <code>style_info</code>, <code>font_info</code> and <code>par_info</code> records in chapter 8, <a href='#8-style-basics'>Style Basics</a>.</p>
<h3 id='change-defaults-after-they-are-created-using-pginit'>Change defaults after they are created using <code>pgInit</code>.</h3>
<p>These changes will apply to all <code>pgNew</code>s that are called later.</p>
<pre><code>void ApplInit()	// Initialisation of the App
{
	pgMemStartup(&amp;mem_globals, 0);
	pgInit(&amp;paige_rsrv, &amp;mem_globals);
	
	/* change to make the default for all pg_refs created herein after 
	9 point instead of 12 point is a fraction with hi word being a 
	point is a fraction with hi word being the whole point value /*
	
	paige_rsrv.def_style.point = 0x00090000;
}
</code></pre>
<h3 id='default-tab-spacing'>Default tab spacing</h3>
<p>You can also change the default spacing for tabs (the distance to the next tab if no specific tab stops have been defined in the paragraph format). To do so, change <code>globals.def_par.def_tab_space</code>.</p>
<pre><code>/* The following code changes the default tab spacing (for all subsequent pg_refs) to $32. */

pgMemStartup(&amp;mem_globals, 0);
pgInit(&amp;paige_rsrc, &amp;mem_globals);
paige_rsrv.def_par.def_tab_space $=32$;
</code></pre>
<h2 id='34-graphic-devices'>3.4 Graphic Devices</h2>
<p>As mentioned earlier, a newly created HERMES Paige object will always draw to a default device; in a Macintosh environment, for instance, the default device will be the current port that is set before calling <code>pgNew</code>. In a Windows environment, the default device will be an HDC derived from <code>GetDC(hWnd)</code>, where <code>hWnd</code> is the window given to <code>pgNew</code>.</p>
<h3 id='setting-a-device'>Setting a device</h3>
<p>It is possible that you will want to change that default device once a HERMES Paige object has been created. To do so, call the following function:</p>
<pre><code>(void) pgSetDefaultDevice (pg_ref pg, graf_device_ptr device);
</code></pre>
<p>The device parameter is a pointer to a structure which is maintained internally (and understood) by HERMES Paige. (Generally, you won&#39;t be altering its structure directly, but the record layout is provided at the end of this section for your reference.)</p>
<p>The contents and significance of each field in a <code>graf_device</code> depends on the platform in which HERMES Paige is running. However, a function is provided for you to initialise a <code>graf_device</code> regardless of your platform:</p>
<pre><code>(void) pglnitDevice (pg_globals_ptr globals, generic_var the_port, long machine_ref, graf_device_ptr device);
</code></pre>
<p>The above function sets up an HERMES Paige graphics port which you can then pass to <code>pgSetDefaultDevice</code> (you can also use <code>pgInitDevice</code> to set up an alternate port that can be passed to <code>pgDisplay</code>).</p>
<p>The <code>globals</code> parameter is a pointer to the same structure you passed to <code>pgInit</code>.</p>
<p>The actual (but machine-dependent) graphics port is passed in <code>the_port</code>; what should be put in this parameter depends on the platform you are working with, as follows:</p>
<ul>
<li><strong>Macintosh</strong> (and PowerMac) — <code>the_port</code> should be a <code>GrafPtr</code> or <code>CGrafPtr</code>; <code>machine_ref</code> should be zero.</li>
<li><strong>Windows</strong> (all OS versions) — <code>the_port</code> should be an <code>HWND</code> and <code>machine_ref</code> should be <code>MEM_NULL</code>. Or, if you only have a device context (but no window), <code>the_port</code> should be <code>MEM_NULL</code> and <code>machine_ref</code> the device context. See sample below.</li>

</ul>
<p>The <code>device</code> parameter must be a pointer to an uninitialised <code>graf_device</code> record. The function will initialise every field in the <code>graf_device</code>; you can then pass a pointer to that structure to <code>pgSetDefaultDevice</code>.</p>
<h4 id='notes-3'>NOTES</h4>
<ol start='' >
<li>If you specified a window during <code>pgNew()</code> and want the <code>pg_ref</code> to continue displaying in that window, the &quot;default device&quot; is already set, so you do not need to use these functions. The only reason you would/should ever set a default device is if you want to literally change the window or device context the <code>pg_ref</code> is associated with.</li>
<li>HERMES Paige makes a copy of your <code>graf_device</code> record when you call <code>pgSetDefaultDevice</code>, so the structure does not need to remain static. But the graphics port itself (<code>HWND</code> or <code>HDC</code> for Windows, or <code>GrafPtr</code> for Mac) must remain “open” and valid until it will no longer be used by HERMES Paige.</li>
<li>If you need to temporarily change the <code>GrafPtr</code> (Macintosh) or device context (Windows), see &quot;Quick &amp; easy <code>set-window</code>&quot;<!-- on page 3-72 in this chapter-->.</li>

</ol>
<p><strong>CAUTION:</strong> Do not set the same <code>graf_device</code> as the &quot;default device&quot; to more than one <code>pg_ref</code>. If you need to set the same window or device context to more than one <code>pg_ref</code>, create a new <code>graf_device</code> for each one.</p>
<h3 id='setting-up-a-grafdevice-for-windows'>Setting up a <code>graf_device</code> for Windows</h3>
<h4 id='example-1-setting-up-a-grafdevice-from-a-window-handle-hwnd'>EXAMPLE 1: Setting up a <code>graf_device</code> from a Window handle (HWND)</h4>
<pre><code>graf_device device;

pgInitDevice(&amp;paige_rsrv, (generic_var)hWnd, MEM_NULL, &amp;device);
pgSetDefaultDevice(pg, &amp;device);

//... other code, draw, paint, whatever.

pgCloseDevice(&amp;paige_rsrv, &amp;device);
</code></pre>
<h4 id='example-2-setting-up-a-grafdevice-from-a-device-context-only-hdc'>EXAMPLE 2: Setting up a <code>graf_device</code> from a device context only (HDC):</h4>
<pre><code>graf_device device;

pgInitDevice(&amp;paige_rsrv, MEM_NULL, (generic_var)hDC, &amp;device);
pgSetDefaultDevice(pg, &amp;device);

//... other code, draw, paint, whatever.
</code></pre>
<h3 id='setting-default-device-on-the-macintosh'>Setting default device on the Macintosh</h3>
<pre><code>/* This function accepts a pg_ref (already created) and a Window pointer. The Window is set to pg&#39;s default drawing port, so after a call to this function, all drawing will occur in a new window. */

void set_new_paige_port (pg_ref pg, WindowPtr new_port)
{
	graf_device paige_port;
	pgInitDevice(&amp;paige_rsrv, new_port, 0, &amp;paige_point);
	pgSetDefaultDevice(pg, &amp;paige_port);
}

/* Done. HERMES Paige makes a copy of paige_port so it does not need to be static */
</code></pre>
<p>If you want to obtain the current default device for some reason, you can call the following:</p>
<pre><code>(void) pgGetDefaultDevice (pg_ref pg, graf_device_ptr device);
</code></pre>
<p>The device is copied to the structure pointed to by <code>device</code>.</p>
<h3 id='disposing-a-device'>Disposing a device</h3>
<p>If you have initialised a <code>graf_device</code>, followed immediately by <code>pgSetDefaultDevice()</code>, you do not need to deïnitialise or dispose the <code>graf_device</code>.</p>
<p>If, however, you have initialised a <code>graf_device</code> that you are keeping around for other purposes, you must eventually dispose its memory structures. To so call the following:</p>
<pre><code>(void) pgCloseDevice (pg_globals_ptr globals, graf_device_ptr device);
</code></pre>
<p>This function disposes all memory structure created in device when you called <code>pgInitDevice</code>. The <code>globals</code> parameter should be a pointer to the same structure given to <code>pgInit</code>.</p>
<h4 id='notes-4'>NOTES:</h4>
<ol start='' >
<li><code>pgCloseDevice</code> does not close or dispose the <code>GrafPort</code> (Macintosh) or the HWND/HDC (Windows) — you need to do that yourself.</li>
<li>You should never dispose a device you have set as the default device because <code>pgDispose</code> will call <code>pgCloseDevice</code>. The only time you would use <code>pgCloseDevice</code> is either when you have set up a <code>graf_device</code> to pass as a temporary pointer to <code>pgDisplay</code> (or a similar function that accepts a temporary port) in which HERMES Paige does not keep around, OR when you have changed the default device (see note below).</li>
<li>Additionally: HERMES Paige does not dispose the previous default device if you change it with <code>pgSetDefaultDevice</code>. Thus, if you change the default you should get the current device (using <code>pgGetDefaultDevice</code>), set the new device then pass the older device to <code>pgCloseDevice</code>.</li>

</ol>
<h3 id='quick--easy-set-window'>Quick &amp; easy <code>set-window</code></h3>
<p>In certain situations you might want to temporarily change the window or device context a <code>pg_ref</code> will render its text drawing. While this can be done by initialising a <code>graf_device</code> and giving that structure to <code>pgSetDefaultDevice()</code>, a simpler and faster approach might be to use the following functions:</p>
<pre><code>generic_var pgSetDrawingDevice (pg_ref pg, const generic_var draw_device);
void pgReleaseDrawingDevice (pg_ref pg, const generic_var previous_device);
</code></pre>
<p>The purpose of <code>pgSetDrawingDevice</code> is to temporarily change the drawing device for a <code>pg_ref</code>. The <code>draw_device</code> parameter must be a <code>WindowPtr</code> (Macintosh) or a device context (Windows).</p>
<p>The function returns the current device (the one used before <code>pgSetDrawingDevice</code>).</p>
<p><strong>NOTE:</strong> &quot;device&quot; in this case refers to a machine-specific device, not a <code>graf_device</code> structure.</p>
<p>You should call <code>pgReleaseDrawingDevice</code> to restore the <code>pg_ref</code> to its previous state. The <code>previous_device</code> parameter should be the value returned from <code>pgSetDrawingDevice</code>.</p>
<h3 id='temporarily-changing-the-hdc-windows'>Temporarily changing the HDC (Windows)</h3>
<pre><code>/* This function forces a pg_ref to display inside a specific HDC instead of the default. */

void DrawToSomeHDC (pg_ref pg, HDC hDC)
{
	generic_var old_dc;
	old_dc = pgSetDrawingDevice(pg, (generic_var)hDC);
	pgDisplay(pg, NULL, MEM_NULL, MEM_NULL, NULL, best_way); 
	pgReleaseDrawingDevice(pg, old_dc);
}
</code></pre>
<h3 id='setting-a-scaled-device-context-windows-only'>Setting a Scaled Device Context (Windows only)</h3>
<p>On a Windows platform, in certain cases you will want to preset a device context that needs to scale all drawing. However, using the standard function to set a device into an HERMES Paige object (<code>pgSetDrawingDevice</code>) will not work in this case because HERMES Paige will want to clear your mapping mode(s) and scaling factor(s).</p>
<p>The solution is to inform HERMES Paige that you wish to set your own device context, but to include a scaling factor:</p>
<pre><code>generic_var pgSetScaledDrawingDevice (pg_ref pg, const generic_var draw_device, pg_scale_ptr scale);
</code></pre>
<p>This is identical to <code>pgSetDrawingDDevice()</code> except that it contains the additional parameter <code>scale</code> which specifies the scaling factor. For more information on HERMES Paige scaling, see the appropriate section(s).</p>
<h2 id='35-colour-palettes-windows-specific'>3.5 Colour Palettes (Windows-specific)</h2>
<pre><code>void pgSetDevicePalette (pg_ref pg, const generic_var palette); generic_var pgGetDevicePalette (pg_ref pg);
</code></pre>
<p>These Windows-specific functions are used to select a custom palette into the device context of a <code>pg_ref</code>. To set a palette, call <code>pgSetDevicePalette()</code> and pass the <code>HPALETTE</code> in <code>palette</code>. If you want to clear a previous palette, pass <code>(generic_var)O</code>.</p>
<p>Setting a palette causes HERMES Paige to select that palette every time it draws to its device context.</p>
<p>To obtain the existing palette (if any), call <code>pgGetDevicePalette()</code></p>
<p><strong>CAUTION:</strong> Do not delete the palette unless you first clear it from the <code>pg_ref</code> by calling <code>pgSetDevicePalette(pg, (generic_var)0)</code>.</p>
<p><strong>CAUTION:</strong> If you change the default device (<code>pgSetDefaultDevice</code>), you need to set the custom palette again.</p>
<p><strong>NOTE:</strong> HERMES Paige does not delete the <code>HPALETTE</code>, even during <code>pgDispose()</code>. It is your responsibility to delete the palette.</p>
<h2 id='36-changing-shapes'>3.6 Changing Shapes</h2>
<p>You can change the <code>vis_area</code>, the <code>page_area</code> and/or the <code>exclude_area</code> of an HERMES Paige object at any time (see section 2.6, <a href='#2.6-creating-a-hermes-paige-object'>Creating a HERMES Paige Object</a>, for a description of each of these parameters):</p>
<pre><code>(void) pgSetAreas (pg_ref pg, shape_ref vis_area, shape_ref page_area, shape_ref exclude_area);
</code></pre>
<p>The <code>vis_area</code>, <code>page_area</code>, and <code>exclude_area</code> are functionally identical to the same parameters passed in <code>pgNew</code>. Of course, you could have passed any of these shapes in <code>pgNew</code>, but the purpose of <code>pgSetAreas</code> is to provide a way to change the visual area and/or wrap area and/or exclusion areas some time after an HERMES Paige object has been created.</p>
<p>Any of the three <code>_area</code> parameters can be <code>MEM_NULL</code>, in which case that shape remains unchanged.</p>
<p>Subsequent drawing of <code>pg</code>&#39;s text will reflect the changes, if any, produced by the changed shape(s).</p>
<p>A typical reason for changing shapes would be, for example, to implement a &quot;set columns&quot; feature. The initial HERMES Paige object might have been a simple rectangle (&quot;normal&quot; documents), but let us suppose that the user later wishes to change the document to three columns. To do so, you could set up a <code>page_area</code> shape for three columns and pass that new shape to <code>page_area</code> and null pointers for the other two areas. The HERMES Paige object, on a subsequent <code>pgDisplay</code>, would rewrap the text and flow within these &quot;columns.&quot;</p>
<h4 id='notes-5'>NOTES</h4>
<ol start='' >
<li>If your area(s) are simple rectangles, it may prove more efficient to use <code>pgSetAreaBounds()</code> in this chapter.</li>
<li>If you simply want to &quot;grow&quot; the <code>vis_area</code> (such as responding to a user changing the window’s size), see <a href='#growing-the-visual-area'>&quot;Growing&quot; The Visual Area</a> under section 3.6 for information on <code>pgGrowVisArea</code>.</li>
<li>HERMES Paige makes a copy of the new shape(s) you pass to <code>pgSetAreas</code>. You can therefore dispose these shapes any time afterwards.</li>

</ol>
<p>For information on constructing various shapes, see chapter 12, <a href='#12-all-about-shapes'>All About Shapes</a>.</p>
<p>If you are implementing containers, see chapter 14, <a href='#14-containers-support'>Containers Support</a>.</p>
<h3 id='growing-the-visual-area'>&quot;Growing&quot; The Visual Area</h3>
<p>If you want to change the <code>vis_area</code> (area in which text displays) in response to a user enlarging the window&#39;s width and height, call the following:</p>
<pre><code>(void) pgGrowVisArea (pg_ref pg, co_ordinate_ptr top_left, co_ordinate_ptr bot_right);
</code></pre>
<p>The size of <code>vis_area</code> shape in <code>pg</code> is changed by adding <code>top_left</code> and <code>bot_right</code> values to <code>vis_area</code>&#39;s top-left and bottom-right corners, respectively.</p>
<p>By &quot;adding&quot; is meant the following: <code>top_left.v</code> is added to <code>vis_area</code>&#39;s top and <code>top_left.h</code> is added to <code>vis_area</code>&#39;s left; <code>bot_right.v</code> is added to <code>vis_area</code>&#39;s bottom and <code>bot_right.h</code> is added to <code>vis_area</code>&#39;s right.</p>
<p><strong>NOTE:</strong> This function adds to (or &quot;subtracts&quot; from, if coördinate parameters are negative) the visual area rather than setting or replacing the visual area to the given coördinates.</p>
<p>Either <code>top_left</code> or <code>bot_right</code> can be null pointers, in which case they are ignored.</p>
<p><strong>NOTE:</strong> This function only works correctly if <code>vis_area</code> is rectangular; if you have set a non-rectangular shape, you need to reconstruct your <code>vis_area</code> shape and change it with <code>pgSetAreas</code>.</p>
<h4 id='responding-to-wm-size-message-windows'>Responding to WM SIZE message (Windows)</h4>
<pre><code class='language-c' lang='c'>case WM_SIZE:
	if (pgRef)
	{
		rectangle vis_bounds;
		co_ordinate amount_to_grow;
		long old_width, new_width, old_height, new_height;
		pgAreaBounds(pgRef, NULL, &amp;vis_bounds);
		new_width = (long) LOWORD(lParam);
		new_height = (long) HIWORD(lParam);
		old_width = vis_bounds.bot_right.h - vis_bounds.top_left.h;
		old_height = vis_bounds.bot_right.v - vis_bounds.top_left.v;
		amount_to_grow.h = new_width - old_width;
		amount_to-grow.v = new_height - old_height;
		pgGrowVisArea(pgRef, NULL, (co_ordinate_ptr) &amp;amount_to_grow);
	}
break;
</code></pre>
<h2 id='37-getting-information-about-shapes'>3.7 Getting information about shapes</h2>
<h3 id='getting-current-shapes'>Getting Current Shapes</h3>
<p>To obtain any of the three shapes in a HERMES Paige object, call the following:</p>
<pre><code class='language-c' lang='c'>(void) pgGetAreas (pg_ref pg, shape_ref vis_area, shape_ref page_area, shape_ref exclude_area);
</code></pre>
<p>The <code>vis_area</code>, <code>page_area</code>, <code>exclude_area</code> must be pre-created <code>shape_ref</code>s (see below). Any of them, however, can be <code>MEM_NULL</code> (in which case that parameter is ignored).</p>
<p>This function will copy the contents of <code>pg</code>&#39;s visual area, wrap area, and exclude area into <code>vis_area</code>, <code>page_area</code> and exclude_area, respectively, if that parameter is non-null.</p>
<p>Helpful hint: The easiest way to create a <code>shape_ref</code> is to call <code>pgRectToShape</code> passing a null pointer to the <code>rect</code> parameter, as follows:</p>
<pre><code>shape_ref new_shape;
new_shape = pgRectToShape(&amp;paige_rsrv, NULL);
</code></pre>
<p>The <code>paige_rsrv</code> parameter in the above example is a pointer to the same <code>pg_globals</code> passed to <code>pgInit</code>. By providing a null pointer as the second parameter, a new <code>shape_ref</code> is returned with an empty shape (all sides zero).</p>
<h3 id='getset-areas-trick'>&#39;Get/Set Areas&#39; Trick</h3>
<p>If you are using simple rectangles for the visual area or wrap (page) area in an HERMES Paige object, and/or if you simply want to know the bounding rectangular area of either shape, use the following instead of <code>pgGetAreas</code>:</p>
<pre><code>(void) pgAreaBounds (pg_ref pg, rectangle_ptr page_bounds, rectangle_ptr vis_bounds);
</code></pre>
<p>When <code>pgAreaBounds</code> is called, <code>page_bounds</code> gets set to a rectangle that encloses the entire <code>page_area</code> and <code>vis_bounds</code> gets set to a rectangle that encloses the entire <code>vis_area</code> of <code>pg</code>.</p>
<p>If you don&#39;t want one or the other, either <code>page_bounds</code> or <code>vis_bounds</code> can be a null pointer.</p>
<p>This function is useful when you simply want the enclosing bounds of either shape because you do not need to create a <code>shape_ref</code>.</p>
<p>You can also set the page area and/or vis area by calling <code>pgSetAreaBounds</code>, which accepts a pointer to a rectangle in <code>page_bounds</code> and <code>vis_bounds</code> (of which either can be a null pointer). Note that this is faster and simpler than <code>pgSetAreas</code>, except that it only works provided that the shape(s) are single rectangles.</p>
<h3 id='direct-shape-access'>Direct Shape Access</h3>
<p>You can also access the <code>shape_ref</code>s in an HERMES Paige object directly using any of the following:</p>
<pre><code>(shape_ref) pgGetPageArea (pg_ref pg);
(shape_ref) pgGetVisArea (pg_ref pg);
(shape_ref) pgGetExcludeArea (pg_ref pg);
</code></pre>
<p>These three functions will return the <code>shape_ref</code> for <code>page_area</code>, <code>vis_area</code> and <code>exclude_area</code>, respectively. Neither will ever return <code>MEM_NULL</code> (even if you provided <code>MEM_NULL</code> for <code>exclude_area</code> in <code>pgNew</code>, for instance, HERMES Paige will still maintain a <code>shape_ref</code> for the exclusion, albeit an empty shape).</p>
<p>The purpose of these functions is for special applications that need to look inside of HERMES Paige shape as quickly and as easily as possible.</p>
<p><strong>CAUTION:</strong> These functions return the actual memory_ref&#39;s for each shape. You must therefore never dispose of them, nor should you alter their contents (or else HERMES Paige won&#39;t know you have changed anything and word wrapping and display will fail). If you want to alter the contents of HERMES Paige shapes, see chapters 14, <a href='#14-containers-support'>Containers Support</a>, and 15, <a href='#15-exclusion-areas'>Exclusion Areas</a>.</p>
<h3 id='getting-shape-rectangle-quantity'>Getting Shape Rectangle Quantity</h3>
<p>You can find out how many rectangles comprise any shape by calling the following:</p>
<pre><code>(pg_short_t) pgNumRectsInShape (shape_ref the_shape);
</code></pre>
<p>The function will return the number of rectangles in <code>the_shape</code>.</p>
<p><strong>NOTE:</strong> The result will always be at least 1, even for an empty shape. Any &quot;empty&quot; shape is still one rectangle whose boundaries are $0,0,0,0$. If you need to detect whether or not a shape is empty, call:</p>
<pre><code>(pg_boolean)pgEmptyShape(the_shape); /* Returns TRUE if empty */
</code></pre>
<h2 id='38-changing-globals'>3.8 Changing Globals</h2>
<p>As mentioned several times, your application provides a pointer to <code>pgInit</code> (and other places) to be used by HERMES Paige to store certain global variables. This structure is initially set to certain default values, but you can make certain changes that apply to your particular application.</p>
<p>For example, HERMES Paige globals contain the values for special control codes such as CR, LF, and arrow keys, but there are instances when you need to change some of these &quot;characters&quot; to a different value.</p>
<p>Another (more common) reason to change HERMES Paige globals is to force a default text or paragraph format for all subsequent <code>pgNew()</code> calls.</p>
<p>Since your application maintains the globals record, there are no functions provided to change its contents; rather, you alter the structure&#39;s contents directly some time after <code>pgInit</code>.</p>
<p><strong>NOTE:</strong> The entire HERMES Paige globals structure can be viewed in <code>paige.h</code>. Only the members of this structure that you are allowed to alter are shown unless noted otherwise.</p>
<pre><code class='language-c' lang='c'>/* Paige &quot;globals&quot; (address space provided by app): */

struct pg_globals
{
	pgm_globals_ptr	mem_globals;				// Globals for pgMemManager
	long				max_offscreen;					// Maximum memory for offscreen
	long				max_block_size;					// Maximum size of text block
	long				minimum_line_width;			// Minimum size line width
	long				def_tab_space;					// Default tab spacing for pgNew
	pg_short_t	line_wrap_char;					// &lt;CR&gt; character
	pg_short_t	soft_line_char;					// Soft &lt;CR&gt; character
	pg_short_t	tab_char;								// Tab character
	pg_short_t	soft_hyphen_char;				// Soft hyphen character
	pg_short_t	bs_char;								// Backspace character
	pg_short_t	ff_char;								// Form feed chr (for page breaks)
	pg_short_t	container_brk_char;			// Container break character
	pg_short_t	left_arrow_char;				// Left arrow
	pg_short_t	right_arrow_char;				// Right arrow
	pg_short_t	up_arrow_char;					// Up arrow
	pg_short_t	down_arrow_char;				// Down arrow
	pg_short_t	fwd_delete_char;				// Forward delete character
	pg_char			hyphen_char[4];					// Hard hyphen character
	pg_char			decimal_char[4];				// &quot;.&quot; char (for decimal tabs)
																				/* Visible surrogate for:
																				-------------------------*/
	pg_char			cr_invis_symbol[4];			// carriage return
	pg_char			lf_invis_symbol[4];			// line feed
	pg_char			tab_invis_symbol[4];		// horizontal tab
	pg_char			end_invis_symbol[4];		// end-of-document
	pg_char			pbrk_invis_symbol[4];		// break-of-page
	pg_char			cont_invis_symbol[4];		// container break
	pg_char			space_invis_symbol[4];	// space
																			//------------------------
	pg_char			flat_single_quote[4];		// Single &quot;typewriter&quot; quote
	pg_char			flat_double_quote[4];		// Double &quot;typewriter&quot; quote
	pg_char			left_single_quote[4];		// Single left smart quote
	pg_char			right_single_quote[4];	// Single right smart quote
	pg_char			left_double_quote[4];		// Double left smart quote
	pg_char			right_double_quote[4];	// Double right smart quote
	pg_char			elipse_symbol[4];				// Char to draw for ellipse
	long				invis_font;							// Machine-specific invisible char font
	pg_char			unknown_char[4];				// Used for unsupported characters
	long				embed_callback_proc;		// Used internally by embed_refs
	font_info		def_font;								// Default font for all pgNew&#39;s
	style_info	def_style;							// Default style for all pgNew&#39;s
	par_info		def_par;								// Default para for all pgNew&#39;s
	color_value	def_bk_color;						// Default background colour
	color_value	trans_color;						// Transparent colour (default is white)
	pg_hooks		def_hooks;							// Default general hooks
	// miscellaneous fields not to be altered by app.
};
</code></pre>
<p>The following is a description for each field that you can change directly:</p>
<p><code>max_offscreen</code> — defines the maximum amount of memory, in bytes, that can be used for offscreen bit map drawing. The purpose of this field is to avoid excessive, unreasonable offscreen bit maps for huge text on high-density monitors.</p>
<p><code>max_block_size</code> — defines the largest size for contiguous text (HERMES Paige breaks down text into blocks of <code>max_block_size</code> as the HERMES Paige object grows).</p>
<p><code>minimum_line_width</code> — pdefines the smallest width allowed, in pixels, for a line of text. The purpose of this field is for HERMES Paige to decide when a portion of a wrap area is too small to even consider placing text.</p>
<p><code>def_tab_space</code> — not used in version 1.3 and beyond. (To change default tab spacing, change <code>globals.def_par.def_tab_space</code>).</p>
<p><code>line_wrap_char</code> through <code>down_arrow_char</code> — defines all the special characters recognized by HERMES Paige. Any of these can be changed to something else if you don&#39;t want the default values. See <strong>Warning</strong> below. See also <a href='#double-byte-defaults'>Double Byte Defaults</a> under section 3.8.</p>
<p><code>text_brk_char</code> — defines an alternate character to delineate text blocks (HERMES Paige partitions large blocks of text into smaller blocks; by default, a block will break on a &lt;CR&gt; or &lt;LF&gt;, but if neither of those are found in the text, the <code>text_brk_char</code> will be searched for). For additional information, see chapter 36, <a href='#36-anatomy-of-text-blocks'>Anatomy of Text Blocks</a>.</p>
<p><code>null_char</code> — defines a special character that, if inserted, merely causes word-wrap to recalculate and the <code>null_char</code> itself is not inserted.</p>
<p><code>cr_invis_symbol</code> through <code>space_invis_symbol</code> — define all the character values to draw when HERMES Paige is in &quot;show invisibles&quot; mode. Each character is represented by a null-terminated Pascal string (first byte is the length, followed by the byte(s) for the character, followed by a zero). Note that these characters can be zero, one or two bytes in length. See also <a href='#double-byte-defaults'>Double Byte Defaults</a> under section 3.8.</p>
<p><code>flat_single_quote</code> through <code>right_double_quote</code> - define single and double quotation characters for &quot;smart quotes&quot; implementation. The &quot;flat<em>&quot; quote characters should be the standard ASCII characters for single and double quotes, while the &quot;left</em>&quot; and &quot;right_&quot; quote characters are to be substituted for &quot;smart quotes&quot; if that feature has been enabled.</p>
<p><code>elipse_symbol</code> — contains the character to draw an ellipsis “…&quot; symbol. However, this character definition has been provided only for future enhancement: the current version of HERMES Paige does not use this character for any built-in feature.</p>
<p><code>invis_font</code> — defines the font to be used for drawing invisibles. This is machine dependent. For Macintosh, this is the QuickDraw font ID that gets set for invisible characters. For Windows, this is a font <code>HANDLE</code> (which you can alter by replacing it with you own font <code>HANDLE</code>)</p>
<p><code>unknown_char</code> — Contains the symbol to be used when importing unsupported characters. For example, importing a file with HERMES Paige&#39;s import extension may include characters that to not cross over to any available character set, in which case unknown_char will be substituted.</p>
<p><strong>WARNINGS</strong></p>
<ul>
<li><em>(Windows only)</em> If you replace the <code>invis_font</code> member with your own font object, do not delete the object that was there before, if any. Moreover, HERMES Paige will not delete your <code>invis_font</code> object either, so you are responsible for deleting your own object before your application quits.</li>
<li>The default machine-specific functions within HERMES Paige are assuming ASCII control codes for the special character values in <code>pg_globals</code> (ASCII chars &lt; 20).</li>

</ul>
<p><code>def_font</code>, <code>def_style</code>, <code>def_par</code> — define the default font, text and paragraph formatting, respectively. Whenever you call <code>pgNew()</code>, these three structures are literally copied into the new <code>pg_ref</code>. Hence, to change the default(s) for text formatting, you simply change the members of these three structures prior to calling <code>pgNew()</code>.</p>
<p><code>def_bk_color</code>, <code>trans_color</code> — define the default background colour to be used for drawing all text and the colour that is considered &quot;transparent&quot;, respectively. The background colour is not necessarily the same as the window&#39;s background colour (HERMES Paige will make the necessary adjustment if window colour does not equal the <code>pg_ref</code>&#39;s background colour). By &quot;transparent&quot; color is meant which colour is considered the normal screen background colour (default is white).</p>
<p>The purpose of defining the transparent colour is to inform HERMES Paige when and if the background of its drawing needs to be &quot;erased&quot; with a different colour other than the regular background of the window. If the background colour for an HERMES Paige object is set to the same value as <code>trans_color</code> in <code>pg_globals</code>, HERMES Paige won&#39;t do any special color filling of background since it assumes normal erasing of the window will take care of it (for instance, responding to WM_PAINT). If HERMES Paige&#39;s background color is not the same as <code>trans_color</code>, then the <code>pg_ref</code>&#39;s background shape will be pre-filled with a different color other than the window&#39;s default.</p>
<p><code>def_hooks</code> — define the default function pointers to be used for a <code>pg_ref</code>&#39;s general hooks. Essentially, <code>pgNew</code> copies these pointers. (DSI and other developers can change these defaults for special extensions).</p>
<h3 id='default-values'>Default Values</h3>
<p>After you have called <code>pgInit</code>, the following defaults are set for all the fields mentioned above:</p>
<figure class='table-figure'><table>
<thead>
<tr><th>Global Field</th><th>About the field</th><th>Windows</th><th>Macintosh</th></tr></thead>
<tbody><tr><td><code>max_offscreen</code></td><td>bit map size (bytes)</td><td>48,000</td><td>48,000</td></tr><tr><td><code>max_block_size</code></td><td>max paragraph size in number of <code>&lt;br&gt;</code> characters</td><td>4096</td><td>4096</td></tr><tr><td><code>minimum_line_width</code></td><td>in pixels</td><td>16</td><td>16</td></tr><tr><td><code>line_wrap_char</code></td><td>carriage return character</td><td>0x0D</td><td>0x0D</td></tr><tr><td><code>soft_line_char</code></td><td>soft carriage return char</td><td>0x0A</td><td>0x0A</td></tr><tr><td><code>tab_char</code></td><td>tab char</td><td>0x09</td><td>0x09</td></tr><tr><td><code>hyphen_char</code></td><td>hard hyphen char</td><td>0x2D</td><td>0x2D</td></tr><tr><td><code>soft_hyphen_char</code></td><td>soft hyphen char</td><td>0x1F</td><td>0x1F</td></tr><tr><td><code>decimal_char</code></td><td>decimal point char</td><td>0x2E</td><td>0x2E</td></tr><tr><td><code>bs_char</code></td><td>back space (delete) char</td><td>0x08</td><td>0x08</td></tr><tr><td><code>lf_char</code></td><td>line feed char</td><td>0x0C</td><td>0x0C</td></tr><tr><td><code>container_brk_char</code></td><td>container break char</td><td>0x0E</td><td>0x0E</td></tr><tr><td><code>left_arrow_char</code></td><td>left arrow key</td><td>0x1C</td><td>0x1C</td></tr><tr><td><code>right_arrow_char</code></td><td>right arrow key</td><td>0x1D</td><td>0x1D</td></tr><tr><td><code>up_arrow_char</code></td><td>up arrow key</td><td>0x1E</td><td>0x1E</td></tr><tr><td><code>down_arrow_char</code></td><td>down arrow key</td><td>0x1F</td><td>0x1F</td></tr><tr><td><code>text_brk_char</code></td><td>alternative carriage return char <code>&lt;br&gt;</code> (form feed)</td><td>0x1B</td><td>0x1B</td></tr><tr><td><code>fwd_delete_char</code></td><td>forward delete key</td><td>0x7F</td><td>0x7F</td></tr><tr><td><code>elipse_symbol</code></td><td>displayed when HERMES Paige encounters an unknown symbol</td><td>&#39;.&#39;</td><td>0x85</td></tr><tr><td><code>flat_single_quote</code></td><td>straight apostrophe – &#39;</td><td>0x27</td><td>0x27</td></tr><tr><td><code>flat_double_quote</code></td><td>straight double quote – &quot;</td><td>0x22</td><td>0x22</td></tr><tr><td><code>left_single_quote</code></td><td>curly left quote – ‘</td><td>0x91</td><td>0xD4</td></tr><tr><td><code>right_single_quote</code></td><td>curly right quote – ’</td><td>0x92</td><td>0xD5</td></tr><tr><td><code>left_double_quote</code></td><td>curly left quotes – “</td><td>0x93</td><td>0xD2</td></tr><tr><td><code>right_double_quote</code></td><td>curly right quotes – ”</td><td>0x94</td><td>0xD3</td></tr><tr><td><code>cr_invis_symbol</code></td><td>carriage return when invisibles are displayed</td><td>¶ (0xB6)</td><td>¶ (0xA6)</td></tr><tr><td><code>lf_invis_symbol</code></td><td>line feed when invisibles are displayed</td><td>¼ (0xB5)</td><td>¼ (0xB9)</td></tr><tr><td><code>tab_invis_symbol</code></td><td>tab when invisibles are displayed</td><td>0x95</td><td>0x13</td></tr><tr><td><code>end_invis_symbol</code></td><td>end of document when invisibles are displayed</td><td>× (0xB5)</td><td>× (0xB0)</td></tr><tr><td><code>cont_invis_symbol</code></td><td>container break when invisibles are displayed</td><td><code>|</code> (0xA5)</td><td><code>|</code> (0xAD)</td></tr><tr><td><code>space_invis_symbol</code></td><td>space symbol when invisibles are displayed</td><td>. (0x2E)</td><td>. (0x2E)</td></tr><tr><td><code>invis_font</code></td><td>font in which invisibles are displayed</td><td>default font*</td><td>0 (Chicago)</td></tr><tr><td><code>def_font</code></td><td>font (name) used for <code>pgNew()</code></td><td>“System”</td><td>Application font</td></tr><tr><td><code>def_style</code></td><td>text format used for <code>pgNew()</code></td><td>Plain, 12 point</td><td>Plain, 12 point</td></tr><tr><td><code>def_par</code></td><td>paragraph format used for <code>pgNew()</code></td><td>Indents all zero, tab spacing 24 pixels</td><td>Indents all zero, tab spacing 24 pixels</td></tr><tr><td><code>def_bk_color</code></td><td>background color used to fill page area for all <code>pg_ref</code>s</td><td>white</td><td>white</td></tr><tr><td><code>trans_color</code></td><td>color assumed also to be window’s background</td><td>white</td><td>white</td></tr></tbody>
</table></figure>
<p>If the default font is zero, then HERMES Paige creates a font object using the default found in <code>pg_globals</code> record that was created with <code>pgNew</code>. If you want to change this you can change the default font in the <code>pg_globals</code>.</p>
<p><strong>NOTE (Macintosh):</strong> The <code>pgdf</code> Resource: During initialisation, the machine-specific code for Macintosh searches for a special resource to determine the character defaults (above). If it does not find this resource, the values given above are used. Hence, you can change the defaults by changing the contents of this resource:</p>
<figure class='table-figure'><table>
<thead>
<tr><th style='text-align:center;' >TABLE #2</th><th style='text-align:center;' >MACINIOSH RESOURCE TYPE &amp; ID</th></tr></thead>
<tbody><tr><td style='text-align:center;' >Resource Type</td><td style='text-align:center;' >Resource ID</td></tr><tr><td style='text-align:center;' >&quot;pgdf&#39;</td><td style='text-align:center;' >128</td></tr></tbody>
</table></figure>
<p>The HERMES Paige package we provide should contain this resource as well as a ResEdit template to change its contents.</p>
<h3 id='double-byte-defaults'>Double Byte Defaults</h3>
<p>Each character default in <code>pgGlobals</code> can be &quot;double byte&quot; such as Kanji, if necessary. Although this manual references these defaults as &quot;characters,&quot; in truth these global values are ALL double-byte, that is they are unsigned integers. An ASCII CR, for instance, is considered to be 0x000D and not 0x0D, etc. To set a double byte default, such as a Kanji decimal for instance, simply place the whole 16-bit value into the appropriate global field.</p>
<h3 id='tech-note-crlf-conversion'>TECH NOTE: CR/LF Conversion</h3>
<blockquote><p>I have read all the stuff so far about carriage return line feeds. What exactly do I have to do to make sure my documents are portable between the PC which uses <code>&lt;CR&gt;&lt;LF&gt;</code>, and the Mac which uses only a <code>&lt;CR&gt;</code>?</p>
</blockquote>
<p>HERMES Paige normally formats text using only CR for paragraph endings (NOT CR/LF), hence for documents created from scratch on any of the platforms, where all text has been entered by the user via the keyboard, documents between platforms are generally portable with respect to CR/LF or just CR.</p>
<p>The only time this can become even remotely an issue is when raw text is inserted which contains both CR and LF, which if left &quot;as is&quot; would cause HERMES Paige to draw two line feeds for each paragraph ending (one for CR and one for LF).</p>
<p>To avoid this situation, the <code>NO_LF_BIT</code> should be set as one of the &quot;flag&quot; bits in <code>pgNew</code> (or, if the <code>pg_ref</code> has already been created, <code>NO_LF_BIT</code> can be set by calling<code>pgGetAttributes</code>, ORing <code>NO_LF_BIT</code> to the result and setting that value with <code>pgSetAttributes</code>. By setting this bit, HERMES Paige will essentially ignore all LF characters and they will become virtually invisible.</p>
<p>See also technical note <a href='#tech-note-carriage-returnline-feeds-causing-problems'>Carriage return/line feeds causing problems</a>.</p>
<h2 id='39-cloning-an-hermes-paige-object'>3.9 Cloning an HERMES Paige Object</h2>
<p>To create a new HERMES Paige object based on an existing <code>pg_ref</code>&#39;s <code>vis_area</code>, <code>page_area</code>, <code>exclude_area</code> and attributes, use the following:</p>
<pre><code>(pg_ref) pgDuplicate (pg_ref pg);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns a new <code>pg_ref</code>, completely independent of, but using the same shapes and attributes as, <code>pg</code>. No text is copied and the default text formatting is used.</p>
<h2 id='310-storing-arbitrary-references-and-structures'>3.10 Storing Arbitrary References and Structures</h2>
<p>You can store any arbitrary long value or pointer into a <code>pg_ref</code> any time you want, and with as many different values as you want by using the following:</p>
<pre><code>(void) pgSetExtraStruct (pg_ref pg, void PG_FAR *extra_struct, long ref_id);
(void PG_FAR *) pgGetExtraStruct (pg_ref pg, long ref_id);
</code></pre>
<p>By &quot;storing&quot; an arbitrary value within a <code>pg_ref</code> is meant that HERMES Paige will save <code>long</code>s or pointers — which only have significance to your application — which can be retrieved later at any time.</p>
<p>To store such items, call <code>pgSetExtraStruct</code>, passing your <code>long</code> (or pointer) in <code>extra_struct</code> and a unique identification number in <code>ref_id</code>. The purpose of this UID is to reference that item later in <code>pgGetExtraStruct</code>.</p>
<p>However, if the value in <code>ref_id</code> is already being used by an &quot;extra struct&quot; item within <code>pg</code>, the old value is overwritten with <code>extra_struct</code>. (Hence, that is how you can &quot;change&quot; a value that had previously been stored).</p>
<p>To retrieve an item stored with <code>pgSetExtraStruct</code>, call <code>pgGetExtraStruct</code> passing the wanted ID in <code>ref_id</code> (which must be the same number given to <code>unique_id</code> for that item originally given to <code>pgSetExtraStruct</code>).</p>
<p>See section 34.2, <a href='#342-hermes-paige-handler-functions'>HERMES Paige &quot;Handler&quot; Functions</a>.</p>
<h3 id='tech-note-removing-extrastruct'>TECH NOTE (Removing ExtraStruct)</h3>
<blockquote><p>Why is there no <code>pgRemoveExtraStruct()</code>?</p>
</blockquote>
<p>Probably because of the way it was implemented and what it is/was intended for, it doesn&#39;t make sense to do a &quot;remove.&quot;</p>
<p>An &quot;extra <code>struct</code>&quot;, as far as HERMES Paige is concerned, is a single element of an array of <code>long</code>s. Each of these <code>long</code>s are treated as <code>refcon</code> values that an application can use for whatever.</p>
<p>Literally, the list of extra <code>struct</code>s are maintained internally as <code>long[n]</code> where <code>n</code> is the number of extra <code>struct</code>s added.</p>
<p>The array number itself, e.g. 0, 1, 2, etc., is the &quot;ID number&quot; of the extra <code>struct</code>. That is what makes each one unique, really. Hence you can see why we could not really &quot;delete&quot; one of these elements since that would cause all subsequent extra <code>struct</code> elements to be a different &quot;ID&quot; number.</p>
<p>For example, if a <code>pg_ref</code> holds elements 0, 1, 2, 3, and 4 (all with same corresponding ID numbers), deleting 2 would make 3 become 2 and 4 become 3.</p>
<p>We realise a more elaborate system could have been implemented that contained indirect pointers, or some other scheme that is closer to what (I think) you are suggesting, so extra <code>struct</code>s could be deleted.</p>
<p>But, the original purpose of this feature was simply to add extra <code>refCon</code> possibilities. It might have made more sense had we called the function something like <code>pgReserveAnotherLongRefCon</code>.</p>
<h3 id='finding-a-unique-id'>Finding a Unique ID</h3>
<p>If you aren&#39;t sure whether or not an ID number is unique for a <code>pg_ref</code>, or if you simply want to get an ID number that you know is unique, call the following:</p>
<pre><code>(long) pgExtraUniquelD (pg_ref pg);
</code></pre>
<p>The number this function returns will always be positive and is guaranteed to have not yet been used for <code>pgSetExtraStruct</code> with this <code>pg_ref</code>.</p>
<p><strong>CAUTION:</strong> HERMES Paige has no idea what you are storing with <code>pgSetExtraStruct</code>, and therefore will not dispose any memory allocations that you might have attached to &quot;extra <code>struct</code>&quot; storage. Be sure to dispose any such allocations before disposing the <code>pg_ref</code> or you will end up with a memory leak.</p>
<p><strong>NOTE:</strong> Once you have stored something with <code>pgExtraStruct</code>, that item (and unique reference) stays in the <code>pg_ref</code> and never gets &quot;removed&quot; unless you
explicitly do another <code>pgSetExtraStruct</code> using the same ID (in which case the previous item associated with that ID will get overwritten).</p>
<h3 id='example-how-to-use-and-extra-struct'>EXAMPLE (How to use and extra struct)</h3>
<pre><code>/* This function adds a WindowPtr to the HERMES Paige object using 
   the extra struct feature and returns the ID of that struct */

short add_window_to_pg (pg_ref pg, WindowPtr w_ptr)
{
	short unique_id;
	unique_id = pgExtraUniqueID(pg);
	pgSetExtraStruct(pg, w_ptr, unique_id);
	return unique_id;
}

/* Later, the extra struct can be accessed using the ID returned above. */

WindowPtr window_with_pg;
window_with_pg = pgGetExtraStruct(pg, unique_id);
</code></pre>
<h2 id='311-cursor-utilities'>3.11 Cursor Utilities</h2>
<p>If you want to know if a point (<code>co_ordinate</code>) sits on top of editable text (to change the mouse symbol to something else, for instance), call the following:</p>
<pre><code>(short) pgPtInView (pg_ref pg, co_ordinate_ptr point, co_ordinate_ptr offset_extra);
</code></pre>
<p>Given an arbitrary window coördinate (relative to that window&#39;s coördinate system) in point, <code>pgPtInView</code> returns information about what part of <code>pg</code>, if any, includes that point.</p>
<p>The <code>offset_extra</code> parameter is an optional pointer to a coördinate that holds values to temporarily offset everything in <code>pg</code> before checking intersections of the point. In other words, if <code>offset_extra</code> is non-null, this visual area in <code>pg</code> will first be offset by <code>offset_extra.h</code> and <code>offset_extra.v</code> amounts before checking the containment of point in <code>vis_area</code>; the wrap area will also be offset by this amount before checking if the wrap area contains the point, and so on.</p>
<p>If <code>offset_extra</code> is a null pointer, everything is checked as-is.</p>
<p><strong>FUNCTION RESULT:</strong> The function result will be a word containing different bits set (or not) indicating what intersects the point as follows:</p>
<pre><code>#define WITHIN_VIS_AREA			0x0001	// Point within vis_area
#define WITHIN_WRAP_AREA		0x0002	// Point within page_area
#define WITHIN_EXCLUDE_AREA	0x0004	// Point within exclude_area
#define WITHIN_TEXT					0x0008	// Point within actual text
#define WITHIN_REPEAT_AREA	0x0010	// Point is in repeating gap of page
#define WITHIN_LEFT_AREA		0x0020	// Point is left of document
#define WITHIN_RIGHT_AREA		0x0040	// Point is right of document
#define WITHIN_TOP_AREA			0x0080	// Point is above top of document
#define WITHIN_BOTTOM_AREA	0x0100	// Point is below bottom of document
</code></pre>
<p><code>WITHIN_VIS_AREA</code> means the point is within the bounding area of <code>vis_area</code>.</p>
<p><code>WITHIN_WRAP_AREA</code> means the point is somewhere within the <code>page_area</code> shape.</p>
<p><code>WITHIN_EXCLUDE_AREA</code> means the point is somewhere within the <code>exclude_area</code>.</p>
<p><code>WITHIN_TEXT</code> means the point is somewhere within &quot;real&quot; text. This differs from <code>WITHIN_WRAP_AREA</code> since it is possible to have a large <code>page_area</code> shape with very little text (in which case, <code>WITHIN_TEXT</code> will only be set if the point is over the portion that displays text).</p>
<p>Each bit gets set notwithstanding the other settings. For example, <code>WITHIN_EXCLUDE_AREA</code> and <code>WITHIN_WRAP_AREA</code> can both be set, even though text cannot flow into the <code>exclude_area</code>.</p>
<p>Another setting that can be returned is <code>WITHIN_TEXT</code> set but <code>WITHIN_VIS_AREA</code> not set, which really means the point is over text that falls outside of <code>vis_area</code>. The function result is simply the setting for each case individually, so it is your responsibility to examine the combination of bits to determine what action you should take, if any.</p>
<p><strong>NOTE:</strong> The best time to turn the cursor to an &quot;i-beam&quot; is when <code>pgPtInView</code> returns <code>WITHIN_VIS_AREA</code> and <code>WITHIN_TEXT</code> at the same time and <code>pg</code> is in an active state.</p>
<h2 id='312-getting-text-size-and-height'>3.12 Getting Text Size and Height</h2>
<p>To obtain the total size of text in an HERMES Paige object (in bytes), call the following:</p>
<pre><code>(long) pgTextSize (pg_ref pg);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns the total size of text (byte size) in <code>pg</code>.</p>
<p>To find out how &quot;tall&quot; the text is, call the following:</p>
<pre><code>(long) pgTotalTextHeight (pg_ref pg, pg_boolean paginate)
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns the distance between the top of the first line of text to the bottom of the lowest line, in pixels.</p>
<p><strong>NOTE:</strong> The lowest line is not necessarily the last line in the document: had <code>pg</code> had a non-rectangular shape, such as parallel columns, the last (ending) line could have been vertically above some of the lines in other areas of the shape. Hence, <code>pgTotalTextHeight</code> really returns the bounding height between the highest and lowest points.</p>
<p>If <code>paginate</code> is <code>TRUE</code>, all the text from top to bottom is recalculated (word wrap recomputed), if necessary. If <code>paginate</code> is <code>FALSE</code>, the total text height returned is computed with the latest information available within <code>pg</code>. In essence, this would be HERMES Paige&#39;s &quot;best guess.&quot;</p>
<p>For example, suppose a large document changed from 12 point text to 18 point text and you wanted to know how tall the document had become. To get the exact height, to the nearest pixel, you should pass TRUE for paginate, otherwise HERMES Paige might not have computed all the text to return an exact answer. However, computing large amounts of text can consume a great deal of time, which is why the choice to &quot;paginate&quot; or not has been provided.</p>
<h5 id='notes-6'>NOTES:</h5>
<ol start='' >
<li>If you will be using the built-in scrolling support in HERMES Paige, you probably never need to get the height of an HERMES Paige object — see chapter 11, <a href='#11-all-about-scrolling'>All About Scrolling</a>. If you do need an exact height for other reasons, see section 24.12, <a href='#2412-getting-the-maximum-text-bounds'>Getting the Maximum Text Bounds</a>.</li>
<li>The <code>height</code> returned from this function does not consider any extra structures that aren&#39;t embedded in the text stream. For example, if you have implemented headers, footers, footnotes, or any other page &quot;ornaments&quot; their placement will not be considered in the text height computation.</li>

</ol>
<h1 id='4-virtual-memory'>4 Virtual Memory</h1>
<h2 id='41-initialising-virtual-memory'>4.1 Initialising Virtual Memory</h2>
<p>HERMES Paige supports a &quot;virtual memory&quot; system in which memory allocations made by HERMES Paige can be spooled to a disk file in order to free memory for new allocations.</p>
<p>However, your application must explicitly initialise HERMES Paige virtual memory before it is operational; this is because disk file reading and writing is machine-dependent, hence your application needs to provide a path for memory allocations to be saved.</p>
<p>To do so, call the following function somewhere early when your application starts up and after <code>pgInit</code>:</p>
<pre><code>#include &quot;pgMemMgr.h&quot;
void InitVirtualMemory (pgm_globals_ptr globals, purge_proc purge_function, long ref_con);
</code></pre>
<p>The <code>globals</code> parameter is a pointer to a field in <code>pg_globals</code> (same structure you gave to <code>pgInit</code>). For example, if your <code>pg_globals</code> structure is called <code>paige_rsrv</code>, this parameter would be passed as follows:</p>
<pre><code>&amp;paige_rsrv.mem_globals
</code></pre>
<h4 id='parameters'>Parameters</h4>
<ul>
<li><code>purge_function</code> — a pointer to a function that will be called by HERMES Paige to write (save) and purge memory allocations and/or to read (restore) purged allocations. However, HERMES Paige will use its own function for <code>purge_proc</code> if you pass a null pointer for <code>purge_proc</code>. Otherwise, if you need to write your own, see <a href='#providing-your-own-purge-function'>Providing Your Own Purge Function</a> under section 4.2 for the definition and explanation of this function.</li>
<li><code>ref_con</code> — contains the necessary information for the purge function to read and write to the disk and what you pass to <code>ref_con</code> depends on the platform you are operating and/or whether or not you are using the standard purge function (<code>purge_function null</code>).</li>

</ul>
<h4 id='how-to-set-up-virtual-memory-macintosh'>How to set up virtual memory (Macintosh)</h4>
<pre><code>// This function inits VM by setting up a temp file in System folder

pg_globals paige_rsrv;	// Same globals as given to pgInit, pgNew
void init_paige_vm(void)
{
	SysEnvRec theWorld;
	sysEnvirons(2, &amp;theWorld);	// Get system info for &quot;folder&quot;
	
	// Get whatever temp file name to use (in this example I get a STR#)
	
	GetIndString(temp_file_name, MISC_STRINGS, TEMP_FILE_STR);
	Create(temp_file_name, theWorld.sysVRefNum, TEMP_FILE_TYPE);
	FSOpen(temp_file_name, theWorld.SysVRefNum, &amp;vm_file);
	InitVirtualMemory(&amp;paige_rsrv.mem_globals, NULL, vm_file);
	
	// Leave temp file open until quit (see below)
}

// Before quit, &quot;shut down&quot; VM by closing temp file

void uninit_paige_vm(void)
{
	FSClose(paige_rsrv.purge_ref_con);	// VM file stored here
}
</code></pre>
<h2 id='42-the-scratch-file'>4.2 The scratch file</h2>
<p>Assuming you will be passing a null pointer to <code>purge_proc</code>, letting HERMES Paige use the built-in purge function, the steps to initialise virtual memory fully are as follows:</p>
<ol start='' >
<li>First, call <code>pgMemStartup</code> to initialise the HERMES Paige Memory Allocation manager, and pass the maximum memory you want HERMES Paige using to <code>max_memory</code> before allocations begin purging. If you want HERMES Paige to use whatever is available, pass 0 for <code>max_memory</code> (see <code>pgMemStartup</code> in the index for additional information).</li>
<li>Create a file that can be used as a &quot;temp&quot; file and open it with read/write access.</li>
<li>Call <code>InitVirtualMemory</code>, passing the file reference from §2 in the <code>ref_con</code> parameter. (For <strong>Macintosh</strong> platform, this should be the file <code>refnum</code> of the opened file; for <strong>Windows</strong> platform, this should be the <code>int</code> returned from <code>OpenFile</code> or <code>GetTempFile</code>, etc.).</li>
<li>Keep the scratch file open until you shut down the Allocation Manager with <code>pgMemShutdown</code>.</li>

</ol>
<p><strong>NOTE:</strong> It is your responsibility to close and/or delete your temp file after your application session with HERMES Paige has terminated.</p>
<p>If you are writing your own purge function, however, <code>ref_con</code> can be anything you require to initialise virtual memory I/O, such as a file reference or a pointer to some structure of your own definition.</p>
<p>After calling the above function, memory allocations will be &quot;spooled&quot; to your temp file as necessary to create a virtual memory environment.</p>
<p>The value originally passed to <code>pgMemStartup</code> — <code>max_memory</code> — dictates the maximum memory available for the HERMES Paige Allocation Manager before allocations must be purged. This is a logical partition, not necessarily physical (i.e., you might have 2 GiB available but only want HERMES Paige to use 50 MiB, in which case you would pass 52428800 to <code>max_memory</code> in <code>pgMemStartup</code>).</p>
<h4 id='providing-your-own-purge-function'>Providing Your Own Purge Function</h4>
<p>In most cases you can use the purging utilities provided in the Allocation Manager, see section 25.15, <a href='#2515-purging-utilities'>Purging Utilities</a>. If necessary, however, you can bypass the built-in memory purge function; for complete details, see section 25.19, <a href='#2519-writing-your-own-purge-function'>Writing Your Own Purge Function</a>.</p>
<h2 id='5-cut-copy-paste'>5 Cut, Copy, Paste</h2>
<p>This section explains how to implement Cut, Copy, Paste and Undo, including additional methods to copy &quot;text only.&quot;</p>
<h3 id='51-copying-and-deleting'>5.1 Copying and Deleting</h3>
<pre><code>(pg_ref) pgCut (pg_ref pg, select_pair_ptr selection, short draw_mode);
(pg_ref) pgCopy (pg_ref pg, select_pair_ptr selection);
(void) pgDelete (pg_ref pg, select_pair_ptr delete_range, short draw_mode);
</code></pre>
<p>To perform a &quot;Cut&quot; operation — for which text is copied and then deleted — call <code>pgCut</code>. The <code>selection</code> parameter is an optional pointer to a pair of text offsets from which to delete text. This is a pointer to the following structure:</p>
<pre><code>typedef struct
{
	long begin;	// Beginning offset of some text portion
	long end;	// Ending offset of some text portion
}
select_pair, *select_pair_ptr;
</code></pre>
<p>The <code>begin</code> field of a <code>select_pair</code> defines the beginning text offset and the <code>end</code> field defines the ending offset. Both offsets are byte counts, not character counts. Text offsets in HERMES Paige are zero-indexed (first offset is zero). The last character &quot;end&quot; is included in <code>selection</code>.</p>
<p><strong>FIGURE 3 SELECTION BEGIN AND END EXPLAINED</strong></p>
<p><img src="figs/fig3.jpg" referrerpolicy="no-referrer"></p>
<p><strong>NOTE:</strong> All offsets are byte counts. In the case of characters, they are each one byte.</p>
<p>If the selection parameter in <code>pgCut</code> is a null pointer, the current selection in <code>pg</code> is used instead (which is usually want you want).</p>
<p><strong>FUNCTION RESULT:</strong> The function result of <code>pgRef</code> is a newly created HERMES Paige object containing the copied text and associated text formatting. You can then pass this <code>pg_ref</code> to <code>pgPaste</code>, below.</p>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none,		// Do not draw at all 
best_way,			// Use most efficient method(s) 
direct_copy,	// Directly to screen, overwrite 
direct_or,		// Directly to screen, &quot;OR&quot; 
direct_xor,		// Directly to screen, &quot;XOR&quot; 
bits_copy,		// Copy offscreen 
bits_or,			// Copy offscreen in &quot;OR&quot; mode 
bits_xor			// Copy offscreen in &quot;XOR&quot; mode
</code></pre>
<h5 id='notes-7'>NOTES:</h5>
<ol start='' >
<li>The <code>pg_ref</code> returned from <code>pickup</code> is a &quot;real&quot; HERMES Paige object, which means you need to eventually dispose of it properly using <code>pgDispose</code>.</li>
<li>Shapes from the source <code>pg_ref</code> are used to &quot;clone&quot; the resulting <code>pg_ref</code> from a copy or cut regardless of the selection range. For example, if the source <code>pg_ref</code> that gets copied contained a <code>page_area</code> shape with dimensions 10, 10, 580, 800, the resulting <code>pg_ref</code> will have the same <code>pg_area</code> shape. The same is true for <code>vis_area</code> and <code>exclude_area</code>.</li>

</ol>
<p><strong>CAUTION:</strong> If there is nothing to copy (no selection range exists), both <code>pgCut</code> and <code>pgCopy</code> will return <code>MEM_NULL</code>.</p>
<p><strong>CAUTION:</strong> It is wise never to display the resulting <code>pg_ref</code> unless you first set a default graphics device to target the display. For example, doing a <code>pgCopy</code> then drawing to a &quot;clipboard&quot; window later could result in a crash. This can happen if the original window containing the copied <code>pg_ref</code> has been closed (rendering an invalid window attached to the copied reference). Hence, before drawing to such a &quot;clipboard&quot;, use <code>pgSetDefaultDevice</code>. See <a href='#setting-a-device'>Setting a device</a> under section 3.4.</p>
<p>The <code>pgCopy</code> function is identical to <code>pgCut</code> except that no text is deleted, only a <code>pg_ref</code> is returned which is the copy of the specified text and formatting and no <code>draw_mode</code> is provided (because the source <code>pg_ref</code> remains unchanged).</p>
<p>HERMES Paige provides excellent error checking for out-of-memory situations with <code>pgCopy</code>. See chapter 26, <a href='#26-exception-handling'>Exception Handling</a>.</p>
<p>The <code>pgDelete</code> function is the same as <code>pgCut</code> in every respect except that a &quot;copy&quot; is neither made nor returned. Use this function when you simply want to delete a selection range but not make a copy (such as a <em>Clear</em> command from a menu).</p>
<h2 id='52-pasting'>5.2 Pasting</h2>
<pre><code>(void) pgPaste (pg_ref pg, pg_ref paste_ref, long position, pg_boolean text_only, short draw_mode);
</code></pre>
<p>The <code>pgPaste</code> function takes <code>paste_ref</code> (typically obtained from <code>pgCut</code> or <code>pgCopy</code>) and inserts all of its text into <code>pg</code>, beginning at text offset position (which is a byte offset). The <code>paste_ref</code>&#39;s contents remain unchanged.</p>
<p>The <code>position</code> parameter, however, can be <code>CURRENT_POSITION</code> (value of -1) in which case the paste occurs at the current insertion point in <code>pg</code>. After the paste the insertion point advances the number of characters that were inserted from <code>paste_ref</code>.</p>
<p>If <code>text_only</code> is <code>TRUE</code>, only the text from <code>paste_ref</code> is inserted — no text formatting is transferred.</p>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none, 		// Do not draw at all
best_way,			// Use most efficient method(s)
direct_copy,	// Directly to screen, overwrite
direct_or,		// Directly to screen, &quot;OR&quot;  
direct_xor,		// Directly to screen, &quot;XOR&quot;  
bits_copy,		// Copy offscreen
bits_or, 			// Copy offscreen, &quot;OR&quot; mode
bits_xor			// Copy offscreen, &quot;XOR&quot; mode
</code></pre>
<h4 id='notes-8'>NOTES:</h4>
<ol start='' >
<li>If there is already selected text in <code>pg</code> (the target <code>pg_ref</code>), it is deleted before the paste occurs.</li>
<li>Only text and styles are affected in the target <code>pg_ref</code> — shapes remain unchanged.</li>

</ol>
<h4 id='tech-note-pgpaste-custom-styles'>TECH NOTE: <code>pgPaste</code> custom styles</h4>
<blockquote><p>I need to know when a custom style gets inserted into a particular <code>pg_ref</code>. That is, if a style is duplicated in an undo or clipboard context, I need to know when the style is inserted into the style table for the &quot;real&quot; <code>pg_ref</code>.</p>
</blockquote>
<p>There are several ways to do this. Which method you choose depends on when you need to know, i.e. if you need to know the instant it occurs versus knowing somewhere in your app following a <code>pgPaste</code> or <code>pgUndo</code>.</p>
<p>By &quot;instant it occurs&quot; I mean when processing a style with one of the hooks, for instance. If that&#39;s what you need, one good way is to use the <code>duplicate</code> function. By mere virtue of getting called at all you know that HERMES Paige is adding that style for one reason or another.</p>
<p>If you need to find out if that style exists at any arbitrary time, one way is to use <code>pgFindStyleInfo</code>. This function searches all style change(s) in the text to find the first occurrence of a particular style. One useful feature in <code>pgFindStyleInfo</code> is that you can set up a &quot;mask&quot; to only compare certain specific fields in your style. I assume your custom style will contain some kind of unique value for you to identify it, in which case this function is probably exactly what you want.</p>
<p>Then there is the &quot;hack&quot; method which looks dangerous, but isn&#39;t really. This method is to look at the whole style info list directly, which should remain compatible with all future HERMES Paige versions <em>and</em> it is even portable between Windows and other platforms! This is done as follows:</p>
<pre><code class='language-c' lang='c'>paige_rec_ptr pg_rec;		// actual struct inside pg_ref
style_info_ptr styles;	// will be pointer to styles
long num_styles;				// will be number of styles avail

pg_rec = UseMemory(pg);	// do this to get paige struct
num_styles = GetMemorySize(pg_rec -&gt; t_formats);	// number of style_info

styles = UseMemory(pg_rec -&gt; t_formats);					// points to first style

/* At this point: styles = pointer to first style_info and num_styles contains number of styles. Hence, you can get next style as styles[1], ++styles, etc. To find your particular style, just walk through and look for it. */

// Once you&#39;re through, you MUST do:

UnuseMemory(pg_rec-&gt;t_formats);
UnuseMemory(pg); 
</code></pre>
<h2 id='53-copying-text-only'>5.3 Copying Text Only</h2>
<pre><code class='language-c' lang='c'>text_ref pgCopyText (pg_ref pg, select_pair_ptr selection, short data_type);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns a memory allocation containing a copy of the text in <code>pg</code>, beginning at the specified offset as follows: if <code>selection</code> is non-null, it is used to determine the <code>selection</code> range (for information about <code>select_pair</code> structure, see section 4.1, <a href='#4.1-copying-and-deleting'>Copying and Deleting</a>). If <code>selection</code> is a null pointer, the current selection range is used.</p>
<p><strong>NOTE:</strong> The <code>memory_ref</code> returned from <code>pgCopyText</code> will have a &quot;record size&quot; set to one byte. In other words, a <code>GetMemorySize()</code> will return the number of bytes copied (which might be different to the number of characters, since HERMES Paige can in principle handle multibyte characters).</p>
<p>The <code>data_type</code> parameter specifies which type of text to copy which can be one of the following:</p>
<pre><code class='language-c' lang='c'>typedef enum
{
	all_data,								// Return all data
	all_text_chars,					// All text that is writing script
	all_roman,							// All Latin ASCII chars
	all_visible_data,				// Return all visible data
	all_visible_text_chars,	// All visible text that is writing script
	all_visible_roman				// All visible Latin ASCII chars
};
</code></pre>
<p>If <code>data_type</code> is <code>all_data</code>, every byte in the specified range is copied; if <code>all_text_chars</code>, all single-byte text is copied (which excludes only custom characters that aren&#39;t really &quot;text&quot;); for <code>all_roman</code>, only ASCII characters of Latin script are copied (as opposed to some other script such as Chinese or Arabic).</p>
<p>The function result is typed as a <code>text_ref</code>, which is a memory allocation created by the HERMES Paige Allocation Manager.</p>
<p><strong>NOTE:</strong> &quot;Single byte text&quot; in the above sense does not refer to single or double byte scripts such as Roman vs. Kanji. The <code>all_text_chars</code> data type will in fact include double-byte script. The only type excluded in this case is embedded graphics, controls, or some other customised text stream that really isn&#39;t text.</p>
<p>See also section 24.5, <a href='#245-examine-text'>Examine Text</a>.</p>
<h3 id='tech-note-no-zeros-at-the-end-of-pgcopytext'>TECH NOTE: No zeros at the end of pgCopyText</h3>
<blockquote><p>I got my text in a <code>text_ref</code> with <code>pgcopyText</code>, but there is no 0 at the end!</p>
<ol start='' >
<li>Can I simply add a zero at the end to create a zero-delimited string?</li>
<li>How do I know where the end is?</li>

</ol>
</blockquote>
<p>Point one: yes, but you <em>must</em> be careful since the <code>memory_ref</code> is only guaranteed to have allocated the number of bytes in the selection sent to <code>pgCopyText</code>. So if you want to append a zero, you should use <code>AppendMemory</code>, then put in the value.</p>
<pre><code class='language-c' lang='c'>memory_ref the_text;
the_text = pgCopyText(pg, &amp;the_selection, all_data);

/* put a zero on the end so the parser doesn&#39;t walk off the end of the text */

AppendMemory(the_text, sizeof(pg_char), true);
UnuseMemory(the_text);
</code></pre>
<p>Point two: you can find the size of the text with <code>GetMemorySize()</code>, which will return the number of &quot;records&quot;, which, in this case, will be the number of characters. Alternatively, you know the number of characters going into <code>pgCopyText</code> by knowing the selection range(s).</p>
<h1 id='6-undo-and-redo'>6 Undo and Redo</h1>
<p>HERMES Paige provides a variety of functions to fully support several kinds of &quot;undo&quot; for most situations. HERMES Paige provides a convenient method of building custom undos which can be incorporated into your own application as well.</p>
<h2 id='61-concept-of-undo'>6.1 Concept of Undo</h2>
<p>The concept of HERMES Paige &quot;undo&quot; support is as follows: Before you do anything to an HERMES Paige object that you want to be undoable, call <code>pgPrepareUndo</code> if you are about to do a <code>pgCut</code>, <code>pgDelete</code>, <code>pgPaste</code>, or any style, font or paragraph formatting change. The function result can then be given to <code>pgUndo</code> which will cause a reversal of what was performed.</p>
<p>For setting up an undo for <code>pgCut</code> or <code>pgDelete</code>, pass <code>undo_delete</code> for the verb parameter and a null pointer for <code>paste_ref</code>, for setting up an undo for <code>pgPaste</code>, pass <code>undo_paste</code> for the <code>verb</code> and the <code>pg_ref</code> you intend to paste from in <code>paste_ref</code>. For formatting changes (setting different fonts and styles or paragraph formats), pass <code>undo_format</code> for <code>verb</code> and null pointer for <code>paste_ref</code>.</p>
<h3 id='62-prepare-undo'>6.2 Prepare Undo</h3>
<p>To implement these features you must make the following function call prior to performing something that is undoable:</p>
<pre><code>(undo_ref) pgPrepareUndo (pg_ref pg, short verb, void PG_FAR *insert_ref);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns a special memory allocation which you can give to <code>pgUndo</code> (below) to perform an Undo.</p>
<p>The <code>verb</code> parameter defines what you are about to perform, which can be one of the following:</p>
<pre><code>typedef enum
{
	undo_none,						// Null undo (&quot;can&#39;t undo&quot;)
	undo_typing,					// Undo key entry except bksp and forward delete
	undo_backspace,				// Undo backspace key
	undo_delete,					// Undo clear/cut/delete
	undo_fwd_delete,			// Undo forward delete
	undo_paste,						// Undo paste/insert
	undo_format,					// Undo text style, para format, or font
	undo_insert,					// Undo some other form of insertion
	undo_page_change,			// Undo page area change
	undo_vis_change,			// Undo vis area change
	undo_exclude_change,	// Undo exclusion area change
	undo_doc_info,				// Undo setDocInfo change
	undo_embed_insert,		// Undo embed_ref insertion
	undo_app_insert				// Undo insert with position parameter
};
</code></pre>
<p><em>About to perform</em> means that you are about to do something you wish to be undoable later on. This includes performing a deletion, insertion, or text formatting change of any kind.</p>
<h2 id='63-the-insertref-parameter'>6.3 The <code>insert_ref</code> Parameter</h2>
<p>For <code>undo_paste</code>, <code>insert_ref</code> must be the <code>pg_ref</code> you intend to paste (the source &quot;scrap&quot;); for <code>undo_insert</code>, <code>insert_ref</code> must be a pointer to the number of bytes to be inserted.</p>
<p>The <code>undo_app_insert</code> <code>verb</code> is identical to <code>undo_insert</code> except you must specify the insert location (<code>undo_insert</code> assumes the current text position). To do so, <code>insert_ref</code> must be a pointer to an array of two long words, the first element should be the text position to be inserted and the second element the insertion size, in bytes.</p>
<p>For <code>undo_typing</code>, <code>undo_backspace</code> and <code>undo_fwd_delete</code>, <code>insert_ref</code> should be the previous undo_ref you received for any <code>pgPrepareUndo</code> — or NULL if none.</p>
<p><strong>NOTE:</strong> <code>insert_ref</code>, in this case, is an <code>undo_ref</code> — not a pointer to one — so you must coerce the <code>undo_ref</code> as <code>(void PG_FAR *)</code>.</p>
<p>For all other undo preparations, <code>insert_ref</code> should be NULL.</p>
<h3 id='insert-100-bytes'>Insert 100 bytes</h3>
<p>If you are about to insert, say, 100 bytes, you would call <code>pgPrepareUndo</code> as follows:</p>
<pre><code class='language-c' lang='c'>long length;
length = 100;
pgPrepareUndo(pg, undo_insert, (void PG_FAR *) &amp;length);

/* The following function inserts a key into pg and returns the undo_ref that can be used to perform &quot;Undo typing&quot;. The last_undo is the previous undo_ref, or MEM_NULL if none. */

undo_ref insert_width_undo (pg_ref pg, pg_char the_key, undo_ref last_undo)
{
	undo_reffunction_result;
	
	if (the_key &gt;= &#39; &#39;)	// if control char
	{
		if(the_key == FWD_DELETE_CHAR)
			function_result = pgPrepareUndo(pg, undo_fwd_delete, (void PG_FAR *) last_undo);
		else
			function_result = pgPrepareUndo(pg, undo_typing, (void *) undo);
	}
	else if (the_key == BACKSPACE_CHAR)
		function_result = pgPrepareUndo(pg, undo_backspace, (void *) undo);
		pgInsert(pg, (pg_char_ptr) &amp;the_key, sizeof(pg_char), CURRENT_POSITION, key_insert_mode, 0, best_way);
		return function_result;
}
</code></pre>
<p>	
For <code>undo_paste</code>, <code>insert_ref</code> must be the <code>pg_ref</code> you are about to paste (same as before).</p>
<p>For all other undo <code>verb</code>s, <code>insert_ref</code> is not used (so can be <code>NULL</code>).</p>
<h2 id='64-additional-undo-verbs'>6.4 Additional Undo <code>verb</code>s</h2>
<p><code>undo_page_change</code> can be used before changing the page shape, <code>undo_vis_change</code> before changing the visual area, and <code>undo_exclude_change</code> before changing the exclusion area.</p>
<p>The <code>undo_doc_info</code> <code>verb</code> can be given before changing anything in <code>pg_ref</code>&#39;s <code>doc_info</code>. For example, you could do “Undo Page Setup” with this undo <code>verb</code>.</p>
<p>The <code>undo_embed_insert</code> <code>verb</code> can be used before inserting an <code>embed_ref</code> (see chapter on Embedded Objects). Note, unlike <code>undo_insert</code> and <code>undo_app_insert</code>, the <code>insert_ref</code> parameter should be <code>NULL</code> for <code>undo_embed_insert</code>.</p>
<h3 id='undoing-containers'>Undoing &quot;Containers&quot;</h3>
<p>When you use <code>undo_page_change</code>, HERMES Paige will set up an undo (and restore upon redo) both &quot;container&quot; rectangles and the associated refcons. You can therefore perform a full Undo Container Change.</p>
<h2 id='65-performing-the-undo'>6.5 Performing the Undo</h2>
<p>To perform the actual Undo operation, pass an <code>undo_ref</code> to the following:</p>
<pre><code class='language-c' lang='c'>(undo_ref) pgUndo (pg_ref pg, undo_ref ref, pg_boolean requires_redo, short draw_mode);
</code></pre>
<p>The <code>ref</code> parameter must be an <code>undo_ref</code> obtained from <code>pgPrepareUndo</code>.</p>
<p>If <code>requires_redo</code> is <code>TRUE</code>, <code>pgUndo</code> returns a new <code>undo_ref</code> which can be used for a &quot;Redo&quot;.</p>
<p>For example, if the <code>undo_ref</code> passed to this function performed an &quot;Undo Cut,&quot; and <code>requires_redo</code> is given as <code>TRUE</code>, the function will return a new <code>undo_ref</code> which, if given to <code>pgUndo</code> again, would perform a &quot;Redo Cut.&quot; Undo/Redo results can be toggled back and forth this way virtually forever.</p>
<p><code>draw_mode</code> can be the values described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none, 		// Do not draw at all
best_way,			// Use most efficient method(s)
direct_copy,	// Directly to screen, overwrite
direct_or,		// Directly to screen, &quot;OR&quot;  
direct_xor,		// Directly to screen, &quot;XOR&quot;  
bits_copy,		// Copy offscreen
bits_or, 			// Copy offscreen, &quot;OR&quot; mode
bits_xor			// Copy offscreen, &quot;XOR&quot; mode
</code></pre>
<p>Generally, if you want the HERMES Paige object to re-draw, pass <code>best_way</code> for <code>draw_mode</code>.</p>
<h5 id='notes-9'>NOTES </h5>
<ol start='' >
<li><code>pgUndo</code> returns a new <code>undo_ref</code>, which is a completely different allocation to the <code>undo_ref</code> you passed to it. It is your responsibility to dispose all <code>undo_ref</code>s.</li>
<li>When an Undo is performed, it does not matter what the selection point (or selection range) is in <code>pg</code> at the time — <code>pgUndo</code> will restore whatever selection range(s) existed at the time the <code>undo_ref</code> was created. For example, if the user performs an action for which you created an <code>undo_ref</code>, such as a Paste, and then he selects some other text or clicks at a different location, <code>pgUndo</code> still works correctly, given that the original insertion point for the Paste is recorded in the <code>undo_ref</code>.</li>

</ol>
<h2 id='66-disposing-undorefs'>6.6 Disposing <code>undo_ref</code>s</h2>
<p>Once you are through using an <code>undo_ref</code>, dispose it by calling the following function:</p>
<pre><code>(void) pgDisposeUndo (undo_ref ref);
</code></pre>
<p>The <code>ref</code> parameter must be a valid <code>undo_ref</code> (received from <code>pgPrepareUndo</code> or <code>pgUndo</code>); or, <code>ref</code> can be <code>MEM_NULL</code> (in which case <code>pgDisposeUndo()</code> does nothing).</p>
<h5 id='notes-10'>NOTES</h5>
<ol start='' >
<li><code>MEM_NULL</code> is allowed intentionally, so that you can blindly pass your application&#39;s last &quot;undoable&quot; operation that can be set initially to <code>MEM_NULL</code>.</li>
<li>There are a few cases where you should not dispose an <code>undo_ref</code> — see following.</li>

</ol>
<h3 id='disposing-the-previous-prepare-undo'>Disposing the Previous Prepare-Undo</h3>
<p>If you are implementing single-level undo support (user can only undo the last operation), you would normally need to dispose the &quot;old&quot; <code>undo_ref</code> (the one returned from the previous <code>pgPrepareUndo()</code>) before preparing for the next undo. For <code>undo_typing</code>, <code>undo_fwd_delete</code>, and <code>undo_backspace</code>, you must not dispose the &quot;old&quot; <code>undo_ref</code> — these are the lone exceptions to the &quot;dispose-old-undo&quot; rule.</p>
<p>The reason for this is that you give HERMES Paige the &quot;old&quot; <code>undo_ref</code> as the <code>insert_ref</code> parameter; for <code>undo_typing</code>, <code>undo_backspace</code>, and <code>undo_fwd_delete</code>, the <code>undo_ref</code> given in <code>insert_ref</code> is either disposed or returned back to you as the function result.</p>
<p>Never dispose the &quot;previous&quot; <code>undo_ref</code> when preparing for any of these &quot;character&quot; undos (<code>undo_typing</code>, <code>undo_backspace</code> and <code>undo_fwd_delete</code>). In all other cases, it is OK to dispose the previous <code>undo_ref</code>.</p>
<h2 id='67-undo-type'>6.7 Undo Type</h2>
<pre><code>short pgUndoType (undo_ref ref);
</code></pre>
<p>This returns what type of <code>undo_ref</code> will perform.</p>
<p><strong>FUNCTION RESULT:</strong> The function returns one of the undo <code>verb</code>s listed above under <code>pgPrepareUndo</code>, or a negative complement of a <code>verb</code>.</p>
<p>If the <code>undo_ref</code> is intended for a redo (returned from <code>pgUndo</code>, the verb will be its negative complement. For example, if <code>pgUndoType()</code> returns <code>undo_paste</code>, a call to <code>pgUndo()</code> would essentially perform a &quot;Redo Paste&quot;.</p>
<p>A good use for this function is to set up a menu item for the user to indicate what can be undone.</p>
<h5 id='note-14'>NOTE</h5>
<p>If you want to record more information about an Undo operation than the undo verbs listed above, use <code>pgSetUndoRefCon</code>, of which an explanation follows.</p>
<h2 id='68-undo-refcon'>6.8 Undo <code>RefCon</code></h2>
<pre><code class='language-c' lang='c'>(void) pgSetUndoRefCon (undo_ref ref, long refCon);
(long) pgGetUndoRefCon (undo_ref ref);
</code></pre>
<p>These two functions allow you set (or get) a long reference inside an <code>undo_ref</code>.</p>
<p>The <code>ref</code> parameter must be a valid <code>undo_ref</code>; for <code>pgSetUndoRefCon</code>, refCon can be anything. <code>pgGetUndoRefCon</code> returns whatever has been set in <code>ref</code>.</p>
<h2 id='69-customising-undo'>6.9 Customising Undo</h2>
<p>HERMES Paige has a low-level hook for which you can use to implement modified undo actions, or you can completely customise an undo regardless of its complexity. For more information, see chapter 27, <a href='#27-customising-hermes-paige'>Customising HERMES Paige</a>.</p>
<h2 id='610-multilevel-undo'>6.10 Multilevel Undo</h2>
<p>Your application can theoretically provide multiple-level Undo support by simply preparing a &quot;stack&quot; of <code>undo_ref</code>s returned from <code>pgPrepareUndo</code>. Given that each <code>undo_ref</code> is independent of the next (i.e. there are no data structures within an <code>undo_ref</code> that depend on other <code>undo_ref</code> s or even <code>pg_ref</code>s), an application can keep as many of these around as desired to achieve &quot;Undo of Undo&quot; and &quot;Undo of Undo of Undo,&quot; etc.</p>
<p>Supporting a multilevel Undo (being able to undo the last several operations) simply involves &quot;stacking&quot; the <code>undo_ref</code>s returned from <code>pgPrepareUndo</code>.</p>
<h5 id='caution-5'>CAUTION</h5>
<p>When you set up for &quot;Undo Typing&quot; (be it for a regular insertion, backspace or forward delete), HERMES Paige might return the same <code>undo_ref</code> that was given to <code>pgPrepareUndo</code>, and/or it might delete the previous <code>undo_ref</code> passed to the <code>insert_ref</code> parameter. In this case, make sure you check for this situation and handle it.</p>
<h5 id='example-5'>Example</h5>
<pre><code class='language-c' lang='c'>/* The following code places consecutive undo_refs into an array so multi-level &quot;Undo&quot; can be supported. While we only show stacking a maximum of 16, it can of course be bigger. */

undo_ref stacked_refs[16];
short stack_index = 0;			// Begins with &quot;no undos&quot;.

/* We call &quot;PrepareUndo&quot; from several places in the program. The verb is the undo_verb to be performed. */

void PrepareUndo(pg_ref pg, short_verb)
{
	undo_ref new_undo, previous_undo;
	previous_undo = MEM_NULL;	// Assume no previous undo.
	if (verb == undo_typing || verb == undo_fwd_delete || verb == undo_backspace)
	if (stack_index &gt; 0)		// There is a previous undo.
	if (pgUndoType(stacked_refs[stack_index - 1] == verb)) 
		otherparam = stacked_refs[stack_index - 1];
		new_undo = pgPrepareUndo(pg, verb, (void PG_FAR *))
		previous_undo;
	
	// Check to see if HERMES Paige returned the same undo_ref.
	
	if(!previous_undo || new_undo != previous_undo_
		++stack_index;
	
	stacked_refs[stack_index - 1] = new_undo;
}
</code></pre>
<h1 id='7-clipboard-support'>7 CLIPBOARD SUPPORT</h1>
<p>HERMES Paige provides a certain degree of automatic support for the external clipboard, regardless of platform.</p>
<h2 id='71-writing-to-the-clipboard'>7.1 Writing to the Clipboard</h2>
<pre><code class='language-c' lang='c'>void pgPutScrap(pg_ref the_scrap, pg_os_type native_format, short scrap_type);
</code></pre>
<p>This function writes the appropriate data to the external clipboard for other applications to read (including your own application). The data to be written is contained in <code>the_scrap</code>; usually, <code>the_scrap</code> would have been returned earlier from <code>pgCopy()</code> or <code>pgCut()</code>.</p>
<p>The <code>scrap_type</code> parameter indicates the preferred format within <code>pg</code> to write to the clipboard. If <code>scrap_type</code> is <code>pg_void_scrap</code> (value of zero), HERMES Paige will write whatever format(s) are appropriate, including its own native type.</p>
<p>If <code>scrap_type</code> is non-zero, it must be one of  <code>pg_native_scrap</code> (the HERMES Paige native format), <code>pg_text_scrap</code> (ASCII text), or <code>pg_embed_scrap</code> (the contents of an <code>embed_ref</code>).</p>
<p>For <code>pg_embed_scrap</code>, only <code>embed_mac_pict</code> (for Macintosh) and <code>embed_meta_file</code> (for Windows) are supported, and only the first <code>embed_ref</code> found within <code>the_scrap</code> is written to the clipboard.</p>
<p>The <code>native_format</code> parameter should contain a platform-appropriate identifier for a native HERMES Paige format. For the Macintosh platform, <code>pg_os_type</code> is an <code>OSType</code> parameter; for the Windows platform, <code>pg_os_type</code> is a <code>WORD</code> parameter (Win16) or <code>int</code> parameter (Win32). Note that the value you place in <code>native_format</code> depends upon the runtime platform, as follows:</p>
<h3 id='windows-only'>Windows only</h3>
<p>You must first register a new format type by calling <code>RegisterClipboardFormat()</code>, then use that format type for every call to <code>pgPutScrap()</code> and <code>pgGetScrap()</code>. The name of this format type can be arbitrary; however, to remain consistent we recommend the name used by the custom control, &quot;HERMES Paige&quot;.</p>
<h5 id='notes-11'>NOTES</h5>
<ol start='' >
<li><strong>IMPORTANT!</strong> You must call <code>OpenClipboard()</code> before calling <code>pgPutScrap()</code>, then call <code>CloseClipboard()</code> after this function has returned. HERMES Paige can&#39;t open the clipboard for you because it can&#39;t assume there is a valid <code>HWND</code> available within its structure.</li>
<li>All data from the clipboard is copied, i.e. the data within the <code>pg_ref</code> is not owned by the clipboard.</li>

</ol>
<h3 id='macintosh-only'>Macintosh only</h3>
<p>For Macintosh, a <code>pg_os_type</code> is identical to <code>OSType</code>. The name of this format type can be arbitrary; however, to remain consistent we recommend the name used by the custom control, <code>paig</code>.</p>
<h3 id='all-platforms-2'>All Platforms</h3>
<p>For both Macintosh and Windows platform, the clipboard is cleared before any data is written. If it is successful, the data can be read from the clipboard by calling <code>pgGetScrap()</code>, below.</p>
<h2 id='72-reading-from-the-clipboard'>7.2 Reading from the Clipboard</h2>
<pre><code>pg_ref pgGetScrap (pg_globals_ptr globals, pg_os_type native_format, embed_callback def_embed_callback);
</code></pre>
<p>This function checks the external clipboard for a recognisable format and, if found, returns a new <code>pg_ref</code> containing the data; the <code>pg_ref</code> can then be passed to <code>pgPaste</code>. This function will work for both Macintosh and Windows-based applications.</p>
<p>The <code>globals</code> parameter must be a pointer to the HERMES Paige globals structure (same structure used for <code>pgNew()</code>).</p>
<p>The <code>native_format</code> parameter should contain the same native format type identifier that was given to <code>pgPutScrap()</code>. For example, if running on a Macintosh, the <code>native_format</code> might be <code>paig</code>. On a Windows machine, <code>native_format</code> would be the value returned from <code>RegisterClipboardFormat()</code>.</p>
<p>The <code>def_embed_callback</code> parameter is an optional function pointer to an <code>embed_ref</code> callback function. The purpose of providing this parameter is to initialise any <code>embed_ref</code>s read from the clipboard to use your callback function. If <code>def_embed_callback</code> is NULL it will be ignored (and the default callback used by HERMES Paige will be placed into any <code>embed_ref</code>s read).</p>
<h5 id='note-windows-4'>NOTE (Windows)</h5>
<p><strong>IMPORTANT:</strong> You must call <code>OpenClipboard()</code> before calling <code>pgGetScrap()</code>, then call <code>CloseClipboard()</code> after you are through processing the data. HERMES Paige can&#39;t open the clipboard for you because it can&#39;t assume there is a valid <code>HWND</code> available within its structure.</p>
<h3 id='function-result-3'>Function Result</h3>
<p>If a format is recognized on the clipboard, a new <code>pg_ref</code> is returned containing the clipboard data. If no format(s) are recognized, <code>MEM_NULL</code> is returned.</p>
<h5 id='note-15'>NOTE</h5>
<p>It is your responsibility to dispose the <code>pg_ref</code> returned from this function.</p>
<h2 id='73-format-type-priorities'>7.3 Format Type Priorities</h2>
<h3 id='windows-2'>Windows</h3>
<p>HERMES Paige will check the clipboard for format types it can support in the following priority order:</p>
<ol start='' >
<li>HERMES Paige native format (taken from <code>native_format</code> parameter).</li>
<li>Text (<code>CF_TEXT</code>).</li>
<li>Metafile (<code>CF_METAFILEPICT</code>)</li>
<li>Bitmap (<code>CF_BITMAP</code>)</li>

</ol>
<p>If none of the above formats are found, <code>pgGetScrap()</code> returns <code>MEM_NULL</code>.</p>
<h3 id='macintosh-2'>Macintosh</h3>
<p>HERMES Paige will check the clipboard for format types it can support in the following priority order:</p>
<ol start='' >
<li>HERMES Paige native format (taken from <code>native_format</code> parameter).</li>
<li>Text (<code>TEXT</code>).</li>
<li>Picture (<code>PICT</code>).</li>

</ol>
<p>If none of the above formats are found, <code>pgGetScrap</code> returns MEM_NULL.</p>
<h2 id='74-checking-clipboard-availability'>7.4 Checking Clipboard Availability</h2>
<pre><code>pg_boolean pgScrapAvail (pg_os_type native_format);
</code></pre>
<p>This function returns <code>TRUE</code> if there is a recognisable format in the clipboard. No data is read from the clipboard — only the data availability is returned.</p>
<p>The <code>native_format</code> should be the appropriate clipboard format type for the HERMES Paige native format (see <code>pgPutScrap()</code> above).</p>
<p>This function is useful for controlling menu items, e.g. disabling &quot;Paste&quot; if nothing is in the clipboard.</p>
<h5 id='note-windows-5'>NOTE (Windows)</h5>
<p><strong>IMPORTANT:</strong> You should call <code>OpenClipboard()</code> before calling <code>pgScrapAvail()</code>, then call <code>CloseClipboard()</code> after this function has returned.</p>
<h1 id='8-style-basics'>8 STYLE BASICS</h1>
<p>HERMES Paige maintains three separate text formatting runs (series of text formatting changes): styles (bold, italic, super/subscript, etc.), fonts (Helvetica, Times, etc.) and paragraph formats (indentations, tabs, justification, etc.).</p>
<p>Each of these three formats can be changed separately; any portion of text can be a combination of each of these formats. Setting each of those is described in detail in chapter 30, <a href='#30-advanced-styles'>Advanced Styles</a>. This chapter, <em>Style Basics</em>, describes the easiest, quickest, and simplest way to set the style, font and paragraph format you want.</p>
<h5 id='note-16'>NOTE</h5>
<p>Unlike a Windows font that defines the whole composite format of text, the term <em>font</em> as used in this chapter generally refers only to a typeface, or typeface name. HERMES Paige considers a <em>font</em> to simply be a specific family such as Candara, Consolas, Corbel, etc., while distinguishing other formatting properties such as bold, italic, underline, etc. as the text <em>style</em>.</p>
<h2 id='81-simplified-fonts-and-styles'>8.1 Simplified Fonts and Styles</h2>
<p>The simplest way to change the text in a <code>pg_ref</code> to different fonts, style or color is to use the high-level utility functions provided with HERMES Paige version 3.0. These utilities provide a &quot;wrapper&quot; around the lower-level HERMES Paige functions that change styles, fonts and text colors.</p>
<p>The source code to the wrapper has also been provided for your convenience, so you can alter them as necessary to fit your particular application. Or, you can examine them as reference material as the need occurs to apply more sophisticated stylization to your document.</p>
<h3 id='installing-the-wrapper'>Installing the Wrapper</h3>
<p>All the functions listed in this section can be installed by including the source file <code>pgHLevel.c</code> in your project and <code>pgHLevel.h</code> as its header file. These functions can be called from both Macintosh and Windows platforms and should work with all compilers that support standard C conventions.</p>
<h5 id='note-17'>NOTE</h5>
<p>If your application requires more sophistication than provided in this high-level wrapper, and/or if you cannot use the wrapper for any reason, please see chapter 30, <a href='#30-advanced-styles'>Advanced Styles</a>.</p>
<h2 id='82-selection-range'>8.2 Selection Range</h2>
<p>Most of the functions in this chapter require a selection range, <code>select_pairs</code> and <code>CURRENT_SELECTION</code>.</p>
<p>The selection range defines the range of text that should be changed, or if you pass a null pointer the current selection range (or insertion point) in <code>pg</code> is changed.</p>
<pre><code class='language-c' lang='c'>typedef struct
{
	long begin;	// Beginning offset of some text portion
	long end		// Ending offset of some text portion
}
select_pair
typedef select_pair PG_FAR *select_pair_ptr;
</code></pre>
<p>The <code>begin</code> field of a <code>select_pair</code> defines the beginning text offset and the <code>end</code> field defines the ending offset. Both offsets are byte offsets, not character offsets. Text offsets in HERMES Paige are zero-indexed (i.e., the first offset is zero).</p>
<h2 id='83-changing--getting-fonts'>8.3 Changing / Getting Fonts</h2>
<h4 id='windows-prototype'>Windows prototype</h4>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
void pgSetFontByName (pg_ref pg, LPSTR font_name, select_pair_ptr selection_range, pg_boolean redraw);
</code></pre>
<h4 id='macintosh-prototype'>Macintosh prototype</h4>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
void pgSetFontByName (pg_ref pg, Str255 font_name, select_pair_ptr selection_range, pg_boolean redraw);
</code></pre>
<p>This function changes the text in <code>pg</code> to the specified <code>font_name</code>.</p>
<p>If <code>selection_range</code> is a null pointer, the text in <code>pg</code> currently selected is changed (or, if nothing is selected, the font is applied to the next key insertion).</p>
<p>If <code>selection_range</code> is not null, it must point to a <code>select_pair</code> record defining the beginning and ending text offsets to apply the font. (See also section 8.2, <a href='8.2-selection-range'>Selection Range</a>).</p>
<p>If <code>redraw</code> is TRUE the changed text is redrawn if there was a selected range affected.</p>
<h5 id='note-18'>NOTE</h5>
<p>Only the font is affected in the composite style of the specified text; <em>i.e.</em>, the text will retain its current point size and its other style attributes, with only the font family changing.</p>
<h4 id='macintosh-prototype-2'>Macintosh prototype</h4>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
pg_boolean pgGetFontByName (pg_ref pg, Str255 font_name);
</code></pre>
<h4 id='windows-prototype-2'>Windows prototype</h4>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
pg_boolean pgGetFontByName (pg_ref pg, LPSTR font_name);
</code></pre>
<p>This function returns the font name that is applied to the text currently highlighted in <code>pg</code> (or, if nothing is highlighted, the font that applies to the current insertion point is returned).</p>
<p>The font name is returned in <code>font_name</code>. If, however, the text is selected and the text range has more than one font, <code>pgGetFontByName</code> returns <code>FALSE</code> and <code>font_name</code> is not certain.</p>
<h2 id='84-settinggetting-point-size'>8.4 Setting/Getting Point Size</h2>
<h4 id='prototype-same-for-both-mac-and-windows'>Prototype (same for both Mac and Windows)</h4>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
void pgSetPointSize (pg_ref pg, short point_size, select_pair_ptr selection_range, pg_boolean redraw);
</code></pre>
<p>This function changes the text point size to the new size specified.</p>
<p>If <code>selection_range</code> is a null pointer, the text in <code>pg</code> currently highlighted is changed (or, if nothing is highlighted, the point size is applied to the next key insertion).</p>
<p>If <code>selection_range</code> is not null, it must point to a <code>select_pair</code> record defining the beginning and ending text offsets to apply the size. (See also section 8.2, <a href='#82-selection-range'>Selection Range</a>).</p>
<p>If <code>redraw</code> is <code>TRUE</code>, the changed text is redrawn if there was a selected range affected.</p>
<h5 id='note-19'>NOTE</h5>
<p>Only the text size is affected in the composite style of the specified text, i.e. the text will retain its current font family and its other style attributes; only the point size changes.</p>
<h4 id='prototype-same-for-both-mac-and-windows-2'>Prototype (same for both Mac and Windows)</h4>
<pre><code>#include &quot;pgHLevel.h&quot;
pg_boolean pgGetPointsize (pg_ref pg, short PG_FAR *point_size);
</code></pre>
<p>This function returns the point size that is applied to the text currently selected in <code>pg</code> (or, if nothing is selected, the point size that applies to the current insertion point is returned).</p>
<p>The point size is returned in <code>*point_size</code> (which must not be a null pointer). However, if the text is highlighted and the text range has more than one size, <code>pgGetPointsize</code> returns <code>FALSE</code> and <code>*point_size</code> is not certain.</p>
<h2 id='85-settinggetting-styles'>8.5 Setting/Getting Styles</h2>
<h3 id='setting-easy-styles'>Setting easy styles</h3>
<h4 id='prototype-same-for-mac-and-windows'>Prototype (same for Mac and Windows)</h4>
<pre><code>#include &quot;pgHLevel.h&quot;
void pgSetStyleBits (pg_ref pg, long style_bits, long set_which_bits, select_pair_ptr selection_range, pg_boolean_redraw);
</code></pre>
<p>This function changes the text style(s) to the new style(s) specified. &quot;Styles&quot; refers to text drawing characteristics such as bold, italic, underline, etc.</p>
<p>The style(s) to apply are represented in <code>style_bits</code>, which can be a composite of any of the following values:</p>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
#define X_PLAIN_TEXT	 					0x00000000
#define X_BOLD_BIT							0x00000001
#define X_ITALIC_BIT						0x00000002
#define X_UNDERLINE_BIT					0x00000004
#define X_OUTLINE_BIT 					0x00000008
#define X_SHADOW_BIT						0x00000010
#define X_CONDENSE_BIT					0x00000020
#define X_EXTEND_BIT						0x00000040
#define X_DBL_UNDERLINE_BIT			0x00000080
#define X_WORD_UNDERLINE_BIT		0x00000100
#define X_DOTTED_UNDERLINE_BIT	0x00000200
#define X_HIDDEN_TEXT_BIT				0x00000400
#define X_STRIKEOUT_BIT					0x00000800
#define X_SUPERSCRIPT_BIT				0x00001000
#define X_SUBSCRIPT_BIT					0x00002000
#define X_ROTATION_BIT					0x00004000
#define X_ALL_CAPS_BIT					0x00008000
#define X_ALL_LOWER_BIT					0x00010000
#define X_SMALL_CAPS_BIT				0x00020000
#define X_OVERLINE_BIT					0x00040000
#define X_BOXED_BIT							0x00080000
#define X_RELATIVE_POINT_BIT		0x00100000
#define X_SUPERIMPOSE_BIT				0x00200000
#define X_ALL_STYLES						0xFFFFFFFF
</code></pre>
<p>The <code>set_which_bits</code> parameter specifies which of the styles specified in <code>style_bits</code> to actually apply; the value(s) you place in <code>set_which_bits</code> should simply be the bits (as defined above) that you want to change.</p>
<p>The purpose of <code>set_which_bits</code> is to distinguish between a style you choose to force to &quot;off&quot; versus a style you choose to remain unchanged.</p>
<p>For example, suppose you want to change all the selected text to boldface but leave the other styles of the text unchanged. To do so, you would simply pass <code>X_BOLD_BIT</code> in both <code>style_bits</code> and <code>set_which_bits</code>.</p>
<p>However, suppose you want to force the selected text to <em>strictly</em> bold (forcing all other styles <strong>off</strong>). In this case, you would pass <code>X_BOLD_BIT</code> in <code>style_bits</code> and 0xFFFFFFFF (or <code>X_ALL_STYLES</code> ) in <code>set_which_bits</code>.</p>
<p>Also note for &quot;plain&quot; text (forcing all styles <strong>off</strong>), pass <code>X_PLAIN_TEXT</code> for <code>style_bits</code> and <code>X_ALL_STYLES</code> for <code>set_which_bits</code>.</p>
<p>If <code>selection_range</code> is a null pointer, the text in <code>pg</code> currently selected is changed (or, if nothing is selected, the style(s) are applied to the next key insertion).</p>
<p>If <code>selection_range</code> is not null, it must point to a <code>select_pair</code> record defining the beginning and ending text offsets to apply the style(s). (See also section 8.2, <a href='#82-selection-range'>Selection Range</a>).</p>
<p>If <code>redraw</code> is <code>TRUE</code> and a selected range is affected, the changed text is redrawn.</p>
<h5 id='note-20'>NOTE</h5>
<p>Only the specified style attributes will affect the text, i.e. the selected text will retain its font family and point size, and all other style attributes that are not specified in <code>set_which_bits</code>.</p>
<h5 id='note-macintosh-3'>NOTE (Macintosh)</h5>
<p>The first six style definition bits are identical to QuickDraw&#39;s style bits. You might find it convenient to simply pass the QuickDraw style(s) to this function.</p>
<h3 id='getting-style-example'>Getting Style Example</h3>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;

/* The following code sets the text currently selected in pg to bold-italic but leaves all other styles in the text alone. The text gets re-draw with the changes if we had a highlight range.*/

long style_bits = X_BOLD_BIT | X_ITALIC_BIT;
pgSetStyleBits(pg, style_bits, style_bits, NULL, TRUE);

/* The following code sets the text currently selected in pg to bold-italic but does NOT leave the other styles alone (forces text to bold-italic and turns off all other styles). The text gets re-drawn with the changes if we had a highlight range. */

long style_bits = X_BOLD_BIT | X_ITALIC_BIT; pgSetStyleBits(pg, style_bits , X_ALL_STYLES, NULL, TRUE);

 // The following code changes all the selected text to &quot;plain&quot; 
 
 pgSetStyleBits(pg, X_PLAIN_TEXT, X_ALL_STYLES, NULL, TRUE);
</code></pre>
<h2 id='prototype-both-mac-and-windows'>Prototype (both Mac and Windows)</h2>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
void pgGetStyleBits (pg_ref pg, long PG_FAR *style_bits, long PG_FAR *consistent_bits);
</code></pre>
<p>This function returns the style(s) that are applied to the text currently highlighted in <code>pg</code> (or, if nothing is highlighted, the style(s) that apply to the current insertion point are returned).</p>
<p>The style(s) are returned in <code>*style_bits</code> (which must not be a null pointer); the value of <code>*style_bits</code> will be a composite of one or more of the style bits as defined in <code>pgSetStyleBits</code> (above).</p>
<p>The <code>*consistent_bits</code> parameter will also get set to the style(s) that remains consistent throughout the selected text; if a style bit in <code>consistent_bits</code> is set to a &quot;1&quot;, that corresponding bit value in <code>*style_bits</code> is the same throughout the selected text.</p>
<p>For example, if <code>*style_bits</code> returns with all 0&#39;s, yet <code>*consistent_bits</code> is set to all 1&#39;s, the selection is purely &quot;plain text&quot; (no styles are set). However, if <code>*style_bits</code> returned all 0&#39;s but <code>*consistent_bits</code> was <em>not</em> all 1&#39;s, the text is not &quot;plain text,&quot; rather the bits that are 0 in <code>*consistent_bits</code> reveal that style is not the same throughout the whole selection.</p>
<p>NOTE: The <code>consistent_styles</code> parameter must not be a null pointer.</p>
<h2 id='86-settinggetting-text-colour'>8.6 Setting/Getting Text Colour</h2>
<h4 id='windows-prototypes'>Windows prototypes</h4>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
void pgSetTextColor (pg_ref pg, COLORREF color, select_pair_ptr selection_range, pg_boolean redraw);
void pgSetBKColor (pg_ref pg, COLORREF color, select_pair_ptr selection_range, pg_boolean redraw);
</code></pre>
<h4 id='macintosh-prototypes'>Macintosh prototypes</h4>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
void pgSetTextColor (pg_ref pg, RGBColor *color, select_pair_ptr selection_range, pg_boolean redraw);
void pgSetTextBKColor (pg_ref pg, RGBColor *color, select_pair_ptr selection_range, pg_boolean redraw);
</code></pre>
<p><code>pgSetTextColor</code> changes the foreground colour of text in <code>pg</code> to the specified color; <code>pgSetTextBKColor</code> changes the background colour of text in <code>pg</code> to the specified color.</p>
<p>If <code>selection_range</code> is a null pointer, the text in <code>pg</code> currently highlighted is changed (or, if nothing is highlighted, the color is applied to the next key insertion).</p>
<p>If <code>selection_range</code> is not null, it must point to a <code>select_pair</code> record defining the beginning and ending text offsets to apply the color. (See also section 8.2, <a href='#82-selection-range'>Selection Range</a>).</p>
<p>If <code>redraw</code> is <code>TRUE</code> and a selected range was affected, the changed text is redrawn.</p>
<h5 id='note-21'>NOTE</h5>
<p>Only the text colour is affected in the specified text, i.e. the text will retain its current font family, point size and its other style attributes.</p>
<h4 id='windows-prototypes-2'>Windows prototypes</h4>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
pg_boolean pgGetTextColor (pg_ref pg, COLORREF PG_FAR *color); 
pg_boolean pgGetTextBKColor (pg_ref pg, COLORREF PG_FAR *color);
</code></pre>
<h4 id='macintosh-prototypes-2'>Macintosh prototypes</h4>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
pg_boolean pgGetTextColor (pg_ref pg, RGBColor *color);
pg_boolean pgGetTextBKColor (pg_ref pg, RGBColor *color);
</code></pre>
<p><code>pgGetTextColor</code> returns the foreground colour that is applied to the text currently highlighted in <code>pg</code> (or, if nothing is highlighted, the colour that applies to the current insertion point is returned); <code>pgGetTextBKColor</code> returns the text background colour.</p>
<p>The colour is returned in <code>*color</code> (which must not be a null pointer). However, if the text is highlighted and the text range has more than one size, the function returns <code>FALSE</code> and <code>*color</code> is not certain.</p>
<h2 id='87-style-examples'>8.7 Style Examples</h2>
<h3 id='setting-styles-windows'>Setting styles (Windows)</h3>
<pre><code class='language-c' lang='c'>/* The following code shows an example of setting a new point size, a new font and new style(s) taken from a &quot;LOGFONT&quot; structure. All new text characteristics are applied to the text currently highlighted (or they are applied to the NEXT pgInsert if no text is highlighted). Carefully note that we do not &quot;redraw&quot; the text until the last function is called, otherwise we would keep &quot;flashing&quot; the refresh of the text. */ 

#include &quot;Paige. h&quot;
#include &quot;pgUtils.h&quot;
#include &quot;pgHLevel.h&quot;

LOGFONT log_font;	// got this from &quot;ChooseFont&quot; or whatever
long style_bits, set_bits; 	// used for pgSetStyleBits

// Set font (by name)
pg SetFontByName(pg_log_font.lfFaceName, NULL, FALSE);

// Set point size
pg SetPointSize(pg, pgAbsoluteValue((long)log_font.lfHeight, NULL, FALSE);

// Set style attributes:
style_bits = set_bits = 0;
if (log_font.lfWeight == FW_BOLD)
	style_bits |= X_BOLD_BIT;
if (log_font.lfItalic)
	style_bits |= X_ITALIC_BIT;
if (log_font.lfUnderline)
	style_bits |= X_UNDERLINE_BIT;
if (log_font.lfStrikeOut)
	style_bits |= X_STRIKEOUT_BIT;
	
// Before setting the styles, check if we actually have &quot;plain text&quot;:
if (style_bits == X_PLAIN_TEXT)
	set_bits = X_ALL_STYLES;
else
	set_bits = style_bits;
	
// Note, this time we pass &quot;TRUE&quot; for redraw because we are done:
pgSetStyleBits(pg, style_bits, set_bits, NULL, TRUE);
</code></pre>
<h3 id='handling-font-menu-macintosh'>Handling font menu (Macintosh)</h3>
<pre><code class='language-c' lang='c'>#include &quot;pgHLevel.h&quot;
/* The following code assumes a &quot;Font&quot; menu (which lists all available fonts), a &quot;Style&quot; menu (containing Plain, Bold, etc.) and a &quot;Point&quot; menu (with 9, 12, 18 and 24 point values). Each example assumes its respective menu has been selected by user and &quot;menu_item&quot; is the item selected. */

/* For font menu: */ 
Str255 font;
GetItem(FontMenu, menu_item, font); 
pgSetFontByName(pg, font, NULL, TRUE);

/* For style menu: */
long style_bits, set_bits;

switch (menu_item) 
	{
	case PLAIN_ITEM:
		style_bits = X_PLAIN_TEXT;
		set_bits = X_ALL_STYLES;
		break;
	case BOLD_ITEM:
		style_bits = set_bits = X_BOLD_BIT;
		break;
	case ITALIC_ITEM:
		style_bits = set_bits = X_ITALIC_BIT;
		break;
	case UNDERLINE_ITEM:
		style_bits = set_bits = X_UNDERLINE_BIT; 
		break;
	case OUTLINE_ITEM:
		style_bits = set_bits = X_OUTLINE_BIT;
		break;
	case SHADOW_ITEM:
		style_bits = set_bits = X_SHADOW_BIT;
		break;
	}
	
pgSetStyleBits(pg, style_bits, set_bits, NULL, TRUE);
	
// Setting point size
	
short pointsize;
switch (menu_item) 
	{
	case PT9_ITEM:
		pointsize = 9;
		break;
	case PT12_ITEM:
		pointsize = 12;
		break;
	case PT18_ITEM:
		pointsize = 18;
		break;
	case PT24_ITEM:
		pointsize = 24;
		break;
	}
</code></pre>
<h2 id='88-changing-pgref-style-defaults'>8.8 Changing pg_ref style defaults</h2>
<p>Changing the defaults of the <code>pg_ref</code> is done just after <code>pgInit</code>. Changing the defaults is shown in section 3.3, <a href='#33-a-different-default-font-style-paragraph'>A Different Default Font, Style, Paragraph</a>.</p>
<h2 id='89-changing-paragraph-formats'>8.9 Changing Paragraph Formats</h2>
<p>Changing the paragraph format applied to text range(s) requires a separate function call since paragraph formats are maintained separate from text styles and fonts.</p>
<p>To set one or more paragraphs to a different format, call the following:</p>
<pre><code class='language-c' lang='c'>(void) pgSetParInfo (pg_ref pg, select_pair_ptr selection, par_info_ptr info, par_info_ptr mask, short draw_mode);
</code></pre>
<p>This function is almost identical to <code>pgSetStyleInfo</code> or <code>pgSetFontInfo</code> except a <code>par_info</code> record is used for <code>info</code> and <code>mask</code>.</p>
<p>The other difference is that <code>pgSetParInfo</code> will always apply to at least one paragraph: even if the selection &quot;range&quot; is a single insertion point, the whole paragraph that contains the insertion point is affected.</p>
<p>The <code>selection</code> and <code>draw_mode</code> parameters are functionally identical to the same parameters in <code>pgSetStyleInfo</code> (see &quot;Changing Styles&quot;<!-- on page 30-7--> and &quot;Draw Modes&quot;<!-- on page 2-30-->), except whole paragraphs are changed (even if you specify text offsets that do not fall on paragraph boundaries). (For more information, <em>vide</em> section 8.2, <a href='#82-selection-range'>Selection Range</a>, and chapter 10, <a href='#10-all-about-selection'>All About Selection</a>).</p>
<p>For detailed information on <code>par_info</code> records—and what fields you should set up—see &quot;par_info&quot;<!-- on page 30-33-->.</p>
<h5 id='note-22'>NOTE</h5>
<p>If you want to set or change tabs, it is more efficient (and less code) to use the functions in chapter 9, <a href='#9-tabs-and-indents'>Tabs and Indents</a>.</p>
<pre><code>(long) pgGetParInfo (pg_ref pg, select_pair_ptr selection, pg_boolean set_any_match, par_info_ptrinfo, par_info_ptr mask);
</code></pre>
<p>This function returns paragraph information for a specific range of text.</p>
<p>If <code>selection</code> is a null pointer, the information that is returned applies to the current selection range in <code>pg</code> (or the current insertion point); if selection is non-null, pointing to <code>select_pair</code> record, information is returned that applies to that selection range (for information about <code>select_pair</code> pointer under <code>pgGetStyleInfo</code>, see section 5.1, <a href='#51-copying-and-deleting'>Copying and Deleting</a>).</p>
<p>Both <code>info</code> and <code>mask</code> must both point to <code>par_info</code> records; neither can be a null pointer. When the function returns, both <code>info</code> and <code>mask</code> will be filled with information you can examine to determine what style(s), paragraph format(s), or font(s) exist throughout the selected text, and/or which do not.</p>
<p>If <code>set_any_mask</code> was <code>FALSE</code>, all the fields in <code>mask</code> that are set to nonzero indicate that the corresponding field value in <code>info</code> is the same throughout the selected text; all the fields in <code>mask</code> that are set to zero indicate that the corresponding field value in <code>info</code> is not the same throughout the selected text.</p>
<p>For example, suppose after calling <code>pgGetParInfo</code>, <code>mask.spacing</code> has a nonzero value. That means that whatever value has been set in <code>info.spacing</code> is the same for every paragraph in the selected text. Hence, if <code>info.spacing</code> is 12, then every character is spaced the same.</p>
<p>On the other hand, suppose after calling <code>pgGetParInfo</code>, <code>mask.spacing</code> is set to zero. That means that some of the characters in the selected text match the spacing in <code>info</code> and some do not. In this case, whatever value happens to be in <code>info.spacing</code> is not certain.</p>
<p>Essentially, any non-zero value in <code>mask</code> is saying, &quot;Whatever is in <code>info</code> for this field is applied to every character in the text,&quot; and any zero in <code>mask</code> is saying, &quot;Whatever is in <code>info</code> for this field does not matter because it is not the same for every character in the text.&quot;</p>
<p>You want to pass <code>FALSE</code> for <code>set_any_mask</code> to find out what paragraph formats apply to the entire selection (or not).</p>
<p>TABLE #3: POSSIBLE RESULTS WHEN <code>SET_ANY_MASK</code> IS SET TO <code>FALSE</code></p>
<figure class='table-figure'><table>
<thead>
<tr><th style='text-align:center;' >info</th><th style='text-align:center;' >mask</th><th style='text-align:center;' >results</th></tr></thead>
<tbody><tr><td style='text-align:center;' >12</td><td style='text-align:center;' >-1</td><td style='text-align:center;' >All paragraphs have spacing of 12</td></tr><tr><td style='text-align:center;' >12</td><td style='text-align:center;' >0</td><td style='text-align:center;' >Some paragraphs have spacing of 12</td></tr></tbody>
</table></figure>
<p>Setting <code>set_any_match</code> to TRUE is used to determine if only a part of the text matches a given paragraph format. This is described in &quot;Obtaining Current Text Format(s)&quot;<!-- on page 30-15-->. The <code>par_info</code> structure is described in &quot;par_info&quot;<!-- on page 30-33-->.</p>
<h1 id='9-tabs-and-indents'>9 TABS AND INDENTS</h1>
<h2 id='91-tab-support'>9.1 Tab Support</h2>
<p>One of the elements of a paragraph formats is a list of tab stops. Although you could set tabs (or change tabs) using <code>pgSetParInfo</code>, some additional functions have been provided exclusively for tabs to help save on coding:</p>
<pre><code>void pgSetTab (pg_ref pg, select_pair_ptr selection, tab_stop_ptr tab_ptr, short draw_mode);
</code></pre>
<p>This function sets a new tab that applies to the specified selection.</p>
<p>The <code>selection</code> parameter is used in the same way as other functions use a <code>select_pair</code> parameter: if it is a null pointer, the current selection in <code>pg</code> is used, otherwise the <code>selection</code> is taken from the parameter (for information about <code>pgSetParInfo</code> regarding <code>select_pair</code> records, see section 8.2, <a href='#82-selection-range'>Selection Range</a>).</p>
<p>The <code>draw_mode</code> is also identical to all other functions that accept a <code>draw_mode</code> parameter. <code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code class='language-c' lang='c'>draw_none, 		// Do not draw at all
best_way,			// Use most efficient method(s)
direct_copy,	// Directly to screen, overwrite
direct_or,		// Directly to screen, &quot;OR&quot;  
direct_xor,		// Directly to screen, &quot;XOR&quot;  
bits_copy,		// Copy offscreen
bits_or, 			// Copy offscreen, &quot;OR&quot; mode
bits_xor			// Copy offscreen, &quot;XOR&quot; mode
</code></pre>
<p>The <code>tab_ptr</code> parameter is a pointer to the following record (<code>tab</code> must not be a null pointer):</p>
<pre><code class='language-c' lang='c'>typedef struct 
{
	long tab_type;	// Type of tab
	long position;	// Tab position
	long leader;		// Tab leader (or null)
	long ref_con;		// Can be used for anything
}
</code></pre>
<p>The <code>tab_type</code> field can be one of the following:</p>
<pre><code class='language-c' lang='c'>typedef enum
{
	no_tab,			// none (used to delete)
	left_tab,		// left tab
	center_tab,	// centre tab
	right_tab,	// right tab
	decimal_tab	// tab on decimal point
}
</code></pre>
<p>The position field in a <code>tab_stop</code> defines the tab&#39;s position, in pixels. However, a tab&#39;s pixel position is relative to either the left edge of <code>pg</code>&#39;s <code>page_area</code>, or to the left edge of the window (see section 9.3, <a href='#93-tab-base'>Tab Base</a>).</p>
<p>If <code>leader</code> is nonzero, the tab is drawn with that value as a &quot;leader&quot; character. HERMES Paige assumes that the character has simply been coerced to a numeric value, which will therefore imply whether the leader character is a single ASCII byte (<code>leader</code> &lt; 256), or a double byte (<code>leader</code> &gt; 256).</p>
<p>For example, if the leader is a single ASCII byte for a &quot;.&quot; (hexadecimal 2E), the value placed in leader should be <code>0x0000002E</code>. If leader is a double-byte character, such as the Kanji with hexadecimal value 802E, then the leader value should be set to <code>0x0000802E</code>, etc.</p>
<pre><code>my_tab.leader = &#39;-&#39;;
</code></pre>
<p>A leader is the character placed before a tab, like this</p>
<pre><code>01234  5  6789
ABC -[TAB]DEFG
</code></pre>
<p>The <code>ref_con</code> field can be used for anything.</p>
<h3 id='deleting-a-tab'>Deleting a Tab</h3>
<p>You can delete a tab by calling <code>pgSetTab</code> with a tab record of type <code>no_tab</code> where the position field set to the exact position of the existing tab you wish to delete.</p>
<h3 id='changing-a-tab'>Changing a Tab</h3>
<p>If you want to change a tab&#39;s position (location relative to the tab base), you must delete the tab and add a new one (see previous subsection, <a href='#deleting-a-tab'>Deleting a Tab</a>).</p>
<p>If you want to change anything else (such as the tab type or leader), simply call <code>pgSetTab</code> with a tab record whose position is identical to the one you wish to change.</p>
<h4 id='notes-12'>NOTES:</h4>
<ol start='' >
<li>The maximum number of tab settings per paragraph is 32.</li>
<li>Tab settings affect whole paragraphs. They are in fact part of the paragraph formatting.</li>

</ol>
<h3 id='tech-note-tabs-setting-different-for-different-lines'>TECH NOTE: Tabs setting different for different lines</h3>
<blockquote><p>I am displaying information in Paige with each block of info occupying 2 lines of text. I would like to have tab stops set differently for the first and second line.</p>
</blockquote>
<p>It depends on what you mean by &quot;line.&quot;</p>
<p>If each line ends with a CR (carriage return), HERMES Paige considers each one a &quot;paragraph&quot; and thus you can simply change the paragraph formatting to be different for each line.</p>
<p>However, if both of your lines are one continuous string of text that just word-wraps into two lines, it is virtually impossible to apply two different sets of tab stops.</p>
<p>This is because tabs are, by definition, a paragraph format and a paragraph is simply text that ends with a CR, no matter how many lines it might have.</p>
<p>I will assume you have CR-terminated lines (&quot;paragraphs&quot;). To apply different tab stops to the second line, you need to simply use the tab setting function(s) as given in the manual. of course you need to know at least one of the text positions in the line you need to change (for example, you need to know that line number 2 starts at the 60th character, or the $72 \mathrm{nd}$ character, etc.); you also need to insert the text line first before you can apply the tab-stop changes (unlike text styles, paragraph styles require that you have a &quot;paragraph&quot; for which to apply the style change).</p>
<h2 id='92-changing--getting-multiple-tabs'>9.2 Changing / Getting Multiple Tabs</h2>
<h3 id='get-tab-list'>Get Tab List</h3>
<p>This provides a way to look at all the tabs within a section of text:</p>
<pre><code>(void) pgGetTabList (pg_ref pg, select_pair_ptr selection, tab_ref tabs, memory_ref tab_mask, long PG_FAR *screen_offset);
</code></pre>
<p>The <code>selection</code> parameter operates in the same way it does for <code>pgGetParInfo</code> (see &quot;Obtaining Current Text Format(s)&quot;<!-- on page 30-15--> for information about <code>pgGetStyleInfo</code> and <code>pgGetParInfo</code>).</p>
<p>The <code>tabs</code> and <code>tab_mask</code> parameters for <code>pgGetTabList</code> are memory allocations which you must create before calling this function. When the function returns, <code>tabs</code> will be set to contain an array of <code>tab_stop</code> records that apply to the selection range and <code>tab_mask</code> will be set to contain an array of <code>long</code>s containing non-zeros for every tab that is consistent (the same) throughout the selection.</p>
<p>For example, supposing that the specified selection contained 3 tabs, when <code>pgGetTabList</code> returns, <code>tabs</code> would contain all three <code>tab_stop</code> records and <code>tab_mask</code> would contain 3 long words (each corresponding to the <code>tab</code> in <code>tabs</code>). If the corresponding long word in <code>tab_mask</code> is zero, that tab is inconsistent (not the same) and/or does not exist throughout the entire selection range.</p>
<p>The <code>tab_mask</code>, however, can be a <code>MEM_NULL</code> if you don&#39;t require a &quot;consistency report.&quot; The <code>tabs</code> parameter, however, must be a valid <code>memory_ref</code>.</p>
<p>The <code>screen_offset</code> parameter should either be a pointer to a <code>long</code> or a null pointer. When the function returns, the variable pointed to by <code>screen_offset</code> will get set to the tab base value (the position, in pixels, against which tabs are measured—see section 9.3, <a href='#93-tab-base'>Tab Base</a>). If <code>screen_offset</code> is a null pointer, it is ignored.</p>
<h5 id='notes-13'>NOTES</h5>
<ol start='' >
<li>To learn how to create the allocations passed to tabs and <code>tab_mask</code>, and how to access their contents, see chapter 25, <a href='#25-the-allocation-manager'>The Allocation Manager</a>.</li>
<li>Calling this function forces the <code>tabs</code> memory allocation to contain <code>sizeof(tab_stop)</code> record sizes. Hence, the result of <code>GetMemorySize(tabs)</code> will return the number of <code>tab_stop</code> records. Similarly, the <code>tab_mask</code> is forced to a record size of <code>sizeof(long)</code>, so <code>GetMemorySize(tab_mask)</code> will return the same number.</li>
<li>If no tabs exist at all, <code>pgGetTabList</code> will set your tabs and <code>tab_mask</code> allocation to a size of zero.</li>

</ol>
<h3 id='set-tab-list'>Set Tab List</h3>
<pre><code>(void) pgSetTabList (pg_ref pg, select_pair_ptr selection, tab_ref tabs, memory_ref tab_mask, short draw_mode);
</code></pre>
<p>The above function provides a way to apply multiple tabs all at once to a specified <code>selection</code>.</p>
<p>The <code>selection</code> parameter operates the same as all functions that accept a <code>select_pair</code>.</p>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none, 		// Do not draw at all
best_way,			// Use most efficient method(s)
direct_copy,	// Directly to screen, overwrite
direct_or,		// Directly to screen, &quot;OR&quot;  
direct_xor,		// Directly to screen, &quot;XOR&quot;  
bits_copy,		// Copy offscreen
bits_or, 			// Copy offscreen, &quot;OR&quot; mode
bits_xor			// Copy offscreen, &quot;XOR&quot; mode
</code></pre>
<p>The <code>tabs</code> and <code>tab_mask</code> parameters must be memory allocations that you create. The <code>tabs</code> allocation must contain one or more tab stop records; the <code>tab_mask</code> allocation must have an identical number of long words, each <code>long</code> corresponding to the tab element in <code>tabs</code>. For every entry in <code>tab_mask</code> that is nonzero, that corresponding tab is applied to the selection range; for every <code>tab_mask</code> entry that is zero, that tab is ignored.</p>
<p>For example, if you set up the tabs allocation to contain 3 <code>tab_stop</code> records, and the <code>tab_mask</code> had three <code>long</code>s of 1, 0, 1, then the first and third tab would be applied to the selection range; the second tab would not be applied.</p>
<p>However, <code>tab_mask</code> can be <code>MEM_NULL</code> if you simply want to set all tabs unconditionally.</p>
<h5 id='notes-14'>NOTES </h5>
<ol start='' >
<li>To learn how to create the allocations passed to <code>tabs</code> and <code>tab_mask</code>, and how to access their contents, see chapter 25, <a href='#25-the-allocation-manager'>The Allocation Manager</a>.</li>
<li>The maximum number of <code>tab_stop</code>s applied to one paragraph is 32.</li>
<li>When setting multiple tabs, any current tab settings are maintained — they do not get &quot;deleted&quot;. However, a <code>tab_stop</code> does get <em>replaced</em> if a new tab contains the same exact position.</li>

</ol>
<h2 id='93-tab-base'>9.3 Tab Base</h2>
<p>Tab positions (the pixel positions specified in the position field of a tab_stop record) are considered relative to some other position and not absolute. HERMES Paige supports three &quot;tab base&quot; values defining the relative position for which to place tabs. If the base value is positive or zero, HERMES Paige uses that value as the tab base. If the base value is negative, the tab base implies one of the following:</p>
<pre><code>#define TAB_BOUNDS_RELATIVE -1	// relative to page_area bounds
#define TAB_WRAP_RELATIVE -2	// relative to current line wrap edge
</code></pre>
<p>The difference between <code>TAB_BOUNDS_RELATIVE</code> and <code>TAB_WRAP_RELATIVE</code> depends on what kind of wrap shape (<code>page_area</code>) that exists in the HERMES Paige object. <code>TAB_BOUNDS_RELATIVE</code> means tabs are always relative to the entire bounding area (enclosing rectangle) of the <code>page_area</code>, regardless of the shape, while <code>TAB_WRAP_RELATIVE</code> measures tabs against the leftmost edge of the specific portion of the text line for which the tab is intended.</p>
<h3 id='settingchanging-tab-base'>Setting/Changing Tab Base</h3>
<pre><code>(void) pgSetTabBase (pg_ref pg, long tab_base);
(long) pgGetTabBase (pg_ref pg);
</code></pre>
<p>To set (or change) the tab base, call <code>pgSetTabBase</code> and provide the base value in <code>tab_base</code>, which can be a positive number or zero (in which case, tabs are relative to that pixel position), or a negative number (either <code>TAB_BASE_RELATIVE</code> or <code>TAB_BOUNDS_RELATIVE</code>).</p>
<p>To get the current tab base, call <code>pgGetTabBase</code> and the base currently used by <code>pg</code> will be the function result.</p>
<p><strong>NOTE:</strong> The default tab base in a new <code>pg_ref</code> is zero (tabs are relative to pixel position 0).</p>
<p>The four illustrations to follow show examples of how tab positions are measured against the tab base value (the tab base value is stored in <code>pg_ref</code> and can be changed with the functions shown above).</p>
<p><a href='#fig4'>Figure 4</a> (&quot;TAB BASE = 0&quot;) shows a tab measurement with a tab base of zero, while <a href='#fig5'>Figure 5</a> (&quot;TAB BASE = 16&quot;) shows a tab base of 16, in which case all tabs are relative to 16 pixels from the left of the window. In both cases, the window&#39;s left origin is assumed to be at coördinates (0, 0).</p>
<p>Figures <a href='#fig6'>6</a> (&quot;TAB BASE = <code>TAB_BOUNDS_RELATIVE</code>&quot;) and <a href='#fig7'>7</a> (&quot;TAB BASE = <code>TAB_WRAP_RELATIVE</code>&quot;) both measure tabs against the left side of <code>page_area</code>, except that, where a line of text exists, <code>TAB_WRAP_RELATIVE</code> is measured against the edge of <code>page_area</code>. If <code>page_area</code> is <em>a single rectangle</em>, both of the latter two tab base modes are <em>identical</em>.</p>
<h5 id='figures-4----7'>Figures 4 – 7</h5>
<p>The following are some illustrations of different tab base values:</p>
<p><img src="figs/fig4.jpg" referrerpolicy="no-referrer">
<img src="figs/fig5.jpg" referrerpolicy="no-referrer">
<img src="figs/fig6.jpg" referrerpolicy="no-referrer">
<img src="figs/fig7.jpg" referrerpolicy="no-referrer"></p>
<h2 id='94-indentation-support'>9.4 Indentation Support</h2>
<h3 id='set-indents'>Set Indents</h3>
<p>One of the elements of a paragraph format is a set of paragraph indentations (left, right, and first-line indents). Although you could set these using <code>pgSetParInfo</code>, some additional functions have been provided exclusively for indents to help save on coding:</p>
<pre><code>void pgSetIndents (pg_ref pg, select_pair_ptr selection, pg_indents_ptr indents, pg_indents_ptr mask, short draw_mode);
</code></pre>
<p>The function above changes the indentations for the text range specified.</p>
<p>The <code>selection</code> parameter operates in the same way it does for <code>pgGetParInfo</code>. For information about selection ranges, see section 8.2, <a href='#82-selection-range'>Selection Range</a>, and for information about <code>pgSetStyleInfo</code> and <code>pgSetParInfo</code>, see &quot;Changing Styles&quot;<!-- on page 30-7--> ).</p>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>typedef enum
{
	draw_none,			// Do not draw at all
	best_way,			// Use most efficient method(s)
	direct_copy,		// Directly to screen, overwrite
	direct_or,			// Directly to screen, &quot;OR&quot;
	direct_xor,			// Directly to screen, &quot;XOR&quot;
	bits_copy,			// Copy offscreen
	bits_or,			// Copy offscreen in &quot;OR&quot; mode
	bits_xor,			// Copy offscreen in &quot;XOR&quot; mode
	bits_emulate_copy	// Copy &quot;fake&quot; offscreen
	bits_emulate_or	// &quot;Fake&quot; offscreen in &quot;OR&quot; mode
	bits_emulate_xor	// &quot;Fake&quot; offscreen in &quot;XOR&quot; mode
};
</code></pre>
<p>The indents and mask parameter must point to the following structure (neither pointer can be null):</p>
<pre><code>typedef struct
{
	long left_indent;	// Left margin (indent)
	long right_indent;	// Right margin (indent)
	long first_indent;	// First-line indent
}
pg_indents, PG_FAR *pg_indents_ptr;
</code></pre>
<p>The <code>mask</code> parameter should contain nonzero fields for every indent you wish to change in indents.</p>
<p><strong>NOTE:</strong> &quot;nonzero&quot; means that you should fill the field with -1 (so all bits are set to ones).</p>
<p>Indentations are pixel positions relative to a text line&#39;s maximum left and maximum right, as follows: the <code>left_indent</code> is the distance from the leftmost edge of a line (which will be the <code>page_area</code>&#39;s left edge for that line); the right indent is the distance from the rightmost edge (which will be the <code>page_area</code>&#39;s right edge). Note that this is a positive number, not a negative inset. The <code>first_line_indent</code> is relative to the <code>left_indent</code>. Note that <em>only</em> the <code>first_line_indent</code> should ever be negative (in which case the first line of the paragraph hangs to the left of the left indent).</p>
<p>When indents are changed, they apply to whole paragraphs.</p>
<h3 id='get-indents'>Get Indents</h3>
<p>To obtain the current indent settings of a selection range, call the following:</p>
<pre><code>(void) pgGetIndents (pg_ref pg, select_pair_ptr selection, pg_indents_ptr indents, pg_indents_ptr_mask, long PG_FAR *left_screen_offset, long PG_FAR *right_screen_offset);
</code></pre>
<p>The <code>selection</code> parameter operates in the same way it does for <code>pgGetParInfo</code> (see “Obtaining Current Text Format(s)&quot;<!-- on page 30-15--> for information about <code>pgGetStyleInfo</code> and <code>pgGetParInfo</code>).</p>
<p>The indents and mask parameters should point to a <code>pg_indents</code> record (described above); neither parameter can be a null pointer.</p>
<p><strong>FUNCTION RESULT:</strong> When this function returns, indents will be set to the indentation values found in the selection range, and mask will have every field that is consistent (the same) throughout the range to nonzero.</p>
<p>If <code>left_screen_offset</code> and <code>right_screen_offset</code> are non-null, <code>pgGetIndents</code> will set the variables to which they point to the relative left position and right position, respectively, against which the indents are measured. The usual reason you will need to have this information is to draw a &quot;ruler&quot; showing indents, in which case you will need to know the relative edges to draw each indentation. This is particularly important if your <code>page_area</code> is non-rectangular (because the relative edges can change from line to line).</p>
<h5 id='note-23'>NOTE</h5>
<p>The <code>left_screen_offset</code> and <code>right_screen_offset</code> values will include the scrolled position of the HERMES Paige object, if any (see chapter 11, <a href='#11-all-about-scrolling'>All About Scrolling</a>).</p>
<h1 id='10-all-about-selection'>10 All About Selection</h1>
<p>An HERMES Paige object&#39;s text can be selected either by the user or directly by your application.</p>
<h2 id='101-up-and-running-with-selections'>10.1 Up and Running with Selections</h2>
<p>Selection by the user is accomplished with <code>pgDragSelect</code>; this has already been covered in detail (see section 2.13 <a href='#2.13-blinking-carets-and-mouse-selections'>Blinking Carets and Mouse Selections</a> with regards to <code>pgDragSelect</code>).</p>
<p>Additional support functions are provided, however, to set selections directly and/or to obtain both simple selections (insertion points or a selection pair of offsets) as well as complex selections (discontinuous selections).</p>
<h2 id='102-simple-selections'>10.2 Simple Selections</h2>
<p>A <em>simple</em> selection is either a single insertion point or a pair of text offsets which implies a single range. This includes vertical selections that contain only two points (top-left and bottom-right text positions). To set a simple selection, call the following:</p>
<pre><code>(void) pgSetSelection (pg_ref pg, long begin_sel, long end_sel, short modifiers, pg_boolean show_hilite);
</code></pre>
<p>The selection range in <code>pg</code> will be set to <code>begin_sel</code> to <code>end_sel</code>, which are byte offsets; the lowest offset is zero and the highest offset is <code>pgTextSize(pg)</code>. If <code>begin_sel</code> is the same as <code>end_sel</code>, a single insertion is implied.</p>
<p>The <code>modifiers</code> parameter is identical to the modifiers passed to <code>pgDragSelect</code> (for a list of bits you can pass for <code>modifiers</code>, see section 2.15, <a href='#215-blinking-carets-and-mouse-selections'>Blinking Carets and Mouse Selections</a>). This parameter controls how the text is selected, i.e., extended selection, vertical selection, word selection, etc.</p>
<p>If <code>should_draw</code> is <code>TRUE</code>, a new highlight region is computed and drawn. If <code>should_draw</code> is <code>FALSE</code>, nothing on the screen changes (but <code>pg</code> will internally change its selection).</p>
<p><strong>NOTE:</strong> If you want to select all text, pass an arbitrary-but-huge number for <code>end_sel</code>. HERMES Paige will adjust large numbers to be equal to the current text size.</p>
<p>To obtain the current selection (assuming it is a simple selection), call the following:</p>
<pre><code>(void) pgGetSelection (pg_ref pg, long PG_FAR *begin_sel, long PG_FAR *end_sel);
</code></pre>
<p>The current selection range is returned in <code>*begin_sel</code> and <code>*end_sel</code>. Either parameter can be a null pointer if you don&#39;t want the result.</p>
<p>If the <code>selection</code> range is discontinuous, you will receive the first selection pair.</p>
<p><strong>NOTE:</strong> <code>pgSetSelection</code> will not affect the style of text. It merely highlights the text and gets the internal range within HERMES Paige so that other functions can operate thereon.</p>
<h2 id='103-discontinuous-selections'>10.3 Discontinuous Selections</h2>
<p>A discontinuous selection can be accomplished with <code>pgDragSelect</code> and setting the appropriate bit in the modifiers parameter (in which case, every new <code>verb</code> of <code>mouse_down</code> will start a new selection pair). You can also accomplish this from your app with multiple <code>pgSetSelection</code> calls and the appropriate bit set in modifiers.</p>
<p>To set a discontinuous selection from your app all at once, however, you can use the following:</p>
<pre><code>(void) pgSetSelectionList (pg_ref pg, memory_ref select_list, long extra_offset, pg_boolean show_hilight);
</code></pre>
<p>The <code>select_list</code> parameter must be a memory allocation containing one or more <code>select_pair</code> records (for information about <code>select_pair</code>, see section 8.2, <a href='#82-selection-range'>Selection Range</a>).</p>
<p>The <code>offset_extra</code> parameter is an amount to add to each selection pair within <code>select_list</code>; if you want to apply the <code>select_list</code> as-is, pass zero for <code>extra_offset</code>.</p>
<p>If <code>should_draw</code> is TRUE, the new selection is drawn.</p>
<p>For information about memory allocations, see chapter 25, <a href='#25-the-allocation-manager'>The Allocation Manager</a>.</p>
<p>To obtain the current discontinuous selection, call the following:</p>
<pre><code>(memory_ref) pgGetSelectionList (pg_ref pg, pg_boolean for_paragraph);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns a newly created memory allocation containing one or more <code>select_pair</code> records which represent the entire selection in <code>pg</code>.</p>
<p>If <code>for_paragraph</code> is TRUE, the selection pairs will be paragraph-aligned; otherwise, they will be character-aligned (if you want to know what paragraphs fall in the selection range(s), the distinction <em>must</em> be made).</p>
<p><strong>CAUTION:</strong> If there is no selection range, e.g. only a caret, and for_paragraph is FALSE, this function will return <code>MEM_NULL</code> (zero).</p>
<p>You will know how many <code>select_pair</code> records are contained in the function result by calling <code>GetMemorySize()</code> on the function result—see chapter 25, <a href='#25-the-allocation-manager'>The Allocation Manager</a>.</p>
<p><strong>NOTE:</strong> It is your responsibility to dispose the memory allocation returned from this function.</p>
<h2 id='104-additional-selection-support'>10.4 Additional Selection Support</h2>
<h3 id='extending-the-selection'>Extending the selection</h3>
<pre><code>(void) pgExtendSelection (pg_ref pg, long amount_ext, short modifiers, pg_boolean show_hilite);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> The above function extends the current selection by <code>amount_ext</code>; the new extension follows the attributes in <code>modifiers</code> if appropriate (for example, the selection could be extended by whole words or paragraphs).</p>
<p>Negative values in <code>amount_ext</code> extend to the left (extend the beginning selection backwards); positive numbers extend to the right (extend the ending selection forwards).</p>
<p>The <code>modifiers</code> can generally be a combination of:</p>
<pre><code>#define EXTEND_MOD_BIT		0x0001	// Extend the selection
#define WORD_MOD_BIT		0x0002 // Select whole words only
#define PAR_MOD_BIT			0x0004 // Select whole paragraphs only
#define LINE_MOD_BIT		0x0008	// Select whole lines only
#define DIS_MOD_BIT			0x0020	// Enable discontiguous selection
#define STYLE_MOD_BIT		0x0040 // Select whole style range
#define WORD_CTL_MOD_BIT	0x0080 // Select &quot;words&quot; delimited by control chars
#define NO_HALF_CHARS_BIT	0x0100 // Click does not go left/right on half-chars
</code></pre>
<p>These are explained in <a href='#modifiers'>Modifiers</a> under section 2.15. Vertical selection cannot be extended using the modifiers. Using that modifier in combination with the others will cause unpredictable results.</p>
<p>If <code>show_hilite</code> is <code>TRUE</code>, the new highlight is drawn; if <code>FALSE</code>, the appearance does not change.</p>
<p><strong>NOTE:</strong> If the current selection is discontinuous, only the last (ending) selection pair is affected by this function.</p>
<h3 id='handling-mouse--key-combinations-for-selection-mac'>Handling mouse &amp; key combinations for selection (Mac)</h3>
<p><strong>NOTE:</strong> This code does not handle shift-clicks and option-clicks in the same way as the demo. The point of this code is that you can change the key combinations for your own uses. Consult the demo for other ways of handling this.</p>
<pre><code>#include &quot;Paige.h&quot;

#define LEFT_ARROW		0x1C
#define RIGHT_ARROW		0x1D
#define UP_ARROW		0x1E
#define DOWN_ARROW		0x1F
#define BACKSPACE_CHAR	0x08
#define RETURN_CHAR		0x0D
#define ENTER_CHAR		0x03
#define TAB_CHAR		0x09
#define LF_CHAR			0x0A
#define HOME_KEY		0x01
#define END_KEY			0x04

static int scroll_to_cursor(pg_ref my_pg);
static int key_doc_proc(EventRecord *event);
static int is_an_arrow(char key);
extern pg_globals paige_rsrv;
extern undo_ref last_undol

// This is the keydown proc

static int key_doc_proc(pg_ref my_pg, EventRecord *event)
{
	char the_key;
	short modifiers;
	pg_ref my_pg;
	
	the_key = event -&gt; message &amp; charCodeMask;
}
</code></pre>
<p>Next we parse the event record. We have the record before going into <code>pgInsert</code> and can change the keys around or do other things before we send the key into the <code>pg_ref</code>. In this case, we intercept the <code>HOME_KEY</code> and the <code>END_KEY</code> and scroll the <code>pg_ref</code> to the top and bottom:</p>
<pre><code>if (the_key == HOME_KEY)
{
	pgScroll(my_pg, scroll_home, scroll_home, best_way);
	UpdateScrollBarValues(my_pg);
}
else
if (the_key == END_KEY)
{
	pgScroll(my_pg, scroll_none, scroll_end, best_way);
	UpdateScrollBarValues(my_pg);
}
else
{
	ObscureCursor();
}
</code></pre>
<p>Then we check to see if they are characters that HERMES Paige would normally handle and if so, we insert them into the <code>pg_ref</code>. When <code>pgInsert</code> contains the <code>key_insert_mode</code> or <code>key_buffer_mode</code> in the <code>insert_mode</code> parameter, it responds as we would expect when arrow keys are entered, i.e., by moving the insertion point, by handling backspace, by deleting previous characters, etc.</p>
<p>We don&#39;t need to use <code>pgExtendSelection</code>.</p>
<p>HERMES Paige automatically handles extending the selection by holding down the shift key while using arrow keys if the <code>EXTEND_MOD_BIT</code> is set during <code>pgInsert</code>. <code>key_buffer_mode</code> will keep calling the events as long as HERMES Paige is receiving keystrokes, making keyboard text insertion very fast. HERMES Paige won&#39;t cycle through the event loop until the keystrokes are paused.</p>
<pre><code>// Here are the modifiers changing the selection
modifiers = 0;
if (event -&gt; modifiers &amp; shiftKey)
	modifiers |= EXTEND_MOD_BIT;
if (event -&gt; modifiers &amp; optionKey)
	modifiers |= WORD_MOD_BIT;
	
if (the_key == ENTER_CHAR)
{
	event -&gt; message = LF_CHAR;
	the_key = LF_CHAR;
}

if (the_key &gt;= &#39; &#39; || the_key &lt; 0 || the_key == TAB_CHAR || the_key == RETURN_CHAR || the_key == LF_CHAR || the_key == BACKSPACE_CHAR || is_an_arrow(the_key))
{
	short verb_for_undo;
	DisposeUndo(my_pg, last_undo);
	if (the_char == paige_rsrv.bs_char)
		verb_for_undo = undo_backspace;
	else
		verb_for_undo = undo_typing;
	last_undo = pgPrepareUndo(my_pg, verb_for_undo, (void PG_FAR*) last_undo);
		
	pgInsert(my_pg, (pg_char_ptr &amp;the_key, sizeof(pg_char), CURRENT_POSITION, key_insert_mode, 0, best_way);
	
	if (the_key == BACKSPACE_CHAR)
		pgAdjustScrollMax(my_pg, best_way);

	scroll_to_cursor(my_pg);
}

return FALSE;	// to be returned
</code></pre>
<h3 id='number-of-selections'>Number of selections</h3>
<pre><code>(pg_short_t) pgNumSelections (pg_ref pg);
</code></pre>
<p>This returns the number of selection pairs in <code>pg</code>. A result of zero implies a single insertion point; a result of one implies a simple selection, and likewise for higher numbers.</p>
<h3 id='caret--cursor'>Caret &amp; Cursor</h3>
<pre><code>(pg_boolean) pgCaretPosition (pg_ref pg, long offset, rectangle_ptr caret_rect);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This returns a rectangle in <code>caret_rect</code> representing the &quot;caret&quot; corresponding to <code>offset</code>. If <code>offset</code> equals <code>CURRENT_POSITION</code> (value of 1), the current insertion point is used. If the current selection in <code>pg</code> is in fact a single insertion, the function returns <code>TRUE</code>; if it is not, <code>caret_rect</code> gets set to the top-left edge of the selection and the function returns <code>FALSE</code>.</p>
<p><strong>NOTE:</strong> If you specify some other position besides <code>CURRENT_POSITION</code>, this implies a single insertion point; thus, the function will always return <code>TRUE</code>.</p>
<pre><code>(void) pgSetCursorState (pg_ref pg, short cursor_state); (short) pgGetCursorState (pg_ref pg);
</code></pre>
<p>These two functions let you set the cursor (caret) to a specified state or obtain what state the caret is in.</p>
<pre><code>typedef enum
{
	dont_draw_cursor,	// Do nothing
	toggle_cursor,		// Toggle cursor based on timer
	show_cursor,		// Show cursor
	hide_cursor,		// Hide cursor
	deactivate_cursor,	// Cursor is no longer active
	update_cursor,		// Redraw cursor per current state
	restore_cursor,		// Turn cursor back on (chiefly Windows usage)
}
</code></pre>
<p><strong>NOTE:</strong> Except for very unusual applications, you should generally only use this function with <code>force_cursor_off</code> and <code>force_cursor_on</code>.</p>
<p>To obtain the current cursor state, call <code>pgGetCursorState</code>, which will return either TRUE (cursor is currently ON) or FALSE (cursor is currently OFF).</p>
<p>See also section 2.17, <a href='#217-activatedeäctivate'>Activate/Deäctivate</a>.</p>
<p><strong>NOTE:</strong> <em>The function result (<code>TRUE</code> or <code>FALSE</code>) of <code>pgGetCursorState</code> has differing usages in HERMES Paige for Windows and for Macintosh.</em> For <strong>Windows</strong>, the result implies whether or not the System caret is actively blinking within the <code>pg_ref</code>. For <strong>Macintosh</strong>, the result implies whether or not the caret is visible at that instant while it is toggling during <code>pgIdle()</code>. </p>
<pre><code>void pgSetCaretPosition (pg_ref pg, pg_short_t position_verb, pg_boolean show_caret);
</code></pre>
<p>This function should be used to change the location of the caret (insert position); for example, <code>pgSetCaretPosition</code> is useful for handling arrow keys.</p>
<p>The position_verb indicates the action to be taken. The low byte of this parameter should be one of the following values:</p>
<pre><code>enum
{
	home_caret,
	doc_bottom_caret,
	begin_line_caret,
	end_line_caret,
	next_word_caret,
	previous_word_caret
}
</code></pre>
<p>The high byte of <code>position_verb</code> can modify the meaning of the values shown above; the high byte should either be equal to zero or to <code>EXTEND_CARET_FLAG</code>.</p>
<p>The following is a description for each value in <code>position_verb</code>:</p>
<p><code>home_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the beginning of the document to the current position; if <code>EXTEND_CARET_FLAG</code> is clear, the caret moves to the beginning of the document.</p>
<p><code>doc_bottom_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the end of the document; if <code>EXTEND_CARET_FLAG</code> is clear the caret advances to the end of the document.</p>
<p><code>begin_line_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the beginning of the current line; if <code>EXTEND_CARET_FLAG</code> is clear the caret moves to the beginning of the line.</p>
<p><code>end_line_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the end of the current line; if <code>EXTEND_CARET_FLAG</code> is clear the caret moves to the end of the line.</p>
<p><code>next_word_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the beginning of the next word; if <code>EXTEND_CARET_FLAG</code> is clear the caret moves to the beginning of the next word.</p>
<p><code>previous_word_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the beginning of the previous word; if <code>EXTEND_CARET_FLAG</code> is clear the caret moves to the beginning of the previous word.</p>
<p>If <code>show_caret</code> is TRUE then the caret is redrawn in its new location; otherwise, the caret does not visibly change.</p>
<h2 id='105-selection-shape'>10.5 Selection shape</h2>
<p>It is possible to create a selection by specifying a shape. This next function returns a list of <code>select_pairs</code> when given a shape.</p>
<pre><code>(void) pgShapeToSelections (pg_ref pg, shape_ref the_shape, memory_ref selections);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function will place a list of selection pairs in <code>selections</code> that contain all the text that intersects <code>the_shape</code>. What gets put into <code>selections</code> is an array of <code>select_pair</code> records, similar to what is returned from <code>pgGetSelectionList</code>.</p>
<p>The <code>memory_ref</code> passed to selections must be a valid memory allocation (which you must create).</p>
<p>It is also possible to determine the selection shape.</p>
<pre><code>(void) pgSelectToShape (pg_ref pg, memory_ref select_shape, pg_boolean show_hilite);
</code></pre>
<p>This function sets the selection range(s) in <code>pg</code> to all characters that intersect the specified shape.</p>
<p>For example, if the <code>select_shape</code> was one large rectangle expanding across the entire document, then every character would be selected; if the shape were smaller than the document, then only the characters that fit within that shape—whether wholly or partially—would be selected.</p>
<p>If <code>show_hilite</code> is TRUE, the new selection region is drawn.</p>
<p>For information about shapes and individual characters and insertion point, see &quot;Text and Selection Positions&quot;<!-- on page 24-23-->. For information about highlighting see section 2.17, <a href='#217-activatedeäctivate'>Activate/Deäctivate</a>.</p>
<h3 id='activatedeactivate-with-shape-of-selection-still-showing'>Activate/Deactivate with shape of selection still showing</h3>
<h4 id='macintosh-3'>Macintosh</h4>
<p>This function can be used to draw the selection area around text when it is deactivated.</p>
<pre><code>void Do_Activate(Boolean Do_An_Activate)
{
	pg_ref my_pg;
	
	if (!(my_pg = Get_pgref_from_window(WPtr_Untitled1))) return;
	
	if(Do_An_Activate	// Handle the activate
	{
						// Update the scrollbar values
						// -----------------------------
						// Turn on the selection hilites
		pgSetHiliteStates(my_pg, activate_verb, no_change_verb, TRUE); 	
	}
	else				// Handle the deactivate
	{
						// Turn off the scroll bars here
						// -----------------------------
						// Turn off the selection hilites
		pgSetHiliteStates(my_pg, deactivate_verb, no_change_verb, TRUE);
		outline_hilite(my_pg);
		/* do this if you want to draw an outline around the selected text if the window is deactivated, as in MPW or the HERMES Paige demo */
	}					// End IF
}

/* If you want the feature of drawing the line around the selected text when the window is deactivated, you can use this snippet from the HERMES Paige demo */

#include &quot;pgTraps.h&quot; 	// This draws xor-hilight outline

static void outline_hilite(pg_ref the_pg)
{
	shape_ref outline_shape;
	outline_shape = pgRectToShape(&amp;paige_rsrv, NULL);
	if (pgGetHiliteRgn(the_pg, NULL, NULL, outline_shape))
	{
		pg_scale_factor scale_factor;
		RgnHandle rgn;
		rectangle vis_r;
		Rect clip;
		PushPort(WPtr_Untitled1);
		PushClip();
		
		pgAreaBounds(the_pg, NULL, &amp;vis_r);
		RectangleToRect(&amp;vis_r, NULL, &amp;clip);
		ClipRect(&amp;clip);
		
		rgn = NewRgn();
		pgGetScaling(the_pg, &amp;scale_factor);
		ShapeToRgn(outline_shape, 0, 0, &amp;scale_factor, rgn);
		PenNormal();
		PenMode(patXor);
		SET_HILITE_MODE(50);
		FrameRgn(rgn);
		DisposeRgn(rgn);
		PopClip();
		PopPort()
	}
	pgDisposeShape(outline_shape);
}
</code></pre>
<h1 id='11-all-about-scrolling'>11 All about scrolling</h1>
<p>Scrolling an HERMES Paige object is handled differently than previous DataPak technology, with a wider feature set.</p>
<h2 id='111-the-ways-to-scroll'>11.1 The ways to scroll</h2>
<p>An HERMES Paige object can be scrolled in one of four ways: by <em>unit</em>, by <em>page</em>, by <em>absolute position</em>, or by a <em>pixel</em> value.</p>
<ol start='' >
<li>Scrolling by <em>unit</em> generally means to scroll one text line increment for vertical scrolling, and some predetermined distance for horizontal scrolling.</li>
<li>Scrolling by <em>page</em> means to scroll one visual area&#39;s worth of distance (clicking the &quot;grey&quot; areas of the scroll bar).</li>
<li>Scrolling by <em>absolute position</em> means the document scrolls to some specified location (such as the result of dragging a &quot;thumb&quot;).</li>
<li>Scrolling by <em>pixel</em> means to move the position up or down by an absolute pixel amount; generally, this method is used if for some reason all of the above methods are unsuitable to your application.</li>

</ol>
<p>For scrolling by a unit, page or absolute value, when an HERMES Paige object is scrolled vertically, an attempt is always made to align the results to a line boundary (so a partial line does not display across the top or bottom).</p>
<h2 id='112-how-hermes-paige-actually-scrolls'>11.2 How HERMES Paige Actually Scrolls</h2>
<p>In reality, neither the text nor the page rectangle within an HERMES Paige object ever &quot;moves&quot;. Whatever coördinates you have set for an HERMES Paige object&#39;s <code>page_area</code> (shape in which text will flow) remains constant and do not change; the same is true for the <code>vis_area</code> and <code>exclude_area</code>.</p>
<p>The way an HERMES Paige object changes its &quot;scrolled&quot; position, however, is by offsetting the display and/or the relative position of a &quot;mouse click&quot; when you call <code>pgDragSelect</code> or any other function that translates a coördinate point to a text location. The scrolled position is a single vertical and horizontal value maintained within the <code>pg_ref</code>; these values are added to the top-left coördinates for text display at drawing time, and they are added to the mouse coördinate when click/dragging.</p>
<p>This could be important information if your application needs to implement some other method for scrolling, because all you would need to do is leave HERMES Paige alone (do not call its scrolling functions) and offset the display yourself (<code>pgDisplay</code> will accept a horizontal and vertical value to temporarily offset the display). Realise that nothing every really moves; lines are always in the same vertical and horizontal position unless your app explicitly changes them.</p>
<p><strong>NOTE:</strong> Class library users — when implementing an HERMES Paige-based document, you are generally better off letting HERMES Paige handle it own scrolling. If at all possible, do not implement <code>scrollView</code> classes that attempt to scroll by changing the window origin.</p>
<h2 id='113-the-scroll'>11.3 The scroll</h2>
<h3 id='pgscroll'><code>pgScroll</code></h3>
<pre><code>void pgScroll (pg_ref pg, short h_verb, short v_verb, short draw_mode);
</code></pre>
<p>Scrolls the HERMES Paige object by a single unit, or by a page unit. A unit and page unit is described in section 11.5, <a href='#115-scroll-values'>Scroll Values</a>. In short, <code>pgScroll</code> scrolls a specified <code>h_verb</code> and <code>v_verb</code> distance.</p>
<p>The values to pass in <code>h_verb</code> and <code>v_verb</code> can each be one of the following:</p>
<pre><code>typedef enum
{
	scroll_none,	// Do not scroll
	scroll_unit,	// Scroll one unit
	scroll_page,	// Scroll one page unit
	scroll_home,	// Scroll to top of document
	scroll_end	// Scroll to end of document
}
scroll_verb
</code></pre>
<p>Because HERMES Paige will scroll the text some number of pixels, a certain amount of &quot;white space&quot; will result on the top or bottom for vertical scrolling, or on the left or right for horizontal scrolling. Hence, the <code>draw_mode</code> indicates the drawing mode HERMES Paige should use when it refreshes the &quot;white space&quot; areas; normally, the value given for <code>draw_mode</code> should be <code>best_way</code>.</p>
<p>On the other hand, while a value of <code>draw_none</code> will disable all drawing and visual scrolling completely, the text contents will still be &quot;moved&quot; by the specified amounts. In other words, were the HERMES Paige document to be scrolled one page down (using <code>pgScroll</code>) but with <code>draw_none</code> given for <code>draw_mode</code>, nothing would change on the screen until the application redisplayed the HERMES Paige text contents. In this case, the refreshed screen would appear to be scrolled one page down. The &quot;draw nothing&quot; feature for scrolling is therefore used only for special cases, in which an application wants to &quot;move&quot; the visual contents up or down without yet drawing anything.</p>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none,		// Do not draw at all 
best_way,		// Use most efficient method(s) 
direct_copy,	// Directly to screen, overwrite 
direct_or,		// Directly to screen, &quot;OR&quot; 
direct_xor,		// Directly to screen, &quot;XOR&quot; 
bits_copy,		// Copy offscreen 
bits_or,		// Copy offscreen in &quot;OR&quot; mode 
bits_xor		// Copy offscreen in &quot;XOR&quot; mode
</code></pre>
<h3 id='examples'>Examples</h3>
<h4 id='macintosh-4'>Macintosh</h4>
<pre><code>if (the_key == HOME_KEY)
{
	pgScroll(doc -&gt; pg, scroll_home, scroll_home, best_way);
	UpdateScrollbarValues(doc);
}
else
if (the_key == END_KEY)
{
	pgScroll(doc -&gt; pg, scroll_none, scroll_end, best_way);
	UpdateScrollbarValues(doc);
}
</code></pre>
<h4 id='responding-to-wmhscroll-and-wmvscroll-events-windows'>Responding to <code>WM_HSCROLL</code> and <code>WM_VSCROLL</code> events (Windows)</h4>
<pre><code>case WM_HSCROLL:
{
	switch(wParam)
	{
		case SB_PAGEDOWN:
			pgScroll(pg, -scroll_page, scroll_none, best_way);
			break;
		case SB_LINEDOWN:
			pgScroll(pg, -scroll_unit, scroll_none, best_way);
			break;
		case SB_PAGEUP:
			pgScroll(pg, scroll_page, scroll_none, best_way);
			break;
		case SB_LINEUP:
			pgScroll(pg, scroll_unit, scroll_none, best_way);
			break;
		case SB_THUMBPOSITION:
		{
			short cur_h, cur_v, max_h, max_v;
			pg getScrollValues(pg, &amp;cur_h, &amp;cur_v, &amp;max_h, &amp;max_v);
			pgSetScrollValues(pg, LOWORD(lParam), cur_v, TRUE, best_way);
			break;
		}
	}
	
	UpdateScrollbars(pg, hWnd);
}
case WM_VSCROLL:
	if (pg)
	{
		switch (wParam)
		{
			case SB_PAGEDOWN:
				pgScroll(pg, scroll_none, scroll_page, best_way);
				break;
			case SB_LINEDOWN:
				pgScroll(pg, scroll_none, scroll_unit, best_way);
				break;
			case SB_PAGEUP:
				pgScroll(pg, scroll_none, scroll_page, best_way); 
				break; 
			case SB_LINEUP:
				pgScroll(pg, scroll_none, scroll_unit, best_way);
				break;
			case SB_TOP:
				pgScroll(pg, scroll_none, scroll_home, best_way);
				break;
			case SB_BOTTOM:
				pgScroll(pg, scroll_none, scroll_end, best_way);
				break;
			case SB_THUMBPOSITION:
				case SB_THUMBTRACK:
				{
					short cur_h, cur_v, max_h, max_v;
					pgGetScrollValues(pg. &amp;cur_h, &amp;cur_v, &amp;max_h, &amp;max_v);
					pgSetScrollValues(pg, &amp;cur_h, LOWORD(lParam), TRUE, best_way);
					break;
				}
			}
			updateScrollbars(pg, hWnd);
		}
	return 0;
</code></pre>
<h3 id='pgscrolltoview'><code>pgScrollToView</code></h3>
<pre><code>(pg_boolean) pgScrollToView (pg_ref pg, long text_offset, short h_extra, short v_extra, short align_line, short draw_mode);
</code></pre>
<p>Scrolls an HERMES Paige object so a specific location in its text is visible. Canonically, this function is used to automatically scroll to the &quot;current line,&quot; although it could also be used for a number of other purposes (such as find/replace) to show specific text location.</p>
<p>The location in <code>pg</code>&#39;s text is given in <code>text_offset</code>; <code>pg</code> will scroll the required distance so the character at <code>text_offset</code> is at least <code>h_extra</code> pixels from the left or right edge of the view area and <code>v_extra</code> pixels from the top or bottom edge. Whether the distance is measured from the top or bottom, or left or right depends in the value of <code>h_pixels</code> and <code>v_pixels</code>; if <code>h_extra</code> is positive, the character must scroll at least <code>pg</code> pixels from the left, otherwise the right edge is used. For <code>v_extra</code>, a positive number uses the top edge and a negative number uses the bottom edge.</p>
<p>The <code>text_offset</code> parameter can be <code>CURRENT_POSITION</code> (value of -1), in which case the current insertion point is used to compute the required scrolling, if any.</p>
<p><strong>FUNCTION RESULT:</strong> The function returns &quot;TRUE&quot; if scrolling occurred.</p>
<p>The <code>draw_mode</code> indicates how the text should be updated. The value given is identical to the <code>display_modes</code> described for <code>pgDisplay</code>; it should be noted that a value of zero will cause the text not to update at all, which technically could be used to simply &quot;offset&quot; the HERMES Paige object contents without doing a physical scroll at all.</p>
<h3 id='scroll-to-cursor-position-windows'>Scroll to cursor position (Windows)</h3>
<pre><code>// ScrollToCursor forces a scroll to the current insertion point (if any)

void ScrollToCursor(pg_ref, pg, HWND hWnd)
{
	short state1, state2;
	pg GetHiliteStates(pg, &amp;state1, &amp;state2;
	
	if (state1 == deactivate_verb || state2 == deactivate_verb)
		return;
	
	if (!pgNumSelections(pg))
	{
		pgPaginateNow(pg. CURRENT_POSITION, FALSE);
		
		if (pgScrollToView(pg, CURRENT_POSITION, 32, 32, TRUE, best_way))
			UpdateScrollbars(pg, hWnd);
	}
	else
		UpdateScrollbars(pg, hWnd);
}
</code></pre>
<h3 id='scroll-to-cursor-position-macintosh'>Scroll to cursor position (Macintosh)</h3>
<pre><code>// ScrollToCursor is called to &quot;autoscroll&quot; to the insertion point

short ScrollToCursor(doc_rec *doc)
{
	short old_h_value;
	if(!pgNumSelections(doc -&gt; pg))
	{
		old_h_value = GetCtlValue(doc -&gt; h_ctl);
		if (pgScrollToView(doc -&gt; pg, CURRENT_POSITION, 32, TRUE, best_way))
		{
			UpdateScrollbarValues(doc);
			update_ruler(doc, old_h_value);
			return TRUE;
		}
	UpdateScrollbarValues(doc);
	return FALSE;
}
</code></pre>
<h3 id='tech-note-cant-scroll-past-end-of-text'>TECH NOTE: Can&#39;t scroll past end of text</h3>
<blockquote><p>I&#39;ve noticed that I cannot scroll vertically past the end of the text in the window. So if the HERMES Paige document is empty, it is not possible to scroll vertically at all. I need to be able to scroll vertically until the bottom part of the 640x480 workspace is visible, even if the user has not yet typed any text. How do I do that?</p>
</blockquote>
<p>You need to force your <code>pg_ref</code> to be fixed height, not &quot;variable&quot;. When you do <code>pgNew</code>, the default document mode is &quot;variable&quot;, meaning that the bottom of the last text line is considered the document&#39;s bottom.</p>
<p>A &quot;fixed&quot; height document is one whose page shape itself (not the text) determines the document&#39;s bottom. From your description of the app, I think this is what you want.</p>
<p>To do so, you need to set <code>BOTTOM_FIXED_BIT</code> and <code>MAX SCROLL_ON_SHAPE</code> in the <code>pg_doc_info</code>&#39;s attributes field. You do this right after <code>pgNew</code>, like this:</p>
<pre><code>pg_doc_info doc_info;
pgGetDocInfo(pg, &amp;doc_info);
doc_info.attributes |= (BOTTOM_FIXED_BIT | MAX_SCROLL_ON_SHAPE);
pgSetDocInfo(pg, &amp;doc_info, FALSE, draw_none);
</code></pre>
<p>This will tell HERMES Paige to scroll to the bottom of your page area regardless of how much (or how little) text there is.</p>
<p>Of course doing this you must now make sure your page shape is exactly whatt you want, e.g. 640x480 (which you said it is).</p>
<p>This &quot;bonus&quot; on this is that you will never have to worry about scrolling; i.e. you won&#39;t need to constantly adjust the scrollbar max values once they are set up because HERMES Paige will only look at the page area&#39;s bottom. EXCEPTION: when you resize window you&#39;ll need to adjust (see answer below).</p>
<h3 id='tech-note-smaller-windowbad-rectangle'>TECH NOTE: Smaller window/bad rectangle</h3>
<blockquote><p>If I resize my window to be &quot;small&quot;, scroll to the far right and far bottom edges of the workspace, then resize the window to be &quot;large&quot;, I am left with the bottom right corner of the workspace in the upper left corner of the screen. What I need to be able to do is to have HERMES Paige adjust the scrolled position so that the bottom right corner of the workspace is in the bottom right corner of the screen. How do I do that?</p>
</blockquote>
<p>There is actually an HERMES Paige function for this exact situation:</p>
<pre><code>PG_PASCAL (pg_boolean) pgAdjustScrollMax (pg_ref pg, short draw_mode);
</code></pre>
<p>What this does is the following: </p>
<ol start='' >
<li>Checks current scrolled position, and:—</li>
<li>If you are now scrolled too far by virtue of having resized the window, HERMES Paige will scroll the doc to &quot;adjust.&quot; </li>

</ol>
<p>Hence, you don&#39;t wind up with the situation you described. The function result is TRUE if it had to adjust (had to scroll).</p>
<p>However, I haven&#39;t tried this yet on a &quot;fixed height&quot; doc (per my suggestion above), but I can&#39;t think of why it shouldn&#39;t work.</p>
<p>Where this function should fit in the scheme of things is:</p>
<ol start='' >
<li>After resize, resize the <code>pg_ref</code> (<code>pgGrowVisArea</code> or whatever you do), then:—</li>
<li>Call <code>pgAdjustScrollMax</code>.</li>

</ol>
<p>If there&#39;s nothing to &quot;fix&quot; in the scrolling, HERMES Paige won&#39;t do anything.</p>
<h3 id='tech-note-vertical-scrolling-behaves-strangely'>TECH NOTE: Vertical scrolling behaves strangely</h3>
<blockquote><p>In the demo &amp; in my application as well since I extracted scrolling code from the demo, vertical scrolling behaves strangely. As the text approaches the bottom of the window the current position indicator moves up rather than down. When the current input position reaches the bottom of the visible portion of the window and the window automatically scrolls up to create extra visible space below the input position, the current position indicator on the scrollbar moves down. I would expect it to move up to reflect the fact that the current position is no longer at the bottom of the window.</p>
</blockquote>
<p>I&#39;m not sure how else this could ever work, at least in relation to how the demo sets up the document.</p>
<p>First, the reason the indicator moves &quot;up&quot; as you approach the bottom is that HERMES Paige is adding a whole new, blank page. So let&#39;s say you start with one page and approach the bottom and the indicator shows $90 \%$ of the document has scrolled down. Suddenly HERMES Paige appends a new page, so now the doc has 2 pages. In this case the scrolled position is no longer 90%, but rather 50%, so naturally the indicator has to move UP.</p>
<p>Following the 90-to-50% indicator change, if the document then auto-scrolls down by virtue of typing, then of course the indicator moves DOWN. This sequence is exactly as you described, which is &quot;correct&quot; in every respect due to the way the document has been created by the demo.</p>
<p>If this is too disconcerting you can work around it in a couple of ways. The first way is <em>not</em> to implement &quot;repeater shapes&quot; the way the demo is doing it, but instead just make one long document. You do this by not setting the <code>V_REPEAT_BIT</code> in <code>pg_doc_info</code>. The end result will be less noticeable with the scrōll indicator (might move a tiny bit but won&#39;t jump so far) because HERMES Paige will just add a small amount of blank space instead of a whole page.</p>
<p>If you still want &quot;repeater&quot; shapes to get the page-by-page effect as in the demo, then the only workaround is to display something to the user that shows <em>why</em> the indicator has moved so much. For example, you could display &quot;Page 1 of 1&quot; and &quot;Page 1 of 2&quot; etc. So, when HERMES Paige inserts a new blank page, it might be obvious to user why the indicator jumps if &quot;Page 1 of 1&quot; changes to &quot;Page 1 of 2&quot;.</p>
<h3 id='tech-note-scrolling-doesnt-include-picture-at-bottom-of-document'>TECH NOTE: Scrolling doesn&#39;t include picture at bottom of document</h3>
<blockquote><p>I have implement pictures anchored to the document (where text wraps around them). However, if I have a picture below the last line of text, I can&#39;t ever scroll the document down to that location. How do I fix this?</p>
</blockquote>
<p>I looked over your situation with HERMES Paige exclusion areas (pictures). HERMES Paige actually does support what you need.</p>
<p>In <code>Paige.h</code> you will notice the following definition near the top of the file:</p>
<pre><code>#define EX_DIMENSION_BIT	Ox00000100	/* Exclude area is included as width/height */
</code></pre>
<p>When you call <code>pgNew</code>, giving <code>EX_DIMENSION_BIT</code> as one of the attribute flags tells HERMES Paige to include the exclusion area as part of the &quot;document height&quot;—which I believe is exactly what you want.</p>
<p>The reason for this attribute—and the reason HERMES Paige does not automatically include an embedded objects anchored to the page—is because it cannot make that assumption, but in many cases (such as your own), setting <code>EX_DIMENSION_BIT</code> tells HERMES Paige to go ahead and assume that.</p>
<h3 id='tech-note-how-do-i-make-hermes-paige-scroll-to-the-right-when-using-word-wrap'>TECH NOTE: How do I make HERMES Paige scroll to the right when using word wrap</h3>
<blockquote><p>I am building a line editor, which expands to the right, very much like a C source code editor. But my right margin is the right side of the text. How do I get it to scroll correctly?</p>
</blockquote>
<p>I think the reason you&#39;re having a problem is that HERMES Paige can only go by what is set in the document bounds (the &quot;page area&quot;) to determine what the width of the document is.</p>
<p>Hence, the answer lies somewhere in forcing the <code>pg_ref</code>&#39;s page area to expand as text expands to the right. At thât time HERMES Paige will adjust its maximum scroll values, its clipping area, etc.—assuming you set the page area using the high-level functions in <code>Paige.h</code>.</p>
<p>The real trick is to figure out how wide the text area is. I&#39;ll create some examples of how you determine the current width of a no-wrap document. See section 24.12, <a href='#2412-getting-the-maximum-text-bounds'>Getting the Maximum Text Bounds</a>.</p>
<h2 id='114-scroll-parameters'>11.4 Scroll Parameters</h2>
<h3 id='set-scroll-params'>Set Scroll Params</h3>
<pre><code>(void) pgSetScrollParams (pg_ref pg, short unit_h, short unit_v, short append_h, short append_v);
</code></pre>
<p>Sets the scroll parameters for <code>pg</code> as follows: <code>unit_h</code> and <code>unit_v</code> define the distance each scrolling unit shall be. This means if you ask HERMES Paige to scroll <code>pg</code> by one unit, horizontal scrolling will advance <code>unit_h</code> pixels and vertical scroll will advance <code>unit_v</code> pixels.</p>
<p>However, <code>unit_v</code> can be set to zero, in which case &quot;variable&quot; units apply. What occurs in this case (i.e., with <code>unit_v</code> equal to zero) is a scrolling distance of whatever is applicable for a single line.</p>
<p>For example, if the line immediately below the bottom of the visual area is 18 pixels, a scrolling down of one unit will move 18 pixels; if the next line is 12 pixels, the next down scrolling would be 12 pixels, and so on.</p>
<p><code>append_h</code> and <code>append_v</code> define extra &quot;white&quot; space to allow for horizontal maximum and vertical maximum, respectively.</p>
<p>For example, suppose you create an HERMES Paige document whose total &quot;height&quot; is 400 pixels. Normally, the scrolling functions in HERMES Paige would not let you scroll beyond that point. The <code>append_v</code> value, however, is the amount of extra distance you will allow for scrolling vertically: if the <code>append_v</code> were 100, then a 400-pixel document would be allowed to scroll 500 pixels.</p>
<p>If you create a new <code>pgRef</code> and do not call <code>pgSetScrollParams</code>, the defaults are as follows: <code>unit_h = 32</code>, <code>unit_v = 0</code>, <code>append_h = 0</code>, <code>append_v = 32</code>.</p>
<h3 id='create-scroll-bars-macintosh'>Create scroll bars (Macintosh)</h3>
<pre><code>// Create a pair of scrollbars
CreateScrollbars(WindowPtr w_ptr, doc_rec new_doc_;
{
	Rect r_v, r_h, paginate_rect;
	InitWithZeros(&amp;new_doc, sizeof(doc_rec)));
	
	new_doc.w_ptr = w_ptr;
	new_doc.mother = mother_window;
	new_doc.pg = create_new_paige(w_ptr);
	
	pgSetTabBase(new_doc.pg, TAB_WRAP_RELATIVE);
	pgSetScrollParams(new_doc.pg, 0, 0, 0, VERTICAL_EXTRA);
	get_paginate_rect(w_ptr, &amp;paginate_rect);
	
	r_v = w_ptr -&gt; portRect;
	r_v.left = r_v.right - 16;
	r_v.bottom -= 13;
	r_h = w_ptr -&gt; portRect;
	r_h.left = paginate_rect.right;
	r_h.top = r_h.bottom - 16;
	r_h.right -= 13;
	OffsetRect(&amp;r_v, 1, -1);
	OffsetRect(&amp;r_h, -1, 1);
	
	new_doc.v_ctl = NewControl(w_ptr, &amp;r_v, &quot;&quot;, TRUE, O, 0, 0, scrollBarProc, 0);
	new_doc.h_ctl = NewControl(w_ptr, &amp;r_h, &quot;&quot;, TRUE, 0, 0, 0, scrollBarProc, 0);
}
</code></pre>
<h3 id='getting-scroll-parameters'>Getting scroll parameters		</h3>
<pre><code>(void) pgGetScrollParams (pg_ref pg, short PG_FAR *unit_h, short PG_FAR *unit_v, short PG_FAR *append_h, short PG_FAR *append_v);
</code></pre>
<p>Returns the scroll parameters for pg. These are described above for <code>pgSetScrollParams</code>..</p>
<h2 id='115-scroll-values'>11.5 Scroll Values</h2>
<h3 id='getting-scroll-indicator-values'>Getting scroll indicator values</h3>
<pre><code>(short) pgGetScrollValues (pg_ref pg, short PG_FAR *h, short PG_FAR *v, short PG_FAR *max_h, short PG_FAR *max_v);
</code></pre>
<p>This is the function you call to get the exact settings for scroll indicators.</p>
<p>On the Macintosh, for example, you would call <code>pgGetScrollValues</code> and set the vertical scrollbar&#39;s value to the value given in <code>*v</code> and its maximum to the value in <code>*max_v</code>. The same settings apply to the horizontal scrollbar for <code>*h</code> and <code>*max_h</code>.</p>
<p>Note that the values are <code>short</code>s. HERMES Paige assumes your controls can only handle ±32 K; hence, it computes the correct values even for huge documents that are way larger than a scroll indicator could handle.</p>
<p><strong>FUNCTION RESULT:</strong> The function returns &quot;TRUE&quot; if the values have changed since the last time you called <code>pgGetScrollValues</code>. The purpose of this Boolean result is to not slow down your app by excessively setting scrollbars when they have not changed.</p>
<p><strong>NOTE:</strong> The values returned from <code>pgGetScrollValues</code> are <em>guaranteed</em> to be within the ± range of an integer value. That means if the document is too large to report a scroll position within the confines of 32K, HERMES Paige will adjust the ratio between the scroll value and the suggested maximum to accommodate this limitation to most controls.</p>
<p><strong>CAUTION:</strong> <code>pgGetScrollValues</code> can return &quot;wrong&quot; values if a major text change has occurred (such as a large insertion, or deletion, or massive style and font changes) but no text has been redrawn.</p>
<p>The reason scroll values will be inaccurate in these cases is because HERMES Paige has not yet recalculated the new positions of text lines - pwhich normally occurs dynamically as it displays text - bso it has no idea that the document&#39;s text dimensions have changed.</p>
<p>To avoid this situation, the following rules should be observed:</p>
<ul>
<li>A common scenario that creates the &quot;wrong&quot; scroll value is importing a large text file (without drawing yet, for speed purposes), then attempting to get the scrollbar maximum to set up the initial scrollbar parameters, all before the window is refreshed. To avoid this situation, it is generally wise to force-paginate the document following a massive insertion if you do not intend to display its text prior to getting the scroll values.</li>
<li>Always call <code>pgGetScrollValues</code> <em>after</em> the screen has been updated following a major text change, and never before. Normally, this is not a problem because most of the text-altering functions accept a <code>draw_mode</code> parameter which, if ≠ 0, tells HERMES Paige to update the text display. There are special cases, however, when an application has reasons to implement large text changes yet passes <code>draw_none</code> for each of these; if that be the case, the screen should be updated at least once prior to <code>pgGetScrollbarValues</code>, OR the document should be repaginated using <code>pgPaginateNow</code>.</li>

</ul>
<h2 id='logical-steps'>Logical Steps</h2>
<p>The following pseudo instructions provide an example for any HERMES Paige platform when determining the values that should be set for both horizontal and vertical scrollbars:</p>
<pre><code>if (I just made a major text change and did not draw) 
	pgPaginateNow(pg, CURRENT_POSITION, FALSE);
if (pgGetScrollValues(pg, &amp;h, &amp;v, &amp;max_h, &amp;max_v)) returns &quot;TRUE&quot; then 
	I should change my scrollbar values as:
	Set horizontal scrollbar maximum to max_h
	Set horizontal scrollbar value to h
	Set vertical scrollbar maximum to max_v
	Set vertical scrollbar value to v
else
	Do nothing.
</code></pre>
<h3 id='update-scrollbar-values-windows'>Update scrollbar values (Windows)</h3>
<pre><code>void UpdateScrollbars (pg_ref pg, HWND hWnd)
{
	short max_h, max_v;
	short h_value, v_value;
	
	if (pgGetScrollValues(pg (short far *) &amp;h_value, short far, (short far *) &amp;max_h, short far *) &amp;max_v));
	{
		if max_v &lt; 1)
			max_v = 1; // For Windows I don&#39;t want scrollbar disappearing
		SetScrollRange (hWnd, SB_VERT, 0, max_v, FALSE);
		SetScrollRange (hWnd, SB_HORZ, 0, max_h, FALSE);
		SetScrollPos (hWnd, SB_VERT, v_value, TRUE);
		SetScrollPos (hWnd, SB_HORZ, h_value, TRUE);
</code></pre>
<h3 id='update-scrollbar-values-macintosh'>Update scrollbar values (Macintosh)</h3>
<pre><code>void UpdateScrollbarValues (doc_rec *doc)
{
	short h, v, max_h, max_v;
	
	if (pgGetScrollValues(doc -&gt; pg, &amp;h, &amp;v, &amp;max_h, &amp;max_v))
	{
		SetCtlMax(doc -&gt; v_ctl, max_v);
		SetCtlValue(doc -&gt; v_ctl, v);
		SetCtlMax(doc -&gt; h_ctl, max_h);
		SetCtlValue(doc -&gt; h_ctl, h);
	}
}
</code></pre>
<h3 id='tech-note-wrong-scroll-values'>TECH NOTE: &quot;Wrong&quot; Scroll Values</h3>
<blockquote><p>In my application I need to scroll to certain characters or styles in the document. I noticed, however, that the visual location of these special characters are often &quot;wrong&quot;, so when I attempt to scroll to these places I do not wind up at the correct place.</p>
</blockquote>
<p>Regarding the scrolling issues, you&#39;ve touched upon a classic problem that I have been handling with support for years and years. &quot;To Paginate or Not To Paginate, that is the question&quot;, <em>pace</em> Shakespeare.</p>
<p>When dealing with potentially large word-wrapping text, the editor must avoid repaginating the whole document <em>at all costs</em>; otherwise, performance is major dog-slow.</p>
<p>Most of our users that have graduated from TextEdit (Macintosh) or EDIT controls (Windows) are limited in their document size and never understand this problem, because TextEdit maintains an array of line positions at all times. That&#39;s because it doesn&#39;t handle a lot of text so it can get away with it. Our text engines, on the other hand, support massive documents, changing point sizes, irregular wrapping and who knows what else. Hence, to learn the exact document height at any given time, HERMES Paige must calculate every single word-wrapping line to come up with a good answer.</p>
<p>To avoid turning into a major dog, HERMES Paige (and its predecessors) elect to repaginate only at the point they <em>display</em>. There are several good reasons for this, the most important one being a typical HERMES Paige-based app applies all kinds of inserts, embedding, style changing and the like before displaying; if HERMES Paige decided to repaginate each time you set a selection or inserted a piece of text or made any changes whatsoever, it would become unbearably slow.</p>
<p>The reason I&#39;m explaining all of this is so you understand WHY your document behaves the way it does with regards to scrolling. Your problem is simply: you have not yet drawn the part of the document that you will scroll to, hence it is unpaginated, hence the &quot;wrong&quot; answer from <code>pgGetScrollvalues</code>. That is also why <code>auto-scroll-to-cursor</code> works a wee bit better, because the <code>auto-scroll</code> forces a redisplay, which forces a paginate, which forces new information about the doc&#39;s height which can then return the &quot;right&quot; answer.</p>
<p>Put simply, <code>pgGetScrollValues</code> has insufficient information about the whole doc if a part of the doc is &quot;dirty&quot; and undisplayed. That&#39;s why forced paginate fixes the problem. That&#39;s also why the &quot;wrong&quot; answer from <code>pgGetScrollValues</code> is intermittent—your doc won&#39;t always be &quot;dirty&quot; every time you call the function, and also sometimes HERMES Paige&#39;s best-guess in this case is correct anyway.</p>
<p>So yes, <code>pgPaginateNow</code> (see section 24.3, <a href='#243-paginate-now'>Paginate Now</a>) is the best approach; I would call it every time before getting the scrollbar info. The problem with your current logic—paginating <em>after</em> <code>pgGetScrollValues</code>—is that the document hasn&#39;t been computed yet for <code>pgGetScrollValues</code>, so it might return FALSE, thinking that the document is unchanged. Remember, <code>pgPaginateNow</code> isn&#39;t that bad since it won&#39;t do anything unless the document really needs it.</p>
<p>But, you should pass <code>CURRENT_POSITION</code> for the <code>paginate_to</code> parameter— that will help performance a bit.</p>
<h3 id='setting-scroll-values'>Setting scroll values</h3>
<pre><code>(void) pgSetScrollValues (pg_ref pg, short h, short v, short align_line, short draw_mode);
</code></pre>
<p>This function is the reverse of <code>pgGetScrollValues</code>. It provides a way to do absolute position scrolling, if necessary.</p>
<p>For example, you would use <code>pgSetScrollValues</code> after the &quot;thumb&quot; is moved to a new location. As in <code>pgGetScrollValues</code>, the values are <code>short</code>s, but HERMES Paige computes the necessary distance to scroll. (Because of possible rounding errors, however, after you have called <code>pgSetScrollValues</code> you should immediately change the scroll indicator settings with the values from a freah call to <code>pgGetScrollValues</code>.</p>
<h3 id='handling-scrolling-with-mouse-macintosh'>Handling scrolling with mouse (Macintosh)</h3>
<pre><code>/* ClickScrollBars gets called in response to a mouseDown event. If mouse is not within a control, this function returns FALSE and does nothing. Otherwise, scrolling is handled and TRUE is returned. */

int ClickScrollBars (doc_rec *doc, EventRecord *event)
{
	Point start_pt;
	short part_code;
	ControlHandle the_control;
	start_pt = event -&gt; where;
	
	GlobalToLocal(&amp;start_pt);
	
	if (part_code = FindControl(start_pt, doc-&gt; w_ptr, &amp;the_control))
	{
		scrolling_doc = doc;
		if (part_code == inThumb)
		{
			long max_h, max_v;
			long scrolled_h, scrolled_v;
			long scroll_h, scroll_v;
			short v_factor, old_h_position;
			
			if (TrackControl(the_control, start_pt, NULL))
			{
				old_h_position = GetCtlValue(doc -&gt; h_ctl);
				pgSetScrollValues(doc -&gt; pg, GetCtlValue(doc -&gt; h_ctl), GetCtlValue(doc -&gt; v_ctl), TRUE, best_way);
				UpdateScrollbarValues(doc);
				update_ruler(doc, old_h_position);
			}
			else
				TrackControl(the_control, start_pt, (ProcPtr) scroll_action_proc);
		}
		return (part_code != 0);
	}
</code></pre>
<h3 id='maximum-scroll-value'>Maximum scroll value</h3>
<p>Adjustments may be needed after large deletions; if so, call the following function.</p>
<pre><code>(pg_boolean) pgAdjustScrollMax (pg_ref pg, short, draw_mode);
</code></pre>
<p>This tells HERMES Paige that <code>pg</code> might need some adjustment after a large deletion or text size change.</p>
<p>For example, suppose you had a document in 24-point text, scrolled to the bottom. User changes the text to 12 point, resulting in a scrolled position way too far down! If you call <code>pgAdjustScrollMax</code>, this situation is corrected (by scrolling up the required distance).</p>
<p>If <code>draw_mode</code> ≠ 0, actual physical scrolling takes place (otherwise the scroll position is adjusted internally and no drawing occurs). <code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none,		// Do not draw at all 
best_way,		// Use most efficient method(s) 
direct_copy,	// Directly to screen, overwrite 
direct_or,		// Directly to screen, &quot;OR&quot; 
direct_xor,		// Directly to screen, &quot;XOR&quot; 
bits_copy,		// Copy offscreen 
bits_or,		// Copy offscreen in &quot;OR&quot; mode 
bits_xor		// Copy offscreen in &quot;XOR&quot; mode
</code></pre>
<p><strong>FUNCTION RESULT:</strong> The function returns TRUE if the scroll position changed.</p>
<h2 id='116-gettingsetting-absolute-pixel-scroll-positions'>11.6 Getting/Setting Absolute Pixel Scroll Positions</h2>
<pre><code>void pgScrollPixels (pg_ref pg, long h, long v, short draw_mode);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function scrolls <code>pg</code> by <code>h</code> and <code>v</code> pixels; scrolling occurs from the current position (i.e., scrolling advances plus or minus from its current position by <code>h</code> or <code>v</code> amount(s).</p>
<p>If <code>draw_mode</code> ≠ 0, actual physical scrolling takes place (otherwise the scroll position is adjusted internally and no drawing occurs).</p>
<p>HERMES Paige will not scroll out of range — the parameters are checked and HERMES Paige will only scroll to the very top or to the maximum bottom as specified by the document&#39;s height and the current scroll parameters.</p>
<p><strong>NOTE:</strong> You should only use this function if you are not using the other scrolling methods listed above.</p>
<pre><code>(void) pgScrollPosition (pg_ref pg, co_ordinate_ptr scroll_pos);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> The above function returns the current (absolute pixel) scroll position. The vertical scroll position is placed in <code>scroll_pos -&gt; v</code> and the horizontal position in <code>scroll_pos -&gt; h</code>.</p>
<p>The positions, however, are always zero or positive: when HERMES Paige offsets the text to its &quot;scrolled&quot; position, it subtracts these values.</p>
<h3 id='forcing-pixel-alignment'>Forcing Pixel Alignment</h3>
<p>In some applications, it is desirable always to scroll on &quot;even&quot; pixel boundaries, or some multiple other than one.</p>
<p>For example, in a document that displays grey patterns or outlines, it can be necessary to always scroll in a multiple of two pixels, otherwise the patterns can be said to be out of &quot;alignment.&quot;</p>
<p>To set such a parameter, call the following:</p>
<pre><code>(void) pgSetScrollAlign (pg_ref pg, short align_h, short align_v);
</code></pre>
<p>The pixel alignment is defined in <code>align_h</code> and <code>align_v</code> for horizontal and vertical scrolling, respectively.</p>
<p>For either parameter, the effect is as follows: </p>
<ul>
<li>if the value is zero, the current alignment value remains unchanged. </li>
<li>if the value is one, scrolling is performed to the nearest single
pixel (i.e., no &quot;alignment&quot; is performed)</li>
<li>if the value is two or more, that alignment is used.</li>

</ul>
<p>For example, if <code>align_v</code> is two, vertical scrolling would always be in multiples of two pixels; if three, alignment would always be a multiple of three pixels, etc.</p>
<h5 id='notes-15'>NOTES:</h5>
<ol start='' >
<li>The current scrolled position in <code>pg</code> is not changed by this function. You must therefore make sure the scrolled position is correctly aligned or else all subsequent scrolling can be constantly &quot;off&quot; of the desired alignment. It is generally wise to set the alignment once, after <code>pgNew</code>, while the scrolled positions are zero.</li>
<li>The default alignment after <code>pgNew</code> is one.</li>
<li>You do not need to set scroll alignment after a file is opened (with <code>upgraded</code>); scroll alignment is saved with the document.</li>

</ol>
<h3 id='getting-alignment'>Getting Alignment</h3>
<pre><code>(void) pgGetScrollAlign (pg_ref pg, short PG_FAR *align_h, short PG_FAR *align_v);
</code></pre>
<p>This function returns the current scroll alignment. The horizontal alignment is returned in <code>*align_h</code> and vertical alignment in <code>*align_v</code>.</p>
<p>Both <code>align_h</code> and <code>align_v</code> can be NULL pointers, in which case they are ignored.</p>
<h2 id='117-performing-your-own-scrolling'>11.7 Performing Your Own Scrolling</h2>
<p>Because certain environments and frameworks support document scrolling in many different ways, a discussion here that explains what actually occurs inside an HERMES Paige object that is said to be &quot;scrolled&quot; might prove helpful.</p>
<p>When HERMES Paige text is &quot;scrolled,&quot; a pair of long integers inside the <code>pg_ref</code> is increased or decreased which defines the extra distance, in pixels, that HERMES Paige should draw its text relative to the top-left of the window.</p>
<p>This is a critical point to consider for implementing other methods of scrolling: the contents of an HERMES Paige document <em>never actually &quot;move&quot; by virtue of <code>pgScroll</code>, <code>pgSetScrollParams</code> or <code>pgSetScrollValues</code></em>. Instead, only two long words within the <code>pg_ref</code> (one for vertical position and one for horizontal position) are changed. When the time comes to display text, HERMES Paige temporarily subtracts these values from the top-left coördinates of each line to determine the target display coördinates; but the coördinates of the text lines themselves (internally to the <code>pg_ref</code>) remain unchanged and are always relative to the top-left of the window&#39;s origin regardless of scrolled position.</p>
<p>Similarly, when <code>pgDragSelect</code> is called (to detect which character(s) contain a mouse coördinate), HERMES Paige does the same thing in reverse: it temporarily adds the scroll positions to mouse point to decide which character has been clicked, again no text really changes its position.</p>
<p>Considering this method, the following facts might prove useful when <code>pgScroll</code> needs to be bypassed altogether and/or if your programming framework requires a system of scrolling:</p>
<ul>
<li>A <code>pg_ref</code> that is &quot;scrolled&quot; is simply a <code>pg_ref</code> whose vertical and horizontal &quot;scroll position&quot; fields are nonzero; at no time does text really &quot;scroll.&quot; HERMES Paige temporarily subtracts these scroll positions from the display coördinates of each line when it comes time to draw the text.</li>
<li>The &quot;scroll position&quot; values can be obtained by calling <code>pgScrollPosition</code>.</li>
<li>The &quot;scroll position&quot; can be set directly by doing a <code>UseMemory(pg_ref)</code>, changing <code>Paige_rec_ptr -&gt; scroll_position</code>, then <code>UnuseMemory(pg_ref)</code>.</li>
<li>The &quot;scroll positions&quot; are always positive, i.e. as the document scrolls from top to bottom or from left to right, the scroll positions increase proportionally by that many pixels.</li>
<li>The simplest way to understand a <code>pg_ref</code>&#39;s &quot;scroll position&quot; is to realise that HERMES Paige only cares about the scroll position when it draws text or processes a <code>pgDragSelect()</code>.</li>
<li>When <code>pgScroll</code> is called, all that really happens is the screen pixels within the <code>vis_area</code> are scrolled, the scroll positions are changed to new values, then the text is redrawn so the &quot;white space&quot; fills up.</li>
<li>If <code>draw_none</code> is given to <code>pgScroll</code>, all that occurs is the scroll positions are changed (no pixels are scrolled and no text is redrawn).</li>
<li>A call to <code>pgGetScrollValues</code> merely returns the value from the scroll position members (with the values modified as necessary to achieve ≤16-bit integer result and adjusted to match what the application has defined as a &quot;scroll unit&quot;).</li>

</ul>
<h2 id='118-alternate-scrolling'>11.8 Alternate Scrolling</h2>
<p>Scrolling a <code>pg_ref</code> &quot;normally&quot;, using <code>pgScroll()</code> and similar functions, the top-left coördinates of the document are changed internally. However, rather than changing the window origin itself, HERMES Paige handles this by remembering these scroll values, and offsetting the position of text at the time it draws its text.</p>
<p>Using this default scrolling method, HERMES Paige assumes that the window origin never changes and that the visual region is relatively constant.</p>
<p>This method, however, can be troublesome within frameworks that require a document to scroll in some other way, especially by changing the window origin. Additionally, certain aspects of these frameworks are difficult to disable and are therefore rendered unfriendly to the HERMES Paige environment.</p>
<p>Most applications that require a different method of scrolling feel they are required to bypass HERMES Paige&#39;s scrolling system completely. While this may be workable, the app suddenly looses all scrolling features in HERMES Paige. For instance, aligning to the top and bottom of lines can be lost; HERMES Paige&#39;s built-in suggestions of where to set scrollbars is lost, etc.</p>
<p>Furthermore, developers that need to bypass HERMES Paige&#39;s scrolling suffer a loss in performance. For example, such an application might need to have an exact &quot;document height&quot;, and it might thus continuously need to change the HERMES Paige <code>shapes</code> region and <code>vis_area</code>.<!-- Look at this again--></p>
<p>The purpose of the features and functions in this section is to provide additional support to scroll many different ways.</p>
<h3 id='external-scrolling-attribute'>External Scrolling Attribute</h3>
<p>A flag bit has been defined that can help applications that want to do their own scrolling:</p>
<pre><code>#define EXTERNAL_SCROLL_BIT 0x00000010
</code></pre>
<p>If you include this bit in the flags parameter for <code>pgNew()</code>, HERMES Paige will assume that the application&#39;s framework will be handling the document&#39;s top-left positioning in relation to scrolling.</p>
<p>What this means is if you create the <code>pg_ref</code> with <code>EXTERNAL_SCROLL_BIT</code>, you can continue to use all the regular HERMES Paige scrolling functions without actually changing the relative position of text (i.e., you can control the position of text and the view area yourself while still letting HERMES Paige compute the document&#39;s maximum scrolling, its current scroll position and the amount you should scroll to align to lines).</p>
<p>For example, using the default built-in scrolling methods (without <code>EXTERNAL_SCROLL_BIT</code> set), calling <code>pgScroll()</code> will move the display up or down by some specified amount; calling <code>pgGetScrollValues()</code> will return how far the text moved. However, if <code>EXTERNAL_SCROLL_BIT</code> is set, calling <code>pgScroll()</code> will change the scroll position values stored in the pg_ref yet <em>the text display itself remains unaffected</em>. But calling <code>pgGetScrollValues()</code> will correctly reflect the scroll position values (the same as it would using the default scrolling method).</p>
<p>Hence, with <code>EXTERNAL_SCROLL_BIT</code> set you can still use all of the HERMES Paige scrolling functions—yet you can adjust the text display using some other method.</p>
<h3 id='changing-window-origin'>Changing Window Origin</h3>
<p><strong>NOTE:</strong> The term &quot;window origin&quot; in this section refers to the machine-specific origin of the window where the <code>pg_ref</code> is &quot;attached;&quot; it does not refer to the &quot;origin” member of the <code>graf_device</code> structure.</p>
<p>The only problem with changing the window&#39;s origin that contains a <code>pg_ref</code> is after you have changed the origin, HERMES Paige&#39;s internal <code>vis_area</code> is no longer valid.</p>
<p>Using the default HERMES Paige scrolling system, an application would have to force new <code>vis_area</code> shapes into the <code>pg_ref</code> every time the origin changed. However, this is inefficient. The following new function has been provided to optimise this situation:</p>
<pre><code>void pgWindowOriginChanged (pg_ref pg, co_ordinate_ptr original_origin, co_ordinate_ptr new_origin);
</code></pre>
<p>If the window in which <code>pg</code> lives has changed its top-left origin <em>for the purpose of moving its view area in relation to text</em>, you should immediately call this function.</p>
<p>By &quot;view area in relation to text&quot; is meant that the window origin has changed to achieve a scrolling effect.</p>
<p>You would <em>not</em> call this function if you simply wanted the whole <code>pg_ref</code> to move, both <code>vis_area</code> and <code>page_area</code>. The intended purpose of <code>pgWindowOriginChanged</code> is to inform HERMES Paige that your app has changed the (OS-specific) window origin to create a scrolled effect, hence the <code>vis_area</code> needs to be updated.</p>
<p>The <code>original_origin</code> should contain the normal origin of the window, i.e. what the top-left origin of the window was initially when you called <code>pgNew()</code>. The <code>new_origin</code> should contain what the origin is now.</p>
<p>Note that the <code>original_origin</code> must be the original window origin at the time the <code>pg_ref</code> was created, not necessarily the window origin that existed before changing it to new_origin. Typically, the original origin is (0, 0).</p>
<p>However, <code>original_orgin</code> can be a null pointer, in which case the position (0, 0) is assumed. Additionally, <code>new_origin</code> can also be a null pointer, in which case the current scrolled position (stored inside the <code>pg_ref</code>) will be assumed as the new origin.</p>
<p>HERMES Paige will take the most efficient route to update its shape(s) to accommodate the new origin. Text is not drawn, nor are the scrolled position values (internal to the <code>pg_ref</code>) changed. All that changes is the <code>vis_area</code> coördinates so any subsequent display will reflect the position of the text in relationship to the visual region.</p>
<h3 id='oldies-but-goodies'>Oldies but Goodies</h3>
<pre><code>pgSetScrollParams();
pgGetScrollParams();
pgGetScrollValues();
pgScroll();
</code></pre>
<p>The above functions are documented elsewhere in this manual, but they are listed again to encourage their use even when customising HERMES Paige scrolling. If you create the <code>pg_ref</code> with <code>EXTERNAL_SCROLL_BIT</code>, you can begin using all the functions above without actually changing the relative position of text (i.e., you can control the position of text and the &quot;view&quot; area yourself while still letting HERMES Paige compute the document&#39;s maximum scrolling, its current scroll position and the amount you should scroll to align to lines).</p>
<h3 id='additional-support'>Additional Support</h3>
<pre><code>void pgScrollUnitsToPixels (pg_ref pg, short h_verb, short v_verb, pg_boolean add_to_position, pg_boolean window_origin_changes, long PG_FAR *h_pixels, long PG_FAR *v_pixels);
</code></pre>
<p>This function returns the amount of pixels that HERMES Paige would scroll if you called <code>pgScroll()</code> with the same <code>h_verb</code> and <code>v_verb</code> values. In other words, if you are doing your own scrolling but want to know where HERMES Paige would scroll if you asked it to, this is the function to use.</p>
<p>However, this function also provides the option to change the internal scroll values in the <code>pg_ref</code>, and/or to inform HERMES Paige that you will be changing the window origin.</p>
<p>Note that if you created the <code>pg_ref</code> with <code>EXTERNAL_SCROLL_BIT</code>, you can change the scroll position values inside the <code>pg_ref</code> but the text itself does not &quot;move.&quot; This will allow your application&#39;s framework to position the text by changing the window origin, etc., but you can still have HERMES Paige maintain the relative position(s) that the document is scrolled.</p>
<p>Upon entry, <code>h_verb</code> and <code>v_verb</code> should be one of the several scroll verbs normally given to <code>pgScroll()</code>.</p>
<p>If <code>add_to_position</code> is TRUE, HERMES Paige adjusts its internal scroll position (which does not affect visual text positions if <code>EXTERNAL_SCROLL_BIT</code> has been set in the <code>pg_ref</code>). If FALSE, the scroll positions are left alone.</p>
<p>If <code>window_origin_changes</code> is TRUE, HERMES Paige assumes that the new scroll position, by virtue of the <code>h_verb</code> and <code>v_verb</code> values, will change the window origin by that same amount. In other words, passing TRUE for this parameter is effectively the same as calling <code>pgWindowOriginChanged()</code> with coördinates that reflect the new origin after the scroll positions have been updated.</p>
<p>When this function returns, <code>*h_pixels</code> and <code>*v_pixels</code> will be set to the number of pixels that HERMES Paige would have scrolled had you passed the same <code>h_verb</code> and <code>v_verb</code> to <code>pgScroll()</code>.</p>
<h3 id='physical-drawingscrolling-support'>Physical Drawing/Scrolling Support</h3>
<pre><code>pg_region pgScrollViewRect (pg_ref pg, long h_pixels, long v_pixels, shape_ref update_area);
</code></pre>
<p>This function will physically scroll the pixels within <code>pg</code>&#39;s <code>vis_area</code> by <code>h_pixels</code> and <code>v_pixels</code>; negative values cause the image to move up and left respectively.</p>
<p>When the function returns, if <code>update_area</code> is not <code>MEM_NULL</code> it is set to the shape of the area that needs to be updated.</p>
<pre><code>void pgSetCaretPosition (pg_ref pg, pg_short_t position_verb, pg_boolean show_caret);
</code></pre>
<p>This function should be used to change the location of the caret (insert position); for example, <code>pgSetCaretPosition</code> is useful for handling arrow keys.</p>
<p>The <code>position_verb</code> indicates the action to be taken. The low byte of this parameter should be one of the following values:</p>
<pre><code>enum
{
	home_caret,
	doc_bottom_caret,
	begin_line_caret,
	end_line_caret,
	next_word_caret,
	previous_word_caret
};
</code></pre>
<p>The high byte of <code>position_verb</code> can modify the meaning of the values shown above; the high byte should be either zero or set to <code>EXTEND_CARET_FLAG</code>.</p>
<p>The following is a description for each value in position_verb:</p>
<p><code>home_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the beginning of the document to the current position; if <code>EXTEND_CARET_FLAG</code> is clear the caret moves to the beginning of the document.</p>
<p><code>doc_bottom_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the end of the document; if <code>EXTEND_CARET_FLAG</code> is clear the caret advances to the end of the document.</p>
<p><code>begin_line_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the beginning of the current line; if <code>EXTEND_CARET_FLAG</code> is clear the caret moves to the beginning of the line.</p>
<p><code>end_line_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the end of the current line; if <code>EXTEND_CARET_FLAG</code> is clear the caret moves to the end of the line.</p>
<p><code>next_word_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the beginning of the next word; if <code>EXTEND_CARET_FLAG</code> is clear the caret moves to the beginning of the next word.</p>
<p><code>previous_word_caret</code> — If <code>EXTEND_CARET_FLAG</code> is set, the text is selected from the current position to the beginning of the previous word; if <code>EXTEND_CARET_FLAG</code> is clear the caret moves to the beginning of the previous word.</p>
<p>If <code>show_caret</code> is TRUE then the caret is redrawn in its new location, otherwise the caret does not visibly change.</p>
<p><strong>NOTE:</strong> This function is simply a portable way to physically scroll the pixels within a <code>pg_ref</code> — no change occurs to the scroll position internal to the <code>pg_ref</code>, nor does the window origin or the <code>vis_shape</code> change in any way.</p>
<pre><code>void pgDrawScrolledArea (pg_ref pg, long pixels_h, long pixels_v, co_ordinate_ptr original_origin, co_ordinate_ptr new_origin, short draw_mode);
</code></pre>
<p>This function will draw the <code>pg_ref</code> inside the area that would exist (or already exists) after a pixel scroll of <code>pixels_h</code> and <code>pixels_v</code>.</p>
<p>For example, if you (or your framework) has already scrolled the document by, say, -60 pixels, a call to <code>pgDrawScrolledArea(pg, 0, -60, …)</code> will cause the document to update within the region that exists by virtue of such a scroll.</p>
<p><strong>NOTE:</strong> This function fills the would-be update area of a scroll but does not actually scroll anything.</p>
<p>However, optional parameters exist to inform HERMES Paige about window origin changes; if you have changed the window origin since the last display, and have not told HERMES Paige about it yet, you can pass the original and new origin in <code>original_origin</code> and <code>new_origin</code> parameters, respectively. These parameters do the same exact thing as on <code>pgWindowOriginChanged()</code> — except if they are null pointers in this case, they are ignored.</p>
<pre><code>void pgLastScrollAmount (pg_ref pg, long *h_pixels, long *v_pixels);
</code></pre>
<p>This function returns the amount of the previous scrolling action, in pixels.</p>
<p>The &quot;scrolling action&quot; would have been any HERMES Paige function that has changed the <code>pg_ref</code>&#39;s internal scroll position. That includes <code>pgScroll</code> and <code>pgScrollUnitsToPixels()</code> if applicable, <em>inter alia</em>.</p>
<p>By &quot;previous scrolling&quot; is meant the last function call that changed the scroll position. For example, there could have been 1,000 non-scrolling functions since the last scrolling change, but <code>pgLastScrollAmount()</code> would only return the values since the last scrolling.</p>
<h2 id='119-draw-scroll-hook--scroll-regions'>11.9 Draw Scroll Hook &amp; Scroll Regions</h2>
<p>An application could repaint the area uncovered by a scroll with the <code>draw_scroll</code> hook:</p>
<pre><code>PG_PASCAL(void) pgDrawScrollProc (paige_rec_ptr pg, shape_ref update_rgn, co_ordinate_ptr scroll_pos, pg_boolean post_call); 
</code></pre>
<p>This function gets called by HERMES Paige after the contents of a <code>pg_ref</code> have been scrolled; the <code>update_rgn</code> shape contains the area of the window that has been uncovered (rendered blank) by the scrolling.</p>
<p>However, an unintentional anomaly exists with this method: the <code>update_rgn</code> contains a shape that represents the entire bounding area of the scrolled area. This presents a problem if the scrolled area is non-rectangular.</p>
<p>For example, an application might have a &quot;Find...&quot; dialogue box in front of the document. If a word is found, causing the document to scroll, the uncovered document area is non-rectangular (the region is affected by the intersection of the Find window).</p>
<p>The basic problem is that HERMES Paige cannot convert a non-rectangular, platform-specific region into a <code>shape_ref</code>.</p>
<p>The <code>paige_rec</code> structure (provided as the <code>pg</code> parameter in the above hook) contains the member <code>.port</code>, which contains a member called <code>scroll_rgn</code>. The <code>scroll_rgn</code> will be a platform-specific region handle containing the actual scrolled region.</p>
<p>For example, if <code>draw_scroll</code> is called, <code>pg -&gt; port.scroll_rgn</code> would be a <code>RgnHandle</code> for Macintosh and an <code>HRGN</code> for Windows. In both cases, if you were to fill that region with something, it would conform to the exact scrolled area, rectangular or not.</p>
<p>As a rule, to avoid problems with non-rectangular scrolled area(s), use <code>pg -&gt; port.scroll_rgn</code> instead of the <code>update_rgn</code> parameter.</p>
<h1 id='12-all-about-shapes'>12 ALL ABOUT SHAPES</h1>
<h2 id='121-up-and-running-with-shapes'>12.1 Up and Running With Shapes</h2>
<p>The quickest way to get &quot;Up and Running&quot; with shapes is to see &quot;Up and Running Shapes”<!-- on page 2-20-->. This shows how to get a document up within rectangles to display and/or edit.</p>
<p>This chapter provides more details should you wish to provide your users with more complex shapes.</p>
<h2 id='122-basic-shape-areas'>12.2 Basic shape areas</h2>
<p>As mentioned in several places in this document, an HERMES Paige object maintains three basic shape areas.</p>
<p>The exact description and behavior for each of these shapes is as follows:</p>
<p><code>vis_area</code> — The &quot;viewable&quot; area of an HERMES Paige object. Stated simply, anything that HERMES Paige displays that is even one pixel outside the <code>vis_area</code> gets clipped (masked out). Usually, the <code>vis_area</code> in an HERMES Paige object is some portion (or all) of a window&#39;s content area and remains unmoving and stationary. (See Figure 8 <em>infra</em>).</p>
<p><code>page_area</code> — The area in which text will flow. For the simplest documents, the <code>page_area</code> can be considered a rectangle, or &quot;page&quot; which defines the top-left position of text display as well as the maximum width. For example, if you wanted to create a document representing an 8&quot; wide page, you simply specify a <code>page_area</code> that is 8 inches wide. Hence, text will wrap within those boundaries.</p>
<p>The <code>page_area</code> may or may not be the same size as the <code>vis_area</code>, and may or may not align with the <code>vis_area</code>&#39;s top-left position. In fact, a large document on a small monitor would almost always be larger than the <code>vis_area</code> (see Figure 8<!-- on page 12-213-->).</p>
<p><code>exclude_area</code> - An optional area of an HERMES Paige object which text flow must avoid. An good example of implementing an <code>exclude_area</code> would be placing a picture on a document which text must wrap over (or wrap around from left to right). The easiest way to do this would be to build an <code>exclude_area</code> that contains the picture&#39;s bounding frame, resulting in the forced avoidance of text for that area.</p>
<p>All three shapes can be changed dynamically at any time. Changing the <code>page_area</code> would force text to rewrap to match the new shape; changing the <code>exclude_area</code> would also force text to rewrap in order to avoid the new areas.</p>
<p>If you are specifically implementing &quot;containers&quot;, see chapter 14, <a href='#14-containers-support'>Containers Support</a>, for an easier path.</p>
<p>If you are implementing any kind of exclusion shapes, see chapter 15, <a href='#15-exclusion-areas'>Exclusion Areas</a>.</p>
<p><img src="figs/fig8.jpg" referrerpolicy="no-referrer"></p>
<p>As stated, the simplest documents are rectangles; however, the <code>page_area</code> can be non-rectangular. A good example of this would be columns in which text must flow from one column to the other. In this case, the <code>page_area</code> would look similar to what is shown in Figure 9 <em>infra</em>.</p>
<p><img src="figs/fig9.jpg" referrerpolicy="no-referrer"></p>
<h2 id='123-coordinates--graphic-structures'>12.3 Coordinates &amp; Graphic Structures</h2>
<p>For purposes of cross-platform technology, HERMES Paige defines its own set of structures to represent screen positions (coordinates) and shapes. Except for machine-specific source files, no reference is made to, say, Macintosh “QuickDraw” structures.</p>
<p>The main components (&quot;building blocks&quot;) of shapes are the following record structures:</p>
<h4 id='rectangle'><code>Rectangle</code></h4>
<pre><code>typedef struct
{
	co_ordinate top_left;	// Top-left of rect
	co_ordinate bot_right;	// Bottom-right of rect
}
rectangle, *rectangle_ptr;
</code></pre>
<h4 id='coordinate'><code>Co_ordinate</code></h4>
<pre><code>typedef struct
{
	long v;	// vertical position
	long h;	// horizontal position
}
co_ordinate;
</code></pre>
<h2 id='124-whats-inside-a-shape'>12.4 What&#39;s Inside a Shape</h2>
<p>Shapes are simply a series of rectangles. A very complex shape could theoretically be represented by thousands of rectangles, the worst-case being one rectangle surrounding each pixel.</p>
<p>All shape structures consist of a bounding rectangle (first rectangle in the array) followed by one or more rectangles; the bounding rectangle (first one) is constantly updated to reflect the bounding area of the whole shape as the shape changes.</p>
<p>Hence, the shape structure is defined simply as:</p>
<pre><code>typedef rectangle shape; // Also a &quot;shape&quot;, really
typedef rectangle_ptr shape_ptr;
</code></pre>
<p>A shape is maintained by HERMES Paige, however, as a memory_ref to a block of memory that contains the shape information. In the header it is defined as:</p>
<pre><code>typedef memory_ref shape_ref; // Memory ref containing a &quot;shape&quot;
</code></pre>
<h2 id='125-rules-for-shapes'>12.5 Rules for Shapes</h2>
<p>The following rules apply to shapes with respect to the list of rectangles they contain:</p>
<ol start='' >
<li>If rectangle edges are connected exactly (i.e., if two edges have the same value), they are considered as &quot;one&quot; even if such a union results in a non-rectangular shape (see Figure 10<!-- on page 12-216-->).</li>
<li>If rectangle edges are not connected, they are considered separate &quot;containers;&quot; even if they overlap. (Overlapping would result in overlapping text if the shape definition was intended for the area where text is drawn).</li>

</ol>
<p><img src="figs/fig10.jpg" referrerpolicy="no-referrer">
<img src="figs/fig11.jpg" referrerpolicy="no-referrer"></p>
<h2 id='126-building-shapes'>12.6 Building Shapes</h2>
<p>Placing data into the <code>shape_ref</code> is the subject of discussion in this section. However, you will not normally manipulate the <code>shape_ref</code> data directly.</p>
<h3 id='creating-new-shapes'>Creating new shapes</h3>
<p>The easiest way to create a new shape is to use the following function:</p>
<pre><code>(shape_ref) pgRectToShape (pgm_globals_ptr globals, rectangle_ptr rect);
</code></pre>
<p>This returns a new <code>shape_ref</code> (which can be passed to one of the &quot;area&quot; parameters in <code>pgNew</code>). The <code>globals</code> parameter must be a pointer to the same structure given to <code>pgMemStartup()</code> and <code>pgInit()</code>.</p>
<p>The <code>rect</code> parameter is a pointer to a rectangle; this parameter, however, can be a null pointer in which case an empty shape is returned (shape with all sides = 0).</p>
<h3 id='setting-a-shape-to-a-rectangle'>Setting a Shape to a Rectangle</h3>
<p>If you have already created a <code>shape_ref</code>, you can &quot;clear&quot; its contents and/or set the shape to a single rectangle by calling the following:</p>
<pre><code>(void) pgSetShapeRect (shape_ref the_shape, rectangle_ptr rect);
</code></pre>
<p>The shape <code>the_shape</code> is changed to represent the single rectangle <code>rect</code>. If <code>rect</code> is a null pointer, <code>the_shape</code> is set to an empty shape.</p>
<h3 id='adding-to-a-new-shape'>Adding to a New Shape</h3>
<p>The best way to build a shape requiring more than one rectangle is to call the following:</p>
<pre><code>(void) pgAddRectToShape (shape_ref the_shape, rectangle_ptr rect);
</code></pre>
<p>The rectangle pointed to by <code>rect</code> is added to the rectangle list in <code>the_shape</code>, combining it with other rectangles if necessary. When a rectangle is added, <code>pgAddRectToShape</code> first explores all existing rectangles in <code>the_shape</code> to see if any of them can &quot;merge&quot; with <code>rect</code> (see section 12.5, <a href='#125-rules-for-shapes'>Rules for Shapes</a>). If none can be combined, <code>rect</code> is appended to the end of the list.</p>
<p>If <code>the_shape</code> is empty, <code>the_shape</code> gets set to the dimensions of rect (as if you had called <code>pgSetShapeRect</code> <em>supra</em>).</p>
<p><img src="figs/fig12.jpg" referrerpolicy="no-referrer"></p>
<h3 id='disposing-a-shape-2'>Disposing a Shape</h3>
<p>To dispose a shape, call:</p>
<pre><code>(void) pgDisposeShape (shape_ref the_shape);
</code></pre>
<h3 id='rect-to-rectangle-2'><code>Rect</code> to Rectangle</h3>
<p>Two utilities exist that make it easier to create HERMES Paige rectangles:</p>
<pre><code>#include &quot;pgTraps.h&quot;
(void) RectToRectangle (Rect PG_FAR *r, rectangle_ptr pg_rect);
(void) RectangleToRect (rectangle_ptr pg_rect, co_ordinate_ptr offset, Rect PG_FAR *r);
</code></pre>
<p><code>RectToRectangle</code> converts <code>Rect r</code> to rectangle <code>pg_rect</code>. The <code>pg_rect</code> parameter must be a pointer to a rectangle variable you have declared in your code.</p>
<p><code>RectangleToRect</code> converts <code>pg_rect</code> to <code>r</code>; also, if offset is non-null the resulting <code>Rect</code> is offset by the amounts of the coordinate (for example, if <code>offset.h</code> and <code>offset.v</code> were (10, 5) the resulting Rect would be the values in <code>pg_rect</code> with left and right amounts offset by 10 and top and bottom amounts offset by -5.</p>
<p><strong>NOTE (Macintosh):</strong> Since a Mac <code>Rect</code> has a ±32 K limit for all four sides, HERMES Paige rectangle sides larger than 32 K will be intentionally truncated to about 30 K.</p>
<p><strong>NOTE:</strong> You <em>must</em> <code>#include &quot;pgTraps.h&quot;</code> in any code that calls either function above.</p>
<h2 id='127-manipulating-shapes'>12.7 Manipulating shapes</h2>
<h3 id='moving-shapes'>Moving shapes</h3>
<pre><code>(void) pgOffsetShape (shape_ref the_shape, long h, long v);
</code></pre>
<p>Offsets (moves) <code>*the_shape</code> by <code>h</code> (horizontal) and <code>v</code> (vertical) distances. These may be negative. Positive numbers move to the right horizontally and down vertically as appropriate.</p>
<p><img src="figs/fig13.jpg" referrerpolicy="no-referrer"></p>
<h3 id='shrinking-or-expanding-shape'>Shrinking or expanding shape</h3>
<pre><code>(void) pgInsetShape (shape_ref the_shape, long h, long v);
</code></pre>
<p>Insets (shrinks or expands) <code>*the_shape</code> by <code>h</code> and <code>v</code> amounts. Positive numbers inset the shape inwards and negative numbers expand it.</p>
<pre><code>(pg_short_t) pgPtInShape (shape_ref the_shape, co_ordinate_ptr point, co_ordinate_ptr offset_extra, co_ordinate_ptr inset_extra, pg_scale_ptr scaling);
</code></pre>
<p><code>pgPtInShape</code> returns &quot;TRUE&quot; if point is within any part of <code>the_shape</code> (actually, the rectangle number is returned beginning with #1). The point is temporarily offset with <code>offset_extra</code> if <code>offset_extra</code> is non-null before checking if it is within <code>the_shape</code> (and the offset values are checked in this case, not the original point).</p>
<p>If scaling is non-NULL, <code>the_shape</code> is temporarily scaled by that scale factor. For no scaling, pass NULL.</p>
<p>Also, each rectangle is temporarily inset by the values in <code>inset_extra</code> if it is non-NULL. Using this parameter can provide extra &quot;slop&quot; for point-in-shape detection. Negative values in <code>inset_extra</code> enlarge each rectangle for checking and positive numbers reduce each rectangle for checking.</p>
<p><strong>NOTE:</strong> For convenience, <code>the_shape</code> can be also be <code>MEM_NULL</code>, which of course returns FALSE.</p>
<pre><code>(pg_short_t) pgSectRectInShape (shape_ref the_shape, rectangle_ptr rect, rectangle_ptr sect_rect)
</code></pre>
<p>Checks to see if a rectangle is within <code>the_shape</code>. First, <code>offset_extra</code>, if non-null, moves <code>rect</code> by the amount in <code>offset_extra.h</code> and <code>offset_extra.v</code>, then checks if it intersects any part of <code>the_shape</code>. The result is TRUE if any part of <code>rect</code> is within the shape, FALSE if it is not. If <code>the_shape</code> is empty, the result is always FALSE.</p>
<p>Actually, a &quot;TRUE&quot; result will really be the rectangle number found to intersect, beginning with 1 as the first rectangle.</p>
<p><strong>NOTE:</strong> A result of TRUE does not necessarily mean that rect doesn&#39;t intersect with any other rectangle in <code>the_shape</code>; rather, one rectangle was found to intersect and the function returns.</p>
<p>If <code>sect_rect</code> is not <code>MEM_NULL</code>, it gets set to the intersection of <code>rect</code> and the first rectangle in <code>the_shape</code> found to intersect it.</p>
<h3 id='shape-bounds'>Shape Bounds</h3>
<pre><code>(void) pgShapeBounds (shape_ref the_shape, rectangle_ptr bounds);
</code></pre>
<p>Returns the rectangle bounds of the outermost edges of the_shape. The bounds is placed in the rectangle pointed to by bounds (which cannot be null).</p>
<p><img src="figs/fig14.jpg" referrerpolicy="no-referrer"></p>
<h3 id='comparing-shapes'>Comparing Shapes</h3>
<pre><code>(pg_boolean) pgEmptyShape (shape_ref the_shape);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns TRUE if <code>the_shape</code> is empty (all sides are the same or all zeros).</p>
<pre><code>(pg_boolean) pgEqualShapes (shape_ref shape1, shape_ref shape2);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> Returns TRUE if <code>shape1</code> matches <code>shape2</code> exactly, even if both are empty.</p>
<h3 id='intersection-of-shapes'>Intersection of shapes</h3>
<pre><code>(pg_boolean) pgSectShape (shape_ref shape1, shape_ref shape2, shape_ref result_shape);
</code></pre>
<p>Sets <code>result_shape</code> to the intersection of <code>shape1</code> and <code>shape2</code>. All <code>shape_ref</code> parameters must be valid <code>shape_ref</code>s, except <code>result_shape</code> can be <code>MEM_NULL</code> (which you might want to pass just to check if two shapes intersect). Additionally, <code>result_shape</code> cannot be the shape <code>shape_ref</code> as <code>shape1</code> or <code>shape2</code> or this function will fail.</p>
<p>If either <code>shape1</code> or <code>shape2</code> is an empty shape, the result will be an empty shape. Also, if nothing between <code>shape1</code> and <code>shape2</code> intersects, the result will be an empty shape.</p>
<p><strong>FUNCTION RESULT:</strong> The function result will be TRUE if any part of <code>shape1</code> and <code>shape2</code> intersect (and <code>result_shape</code> gets set to the intersection if not <code>MEM_NULL</code>), otherwise FALSE is returned and <code>result_shape</code> gets set to an empty shape (if not <code>MEM_NULL</code>).</p>
<p><img src="figs/fig15.jpg" referrerpolicy="no-referrer"></p>
<p><strong>FUNCTION RESULT:</strong> Neither <code>shape1</code> nor <code>shape2</code> are altered by this function.</p>
<pre><code>(void) pgDiffShape (shape_ref shape1, shape_ref shape2, shape_ref result_shape);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function places the difference in <code>result_shape</code> between <code>shape1</code> and <code>shape2</code>.</p>
<p>Unlike <code>pgSectShape</code>, <code>result_shape</code> cannot be <code>MEM_NULL</code>; however, it <em>can</em> be the same <code>shape_ref</code> as <code>shape1</code> or <code>shape2</code>.</p>
<p>The &quot;difference&quot; is computed by subtracting all portions of <code>shape1</code> from <code>shape2</code>, and the geometric difference(s) produce <code>result_shape</code>. If <code>shape1</code> is an empty shape, <code>result_shape</code> will be a mere copy of shape2; if <code>shape2</code> is empty, <code>result_shape</code> will be empty.</p>
<p><img src="figs/fig16.jpg" referrerpolicy="no-referrer">
<img src="figs/fig17.jpg" referrerpolicy="no-referrer"></p>
<h3 id='erase-a-shape'>Erase a Shape</h3>
<pre><code>(void) pgEraseShape (pg_ref pg, shape_ref the_shape, pg_scale_ptr scale_factor, co_ordinate_ptr offset_extra, rectangle_ptr vis_bounds);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function will erase <code>the_shape</code> (by filling it with the background colour of the device in <code>pg</code>).</p>
<p>The <code>scale_factor</code> parameter defines scaling, if any; for no scaling, pass zero for this parameter. If you want scaling, see section 16.2, <a href='#162-scaling-a-hermes-paige-object'>Scaling a HERMES Paige Object</a>.</p>
<p>If <code>offset_extra</code> is non-null, <code>the_shape</code> is temporarily offset by <code>offset_extra -&gt; h</code> and <code>offset_extra -&gt; v</code> amounts before the erasure occurs.</p>
<p>If <code>vis_bounds</code> is non-null, then only the parts of <code>the_shape</code> that intersect with <code>vis_bounds</code> get erased; otherwise, the whole shape is erased (see illustration <em>infra</em>).</p>
<p><img src="figs/fig18.jpg" referrerpolicy="no-referrer"></p>
<h3 id='moving-a-shape-in-a-pgref'>Moving a Shape in a <code>pg_ref</code></h3>
<pre><code>(void) pgOffsetAreas (pg_ref pg, long h, long v, pg_boolean offset_page, pg_boolean offset_vis, pg_boolean offset_exclude);
</code></pre>
<p>This function &quot;moves&quot; the page area and/or visual area and/or the exclusion area of <code>pg</code>. If <code>offset_page</code> is TRUE, the page area is moved; if <code>offset_vis</code> is TRUE the visual area is moved; if <code>offset_exclude</code> is TRUE the exclusion area is moved.</p>
<p>Each area is moved horizontally and vertically by <code>h</code> and <code>v</code> pixels, respectively. What occurs is <code>h</code> gets added to the left and right sides of all rectangles enclosed in the shape while <code>v</code> gets added to top and bottom. Hence the shape is moved left or right, up or down with negative and positive values, respectively.</p>
<p><strong>NOTE:</strong> The contents of <code>pg</code> are not redrawn.</p>
<h2 id='128-region-conversion-utilities'>12.8 Region Conversion Utilities</h2>
<pre><code>void ShapeToRgn (shape_ref src_shape, long offset_h, long offset_v, pg_scale_factor PG_FAR *scale_factor, short inset_amount, rectangle_ptr sect_rect, RgnHandle rgn);
</code></pre>
<p>This function sets region <code>rgn</code> to <code>src_shape</code>. In addition, the region is offset by <code>offset_h</code> and <code>offset_v</code> amounts. If <code>scale_factor</code> is non-<code>NULL</code>, the resulting region is scaled by that scaling factor (see chapter 16, <a href='#16-scaling'>Scaling</a>).</p>
<p>Each rectangle added to the region is inset by <code>inset_amount</code> (<code>inset_amount</code> is added to the top and left and subtracted from right and bottom).</p>
<p>If <code>sect_rect</code> is non-<code>NULL</code>, every rectangle in the shape is first intersected with <code>sect_rect</code> and the intersection (only) is output to the region.</p>
<p><strong>NOTE:</strong> You <em>must</em> <code>#include &quot;pgTraps.h&quot;</code> to use this function.</p>
<p><strong>NOTE (Windows):</strong>  <code>RgnHandle</code> is <code>typedef</code>ed in <code>pgTraps.h</code> and is the same as <code>HRGN</code>.</p>
<p><strong>CAUTION:</strong> Converting huge complex shapes to a region can be slow.</p>
<h3 id='picture-handle-to-shape-macintosh-only'>Picture Handle to Shape (Macintosh only)</h3>
<p>The following function is available only for Macintosh that takes a picture and produces a shape that encloses the picture&#39;s outside edges:</p>
<pre><code>#include &quot;pgTraps.h&quot;
(void) PictOutlineToShape (PicHandle pict, shape_ref target_shape, short accuracy)
</code></pre>
<p>Given a picture in <code>pict</code> and a <code>shape_ref</code> in <code>target_shape</code>, this function sets <code>target_shape</code> to surround the outside bit image of the picture.</p>
<p>The <code>accuracy</code> parameter can be a value from 0 to 7 and indicates how &quot;accurate&quot; the shape should be: 0 is the most accurate (but consumes the most memory) and 7 is the least accurate (but consumes the least memory). The <code>accuracy</code> value actually indicates how many pixels to skip, or &quot;group&quot; together in forming the image. If <code>accuracy = 0</code>, the image is produced to the nearest pixel — which theoretically can mean that a rectangle is produced for every pixel surrounding the image (which is why so much memory can be consumed).</p>
<p>The picture does not need to be a bitmap image, and it can be in colour (the image is produced around the outside edges of all nonwhite areas for colour).</p>
<p><strong>NOTE:</strong> Large, complex images can not only consume huge amounts of memory but can take several seconds to produce the image, so use this function sparingly!</p>
<p><strong>NOTE:</strong> You <em>must</em> <code>#include &quot;pgTraps.h&quot;</code> to use this function.</p>
<h2 id='129-page-area-background-colours'>12.9 Page Area Background Colours</h2>
<p>HERMES Paige will support any background colour (which your machine can support) even if the target window&#39;s background colour is different.</p>
<p>The page area (area text draws and wraps) will get filled with the specified colour before text is drawn; hence this features lets you overlay text on top of non-white backgrounds (or, if desirable, will also let you overlay white text on top of dark or black backgrounds).</p>
<p>Note that this differs from the <code>bk_color</code> value in <code>style_info</code>. When setting the <code>style_info</code> background, HERMES Paige will simply turn on that background colour only for that text. Setting the general background colour (using the functions below) sets the background of the entire page area.</p>
<h4 id='colour-text-and-text-background'>COLOUR TEXT AND TEXT BACKGROUND</h4>
<p><strong>NOTE:</strong> For information about setting text colour and text background colour, see section 8.6, <a href='#86-settinggetting-text-colour'>Setting/Getting Text Colour</a>, and &quot;Changing Styles&quot;<!-- on page 30-7--> .</p>
<p>HERMES Paige will also recognise which colour is considered &quot;transparent&quot;. Normally, this would be the same color as the window&#39;s normal background colour, typically &quot;white.&quot;</p>
<p>&quot;Transparent&quot; is simply the background colour for which HERMES Paige will not set or force. Defining which color is transparent in this fashion lets you control the background colour(s) for either the entire window and/or a different colour for the window versus the <code>pg_ref</code>&#39;s page area.</p>
<h2 id='1210-transparent-colour'>12.10 Transparent Colour</h2>
<p>The colour that is specified as &quot;transparent&quot; effectively tells HERMES Paige: &quot;Leave the background alone if the page area&#39;s background is the transparent colour.&quot;</p>
<p>For most situations, you can leave the transparent colour as its default — white.</p>
<p>Here is an example, however, where you might need to change the transparent color. Suppose that your whole window is always blue but you want HERMES Paige to draw on a white background. In this case, you would set the transparent colour to something other than &quot;white&quot; so HERMES Paige is forced to set a white background. Otherwise, HERMES Paige will not change the background at all when it draws text since it assumes the window is already in that colour.</p>
<h2 id='1211-settinggetting-the-background-colour'>12.11 Setting/Getting the Background Colour</h2>
<pre><code>(void) pgSetPageColor (pg_ref pg, color_value_ptr color);
(void) pgGetPageColor (pg_ref pg, color_value_ptr color);
</code></pre>
<p>To change the page area background colour, call <code>pgSetPageColor</code>. The new background colour will be copied from the <code>color</code> parameter.</p>
<p>To obtain the current page colour, use <code>pgGetPageColor</code> and the background colour of <code>pg</code> is copied to <code>*color</code>.</p>
<p>After changing the background, subsequent drawing will fill the page area with that colour before text is drawn.</p>
<p><strong>NOTE:</strong> <code>pgSetPageColor</code> does not redraw anything.</p>
<h2 id='1212-gettingchanging-the-transparent-colour'>12.12 Getting/Changing the Transparent Colour</h2>
<p>The &quot;transparent colour&quot; is a global value, as a field in <code>pg_ref</code>. Hence, all <code>pg_ref</code>s will check for the transparent colour by looking at this field.</p>
<p>If you need to swap different transparent colours in and out for different situations, simply change <code>pg_globals -&gt; trans_color</code> to the desired value.</p>
<p>NOTE: Usually the only time you need to change the transparent colour to something other than its default (white) is the following scenario: Non-white background colour for the whole window, but white background for a <code>pg_ref</code>&#39;s page area. In every other situation it is safe to leave the transparent colour in <code>pg_globals</code> alone.</p>
<h2 id='1213-miscellaneous-utilities'>12.13 Miscellaneous Utilities</h2>
<pre><code>(void) pgErasePageArea (pg_ref pg, shape_ref vis_area);
</code></pre>
<p>This function fills <code>pg</code>&#39;s page area with the current page background color of <code>pg</code>.</p>
<p>The fill is clipped to the page area intersected with the shape given in the <code>vis_area</code> parameter. However, if <code>vis_area</code> is a null pointer, then the <code>vis_area</code> in <code>pg</code> is used to intersect instead.</p>
<p><strong>NOTE:</strong> You do not normally need to call this function: HERMES Paige fills the appropriate areas(s) automatically when it draws text. This function exists for special situations where you want to &quot;erase&quot; the page area.</p>
<h2 id='1214-hermes-paige-background-colours'>12.14 HERMES Paige Background Colours</h2>
<p>The purpose of this section is to provide some additional information about HERMES Paige &quot;background&quot; colours and their relationship to the window&#39;s background colour.</p>
<p>First, let&#39;s clarify the difference between three different aspects of background:</p>
<ul>
<li><em>Page background colour</em> is the colour that fills the background of your page area. The &quot;page area&quot; is the specific area in the <code>pg_ref</code> in which text flows, or wraps. This is not necessarily the same colour as the window&#39;s background colour. For instance, if the page area were smaller than the window that contained it, the page background would fill only the page area, while the remaining window area would remain unchanged.</li>
<li><em>Window background colour</em> is the background colour of the window itself. This can be different than the window&#39;s background colour.</li>
<li><em>Text background colour</em> is the background colour of text characters, applied as a style (just as italic, bold, underline, etc. is applied to text characters). Text background colour applies only to the text character itself. This can be different from both window background and page background.</li>

</ul>
<h2 id='1215-whowhat-controls-colors'>12.15 Who/What Controls Colors</h2>
<p>When creating new HERMES Paige objects, the page area background colour is purely determined by the <code>def_bk_color</code> member of HERMES Paige globals. Afterwards, this colour can be changed by calling <code>pgSetPageColor()</code>.</p>
<p>The window background colour is purely controlled by your application and no HERMES Paige functions alter that colour.</p>
<p>Text background is controlled by changing the <code>bk_color</code> member of <code>style_info</code>, and that color applies only to the character(s) of that particular style.</p>
<h2 id='1216-what-is-transcolor-in-hermes-paige-globals'>12.16 What is &quot;trans_color&quot; in HERMES Paige globals?</h2>
<p>The purpose of <code>pg_globals.trans_color</code> is to define the default <code>WINDOW</code> background. Since HERMES Paige is a portable library, the <code>trans_color</code> member is provided as a platform-independent method for HERMES Paige to know what the &quot;normal&quot; background colour is.</p>
<p>HERMES Paige uses <code>trans_color</code> only as a reference. Essentially, <code>trans_color</code> defines the colour that would appear if HERMES Paige left the window alone, or the colour that would be used by the operating system if the window were &quot;erased&quot;.</p>
<p>The value of <code>trans_color</code> becomes the most significant when you have set the page and/or text color to something different to the window color, because HERMES Paige compares the page and text colors to <code>trans_color</code> to determine whether or not to <code>ERASE</code> the background.</p>
<p>Its reasoning is, &quot;... If the background color I am to draw <em>is not</em> the &quot;normal&quot; background color [<code>trans_color</code>], then I need to force-fill the background.”</p>
<p>Conversely, &quot;... If the background color I am to draw <em>is</em> the same as <code>trans_color</code>, then I don&#39;t have to set anything special”.</p>
<p>Herein is most of the difficulty that HERMES Paige users encounter with background colors: they set the window to a non-white background, yet they usually leave <code>pg_globals.trans_color</code> alone. This is OK as long as <code>trans_color</code> and the page area colour are different.</p>
<p>But if you want the page background and window background to be the same, make sure <code>pg_globals.trans_color</code> is the same as the page background color. The general rules are:</p>
<ol start='' >
<li>Always set <code>pg_globals.trans_color</code> to the same value as the window&#39;s background color. Do this regardless of what the page area background color will be.</li>
<li>The only time you need to change <code>pg_globals.trans_color</code> is when/if you have changed the window&#39;s background color to something other than what is already in <code>pg_globals.trans_color</code>.</li>
<li>Setting page and/or text colour has nothing to do with the window&#39;s real background colour. These may or may not be the same, and HERMES Paige only knows if they match the window by comparing them to <code>trans_color</code>.</li>
<li>To make the page area AND the window backgrounds match each other, you must set <code>pg_globals.trans_color</code>, <code>pgSetPageColor()</code> and the window background colour to the same colour value.</li>

</ol>
<h1 id='13-pagination-support'>13 PAGINATION SUPPORT</h1>
<p>Although HERMES Paige does not provide full pagination features as such, several powerful support functions and features exist to help implement page breaks, columns, margins, etc.</p>
<p>For custom text placement not covered in this chapter and for custom pagination features such as widows and orphans, keep with next paragraph, etc. see chapter 37, <a href='#37-advanced-text-placement'>Advanced Text Placement</a>.</p>
<h2 id='131-hermes-paige-document-info'>13.1 HERMES Paige &quot;Document Info&quot;</h2>
<p>In every <code>pg_ref</code>, the following structure is maintained:</p>
<pre><code>typedef struct
{
	long attributes;			// Various attributes (see below)
	short page_origin;			// What corner = origin
	pg_short_t num_pages;		// Number of &quot;real&quot; pages
	short exclusion_inset;		// Amount to inset exclusion area when clipping
	short scroll_inset;			// Amount to inset vis area when scrolling
	short caret_width_extra;	// Width of the caret
	long repeat_slop;			// Minimum remaining before repeat
	short minimum_widow;		// Minimum window (lines) NOTE SPELLING!
	short minimum_orphan;		// Minimum orphan (lines)
	co_ordinate repeat_offset;	// Amount of &quot;gap for repeater shapes
	rectangle print_target;		// App can use as printed page size
	rectangle margins;			// Applied page margins
	rectangle offsets;			// Additional offsets of doc, 4 sides
	long max_chars_per_line;	// Optional max characters per line, or zero
	long future[PG_FUTURE];		// Reserved for future
	long ref_con;				// App can store whatever
}
pg_doc_info, PG_FAR *doc_ptr;
</code></pre>
<p>NOTE: Some of the fields in <code>pg_doc_info</code> are currently unsupported, some of them are defined in <code>Paige.h</code> but not included above (but exist for future enhancements and extensions).</p>
<p><img src="figs/fig19.jpg" referrerpolicy="no-referrer"></p>
<p>The fields that are currently supported are as follows:</p>
<p><code>attributes</code> — defines special characteristics for the <code>page_area</code> shape. The <code>attributes</code> field applies only to the <code>page_area</code> shape (not <code>vis_area</code> or <code>exclude_area</code>), and it is a set of bits which can be any of the following:</p>
<pre><code>#define V_REPEAT_BIT			0x00000001	// Shape repeats vertically
#define H_REPEAT_BIT			0x00000002	// Shape repeats horizontally
#define BOTTOM_FIXED_BIT		0x00000004	// Shape&#39;s bottom does not grow
#define NO_CONTAINER_JMP_BIT	0x00000010	// Can&#39;t jump containers
#define MAX_SCROLL_ON_SHAPE		0x00000020	// Maximum scroll is on shape
#define NO_CLIP_PAGE_AREA		0x00000040	// Page area does NOT clip text
#define WINDOW_CURSOR_BIT		0x00000400	// Keep cursor in window view
#define COLOR_VIS_BIT			0x10000000	// Page colour covers whole vis_area
</code></pre>
<p><img src="figs/fig20.jpg" referrerpolicy="no-referrer"></p>
<p><code>V_REPEAT_BIT</code> or <code>H_REPEAT_BIT</code> — causes the <code>page_area</code> to &quot;repeat&quot; itself when text overflows the bottom (see section 13.3, <a href='#133-repeating-shapes'>Repeating Shapes</a>).</p>
<p><img src="figs/fig21.jpg" referrerpolicy="no-referrer"></p>
<p><code>BOTTOM_FIXED_BIT</code> — forces the <code>page_area</code>&#39;s bottom to remain the same (otherwise, the bottom is considered infinite or &quot;variable&quot; as text grows or shrinks).</p>
<p><strong>NOTE:</strong> This bit should be set for implementing &quot;containers.&quot; See chapter 14, <a href='#14-containers-support'>Containers Support</a>.</p>
<p><code>NO_CONTAINER_JMP_BIT</code> — causes text to stay within one rectangle of the shape unless a container break character is encountered. (The usual purpose of setting this mode is for &quot;form&quot; documents and other matrix formats in which text can&#39;t leave a &quot;cell&quot; unless explicitly tabbed to do so).</p>
<p><code>MAX_SCROLL_ON_SHAPE</code> — causes HERMES Paige to compute the maximum vertical scrolling values by the bottom-most rectangle in the page area (as opposed to the bottom-most text position).</p>
<p><strong>NOTE:</strong> This bit should be set for implementing &quot;containers.&quot; See chapter 14, <a href='#14-containers-support'>Containers Support</a>.</p>
<p><code>NO CLIP_PAGE_AREA</code> — causes text drawing to be clipped to the page area. Normally, text is only clipped to the vis area. If this bit is set, it is clipped to the intersection of vis area and page area.</p>
<p><strong>NOTE:</strong> You generally want this bit set for &quot;containers&quot; and/or non-rectangular wrap shapes.</p>
<p>Each attribute is said to be &quot;on&quot; if the bit is set. The default, after <code>pgNew</code>, is all zeros (all clear).</p>
<p><strong>NOTE:</strong> If either &quot;repeat&quot; bit is set, <code>BOTTOM_FIXED_BIT</code> attribute is implied (and assumed) even if <code>BOTTOM_FIXED_BIT</code> is clear. This is because a shape cannot &quot;repeat&quot; unless the bottom is unchangeable.</p>
<p><code>WINDOW_CURSOR_BIT</code> — causes the caret to stay within the <code>vis_area</code> regardless of where the document scrolls.</p>
<p><code>COLOR_VIS_BIT</code> — informs HERMES Paige that the page background colour is one and the same as the window&#39;s background colour. Setting this bit causes all &quot;erased&quot; areas to be painted with the page colour. Usually you want to set this bit to avoid &quot;flashing&quot; during scrolling if your window&#39;s background is non-white and it is the same as the page background color.</p>
<p><code>repeat_slop</code> — defines the minimum amount of vertical space, in pixels, remaining at the end of a document before the page shape repeats (new page “appended”). Used for repeating shapes only.</p>
<p><code>exclusion_inset</code> — defines the amount to inset each exclusion rectangle for clipping. For example, if <code>exclusion_inset</code> were -1, each exclusion rectangle would be expanded 1 pixel larger before being subtracted from the clipped text display.</p>
<p><code>caret_width_extra</code> — defines the width of the caret, in pixels. The default is 1.</p>
<p><code>scroll_inset</code> — defines the amount to inset the <code>vis_area</code> when scrolling. For example, if <code>scroll_inset</code> were 1, a call to <code>pgScroll()</code>would visually scroll the <code>vis_area</code> minus 1 pixel on all four sides.</p>
<p><code>minimum_widow</code> — defines the minimum number of lines that can exist at the end of a page, otherwise the paragraph breaks to the next page.</p>
<p><code>minimum_orphan</code> — defines the minimum number of lines that can exist at the beginning of a new page, otherwise the whole paragraph breaks to the new page.</p>
<p><code>repeat_offset</code> — defines the distance or &quot;gap&quot; to place between repeated shapes (see section 13.3, <a href='#133-repeating-shapes'>Repeating Shapes</a>).</p>
<p><code>num_pages</code> — contains the current &quot;number of pages,&quot; which is really the number of times the shape will repeat itself if the whole document was displayed.</p>
<p><strong>NOTE:</strong> This is not necessarily the number of physical pages that should be printed!</p>
<p>Repeating shapes can have &quot;blank&quot; pages due to the slop value on a nearly-filled page causing a new repeat. For correct printing, see pgPrintToPage.</p>
<p>ref_con — Can contain anything you want.</p>
<p><strong>TODO:</strong> Currently, <code>page_origin</code>, <code>print_target</code> and <code>margins fields</code> are not supported but are provided for future enhancements and extensions.</p>
<h3 id='tech-note-continuous-document'>TECH NOTE: Continuous document</h3>
<blockquote><p>The example demos had spacing above the document that I couldn&#39;t get rid of. I&#39;m interested in some of the &quot;multimedia&quot; features of HERMES Paige, but I want a &quot;streaming&quot; document (no margins/headers/footers spaces). How do I get rid of the spacing so that all of the document is one long stream of data?</p>
</blockquote>
<p>By &quot;spacing&quot; I assume you mean the white space between page breaks. We simply chose to implement the demo this way, with the &quot;repeating shape&quot; feature in HERMES Paige. Using this implementation, the pages show exactly as they will appear when printed, i.e. with all the paper margins in each side including top/bottom.</p>
<p>Some developers like to implement documents that way, yet some prefer the method that you mention (as one continuous &quot;page&quot;). To do one continuous page, one simply does not implement the &quot;repeating shape,&quot;; non-repeating shapes is actually the default mode. You can examine non-repeating shapes in our &quot;Simple Demo&quot; for Macintosh</p>
<p>For information on page breaks in a continuous document see technical note <a href='#tech-note-artificial-page-breaks'>Artificial page breaks</a>.</p>
<h3 id='tech-note-relationship-of-pagearea-visarea-and-clipping-regions-clarified'>TECH NOTE: Relationship of <code>page_area</code>, <code>vis_area</code> and clipping regions clarified</h3>
<blockquote><p>I am having difficulty setting the appropriate attributes to make my document behave in a certain way...[etc.].</p>
</blockquote>
<p>It is important to understand the relationship between the <code>vis_area</code>, <code>page_area</code>, and the various attribute bits in a <code>pg_ref</code> thăt might affect the behavior of both shapes (by <code>attribute bits</code> is meant the value(s) originally given to the <code>flags</code> parameter for <code>pgNew</code> and/or new attribute settings given in <code>pgSetAttributes</code>) and/or the attributes set in <code>pg_doc_info</code>.</p>
<p>The most essential difference between a <code>pg_ref</code>&#39;s page area versus <code>vis_area</code> is the <code>page_area</code> is the &quot;container&quot; in which text will wrap, while its vis area simply becomes the document&#39;s clipping region.</p>
<p>Generally, the <code>vis_area</code> remains constant and unchanging, whereas the <code>page_area</code>, particularly its bottom, can change dynamically as text is inserted or deleted, depending on the attribute flags that are set in the <code>pg_ref</code>. The following is the expected behaviour of the page_area when different attribute flags are set in the <code>pg_ref</code>:</p>
<h4 id='table-4-expected-behaviour-of-pagearea-attributes'>Table 4: Expected behaviour of <code>page_area</code> attributes</h4>
<figure class='table-figure'><table>
<thead>
<tr><th style='text-align:left;' >ATTRIBUTE BITS</th><th style='text-align:left;' ><code>page_area</code> BEHAVIOUR</th><th style='text-align:left;' >CLIPPING</th></tr></thead>
<tbody><tr><td style='text-align:left;' >no bits set (default)</td><td style='text-align:left;' >Bottom grows/shrinks dynamically as text is inserted or deleted (see notes below).</td><td style='text-align:left;' >All drawing is clipped to intersection of <code>vis_area</code> and the window&#39;s current clip region.</td></tr><tr><td style='text-align:left;' ><code>BOTTOM_FIXED_BIT</code></td><td style='text-align:left;' >Bottom remains constant, never changes regardless of the text content</td><td style='text-align:left;' >All drawing is clipped to intersection of <code>vis_area</code>, <code>page_area</code> and the window&#39;s current clip region.</td></tr><tr><td style='text-align:left;' ><code>NO_WINDOW_VIS_BIT</code></td><td style='text-align:left;' >No effect</td><td style='text-align:left;' >Same as above except window&#39;s clip region <em>is not</em> included in the clip region</td></tr><tr><td style='text-align:left;' ><code>EX_DIMENSION_BIT</code> (<code>pgNew()</code> flag)</td><td style='text-align:left;' >No effect visually, but the total height of the doc&#39;s contents include the exclusion area shape (otherwise the exclusion area is not considered part of the document&#39;s dimensions).</td><td style='text-align:left;' >No effect visually</td></tr><tr><td style='text-align:left;' ><code>COLOR_VIS_BIT</code></td><td style='text-align:left;' >No additional effect (but <code>vis_area</code> is erased with the background colour)</td><td style='text-align:left;' >No effect visually</td></tr><tr><td style='text-align:left;' ><code>V_REPEAT_BIT</code></td><td style='text-align:left;' >Shape automatically repeats when text fills to its bottom, achieving multiple page effect.</td><td style='text-align:left;' >Each repeating shape intersects with clip region</td></tr><tr><td style='text-align:left;' ><code>NO_CLIP_REGION</code></td><td style='text-align:left;' >No effect</td><td style='text-align:left;' >No clipping is set at all (the application must set the clipping area)</td></tr></tbody>
</table></figure>
<h5 id='notes-16'>NOTES</h5>
<p>On default behaviour (when no attributes have been set):</p>
<ol start='' >
<li>In the default mode, the <code>page_area</code>&#39;s bottom is said to grow dynamically to enclose the total height of text. In this case, the bottom of the <code>page_area</code> originally given to <code>pgNew</code> is essentially ignored; the page area&#39;s <em>top</em>, however, is not ignored, as that defines the precise top position of the first line of text.</li>
<li>When the page area&#39;s bottom is said to &quot;grow&quot; dynamically in the default mode, the shape itself does not actually change, rather HERMES Paige temporarily pretends its bottom matches the text bottom when it paginates or displays. Although the <code>page_area</code> appears to &quot;grow,&quot; any time you might examine the page area shape, its bottom would not be changed from the original dimensions (to get document&#39;s bottom, use <code>pgTotalTextHeight</code> instead).</li>
<li><code>NO_WINDOW_VIS_BIT</code> works only in the Macintosh version and has no effect in the Windows version.</li>

</ol>
<h2 id='132-gettingsetting-document-info'>13.2 Getting/Setting Document Info</h2>
<pre><code>(void) pgGetDocInfo (pg_ref pg, pg_doc_ptr doc_info);
(void) pgSetDocInfo (pg_ref pg, pg_doc_ptr doc_info, pg_boolean inval_text, short draw_mode);
</code></pre>
<p>To obtain the current document info settings for <code>pg</code>, call <code>pgGetDocInfo</code>, and a copy of the document info record will be placed in <code>*doc_info</code>.</p>
<p>To change the document info, call <code>pgSetDocInfo</code> and pass a pointer to the new information. HERMES Paige will copy its contents in <code>pg</code>.</p>
<p>If <code>inval_text</code> is TRUE, HERMES Paige marks all the text in <code>pg</code> as &quot;not paginated,&quot; forcing new word-wrap calculations the next time it paginates the document (which will normally be the next time the contents of <code>pg</code> are drawn).</p>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>typedef enum
{
	draw_none,			// Do not draw at all
	best_way,			// Use most efficient method(s)
	direct_copy,		// Directly to screen, overwrite
	direct_or,			// Directly to screen, &quot;OR&quot;
	direct_xor,			// Directly to screen, &quot;XOR&quot;
	bits_copy,			// Copy offscreen
	bits_or,			// Copy offscreen in &quot;OR&quot; mode
	bits_xor,			// Copy offscreen in &quot;XOR&quot; mode
	bits_emulate_copy	// Copy &quot;fake&quot; offscreen
	bits_emulate_or	// &quot;Fake&quot; offscreen in &quot;OR&quot; mode
	bits_emulate_xor	// &quot;Fake&quot; offscreen in &quot;XOR&quot; mode
};
</code></pre>
<h2 id='133-repeating-shapes'>13.3 Repeating Shapes</h2>
<p>If <code>V_REPEAT_BIT</code> or <code>H_REPEAT_BIT</code> is set in the attributes field of <code>pg_doc_info</code>, the <code>page_area</code> shape will &quot;repeat&quot; itself each time text overflows the bottom. For <code>V_REPEAT_BIT</code>, the shape repeats itself vertically; for <code>H_REPEAT_BIT</code>, the shape repeats itself horizontally (see Figure 15<!-- on page 12-13-->).</p>
<p>However, the shape itself does not physically grow. Instead, HERMES Paige displays the shape repeatedly down the screen, one <em>page</em> at a time. Hence, if you changed <code>page_area</code> to some other shape while one of the <code>repeat</code> bits were on, then all repeating shapes will change to the new shape.</p>
<p>The simplest application of the <code>repeat</code> bits is to provide a page rectangle (in original <code>page_area</code>), then as the document grows multiple &quot;pages&quot; are added.</p>
<p>Note that the term <code>page</code> is used here to describe a logical section of a document: the original shape does not really need to be a <code>page</code> rectangle, rather it could be a set of columns or any non-rectangular shape. In any event, the entire shape <code>repeats</code> itself each time text fills it up.</p>
<p>For such a feature, if you require a &quot;gap&quot; (page break area), you can do so by setting <code>repeat_offset</code> in <code>pg_doc_info</code> to a non-zero value. This is the amount, in pixels, to add between repeated shapes. Note that <code>repeat_offset</code> is a <code>co_ordinate</code>. This means you can specify both a vertical and horizontal displacement for repeated shapes (a horizontal displacement + vertical displacement would cause a &quot;staircase&quot; effect).</p>
<p>If the shape is to repeat vertically, each occurrence of the shape falls below the last one; for horizontal repeating, each occurrence falls to the right of the last one. The &quot;gap&quot; (<code>repeat_offset</code>), however, is added to the appropriate corresponding sides:</p>
<p><code>repeat_offset.v</code> always displaces the repeating shape vertically and <code>repeat_offset.h</code> always displaces horizontally, regardless of whether <code>V_REPEAT_BIT</code> or <code>H_REPEAT_BIT</code> is set.</p>
<p>The purpose of the <code>repeat_slop</code> field is to append a repeated shape before text actually fills the entire shape.</p>
<p>For example, many applications prefer a new &quot;page&quot; to become available when text is almost filled to the bottom of the last page. The value you place in <code>repeat_slop</code> is used for this purpose, and is used by HERMES Paige as follows: once the bottom of text + <code>repeat_slop</code> ≥ the shape&#39;s bottom, the shape is repeated.</p>
<h5 id='notes-17'>NOTES</h5>
<ol start='' >
<li>Only the text bottom is measured against the shape, not the right or left sides. Even if you set <code>H_REPEAT_BIT</code>, a shape only repeats when text BOTTOM + <code>repeat_slop</code> hits or surpasses the shape&#39;s bottom.</li>
<li>Only one of <code>H_REPEAT_BIT</code> or <code>V_REPEAT_BIT</code> should ever be set at a time (the shape will not repeat both ways).</li>

</ol>
<p>For more details on how HERMES Paige paginates, see chapter 37, <a href='#37-advanced-text-placement'>Advanced Text Placement</a>.</p>
<h3 id='tech-note-artificial-page-breaks'>TECH NOTE: Artificial page breaks</h3>
<blockquote><p>I am doing my word processor similar to MS Word. I put in a page break and draw my line dividing the pages. But when I go to print, HERMES Paige draws a single page, the text does not break to the next page.</p>
</blockquote>
<p>The only real problem is if a <code>pg_ref</code> has no repeating shapes (or containers), a page break char has no place to &quot;jump.&quot; Well, then during printing—just before <code>pgPrintToPage</code>—all one needs to do is set repeating shapes, then print. When printing is done, restore non-repeating shapes. That will cause HERMES Paige to work &quot;correctly.&quot;</p>
<p>But when you want to go to page view mode, you should then switch to repeating shapes, just as the above note does for printing. That will help solve your problem.</p>
<p>Note that in a long document, anything exceeding 10 pages, finding a page will require pagination which the user wili probably notice. This is why word includes a &quot;Paginate Now&quot; menu item in the menu! You will probably want to paginate once and then I believe <code>pgFindPage</code> should work more quickly. If you don&#39;t allow HERMES Paige to paginate, it can&#39;t know which character is the top of the page! HERMES Paige (and all other word processors that display WYSIWYG pages) will have to repaginate to find the positions of the first character on the page. HERMES Paige currently performs many tricks and second guessing on when and how to calculate those positions.</p>
<p>Please note that HERMES Paige cannot make the same assumptions as Word on <em>when</em> to perform those calculations. We must sometimes rely on the developer to know when to perform the pagination.</p>
<h2 id='134-repeating-shapes-examples'>13.4 Repeating shapes examples</h2>
<p>In Figure 13<!-- on page 12-10-->, the initial <code>page_area</code> shape contains text which is within the bounds of the shape. Once text overflows the bottom, the shape is repeated and placed at <code>repeat_offset.v</code> pixels down and <code>repeat_offset.h</code> pixels across.</p>
<p><img src="figs/fig22.jpg" referrerpolicy="no-referrer"></p>
<p>The next illustration shows what happens when <code>repeat_stop</code> is nonzero. In this example, <code>repeat_stop</code>&#39;s value is added to the bottom of the text and, if the result overflows the shape&#39;s bottom, the shape is repeated. This provides an &#39;extra page&#39; to get added before the text completely fills the page shape.</p>
<h5 id='figure-23-the-shape-when-text-gets-below-the-repeatstop-value'>Figure 23. The shape when text gets below the <code>repeat_stop</code> value.</h5>
<p><img src="figs/fig23.jpg" referrerpolicy="no-referrer"></p>
<p>A repeating shape can actually be any shape and does not need to be a &quot;page&quot; rectangle. Figure 17<!-- on page 12-15--> shows an example of &quot;columns&quot; repeating for each &quot;page.&quot;</p>
<p><img src="figs/fig24.jpg" referrerpolicy="no-referrer"></p>
<h2 id='135-shape-repeat-deletions'>13.5 Shape Repeat Deletions</h2>
<p>Repeated shapes will &quot;delete&quot; themselves if text shrinks above the repeated shape.</p>
<p>For example, if text filled up &quot;page 1&quot; causing a &quot;page 2&quot; to be created, deleting all the text will effectively delete &quot;page 2.&quot;</p>
<h2 id='136-widows-and-orphans'>13.6 Widows and Orphans</h2>
<p>HERMES Paige supports &quot;widow and orphan&quot; control, to a certain extent. When lines are computed to flow within repeating shapes (multiple &quot;pages&quot;), whenever <code>pg_doc_info.minimum_widow</code> is non-zero, HERMES Paige will force a whole paragraph to the next page if its number of lines on the bottom of the page are equal to or less than minimum_widow.</p>
<p>Similarly, if <code>pg_doc_info.minimum_orphan</code> is non-zero, the whole paragraph is forced to the next page if its number of lines already breaking to the next page are less than or equal to minimum_orphan.</p>
<h2 id='137-header--footer-support'>13.7 Header &amp; Footer Support</h2>
<p>While HERMES Paige does not directly support &quot;headers and footers,&quot; a number of functions are provided to implement them more easily.</p>
<h3 id='page-modify-hook'>Page modify hook</h3>
<p>This &quot;hook&quot; allows an application to temporarily modify the top, left, right and bottom margins of a &quot;page&quot; before pagination occurs. This is useful for header/footer/footnote support since temporary &quot;exclusion&quot; areas can be tailored for any specific page—and without actually modifying the exclusion shape itself.</p>
<pre><code>PG_PASCAL (void) page_modify_proc) (paige_rec_ptr pg, long page_num, rectangle_ptr margins);
</code></pre>
<p>The above is the prototype for <code>page_modify</code>. This is a general HERMES Paige hook (not a style hook). When this gets called, <code>page_num</code> will indicate a <em>zero-indexed</em> page number and margins will point to a &quot;rectangle&quot; that represents four margins.</p>
<p>HERMES Paige calls this hook for every page that it &quot;paginates.&quot; Note that the margins rectangle is not actually <code>rectangle</code>, rather it represents four margin values to add to the top or left, and/or subtract from bottom or right. Normally, these values will be zero (no extra margins); but if you wanted to remove, say, 16 pixels of space from the bottom of the page, you would set <code>margins -&gt; bot_right.v</code> to 16.</p>
<p>Each time this function is called, all four &quot;margins&quot; are cleared to zero (the default). Hence if your function does nothing, the page remains the original size.</p>
<p>This hook is also very useful for alternating &quot;gutters,&quot; i.e. extra space on the right side for odd pages and the same extra space on the left side for even pages, etc.</p>
<p><strong>CAUTION:</strong> The top and bottom of the page can be modified randomly, i.e. each page can be different. Modifying left and/or right sides, however, must result in the same width for all pages. For example, you should not modify the left or right sides of page 1 but leave page 2&#39;s left or right side alone; it is OK to alternate sides as they are modified as long as the distance between left and right edges remain the same.</p>
<p>For additional information, see also chapter 27, <a href='#27-customising-hermes-paige'>Customising HERMES Paige</a>.</p>
<pre><code>void pgTextboxDisplay (pg_ref pg, paige_rec_ptr target_pg, rectangle_ptr target_box, rectangle_ptr wrap_rect, short draw_mode);
</code></pre>
<p>The above function is useful for drawing a <code>pg_ref</code> to any arbitrary location; the text will move (and optionally wrap) to a specified target location regardless of where its &quot;normal&quot; coordinates exist.</p>
<p><strong>PURPOSE:</strong> Since most applications that implement headers and footers use <code>pg_ref</code>s for a &quot;header&quot; or &quot;footer&quot;, this new function exists for header/footer utilities.</p>
<p>If <code>target_pg</code> is not null, the drawing occurs to the graphics device attached to that HERMES Paige record; otherwise the drawing occurs to the device attached to <code>pg</code>. Note there are two usual ways to obtain a <code>paige_rec_ptr</code>: the first is from a low-level hook, in which case the <code>paige_rec_ptr</code> is usually one of its parameters. The second way is to do <code>UseMemory(pg_ref)</code> and then <code>UnuseMemory(pg_ref)</code> when you are done using the <code>paige_rec_ptr</code>.</p>
<p>The <code>target_box</code> parameter is a pointer to a rectangle which defines bounding &quot;box&quot; in which to draw the text. This rectangle defines the top-left position of the drawing as well as the clipping region. Text <em>will not</em> rewrap into this shape; rather, it repositions its text to align with the box&#39;s top-left coordinate, and <code>target_box</code> also becomes the clipping region.</p>
<p>The <code>wrap_rect</code> parameter is a pointer to an optional, temporary &quot;page <code>rect</code>&quot; for the text to wrap. If this is a null pointer, the <code>page_area</code> is used within <code>pg</code> (the source <code>pg_ref</code>).</p>
<p>The <code>draw_mode</code> is identical to all other functions that accept a drawing mode.</p>
<p>HERMES Paige supports several other page finding and setting commands. These are closely aligned with printing. These are shown in sections 16.6, <a href='#166-computing-pages'>Computing Pages</a> , and 16.7, <a href='#167-skipping-pages'>Skipping Pages</a>. Custom page display techniques are described in section 16.9, <a href='#169-display-proc'>Display Proc</a>.</p>
<h1 id='14-containers-support'>14 CONTAINERS SUPPORT</h1>
<p>HERMES Paige has some built-in support for this purpose by providing several functions to insert, delete and change a list of rectangles that constitute <code>page_area</code>, as well as the ability to attach an application-defined reference to each &quot;container&quot; of the shape.</p>
<p>The term <em>container</em> is used to describe a rectangular portion of the <code>page_area</code>. For an application to support page-layout text containers, the typical method is to build the <code>page_area</code> (the shape in a <code>pg_ref</code> in which text will flow) with the desired series of rectangles.</p>
<h2 id='141-setting-up-for-containers'>14.1 Setting Up for &quot;Containers&quot;</h2>
<p>By default, a <code>pg_ref</code> will not necessarily handle containers the way you might expect without first setting the appropriate values in <code>pg_doc_info</code>.</p>
<p>Before using any of the functions below, you should set <em>at least</em> the <code>BOTTOM_FIXED_BIT</code> and <code>MAX_SCROLL_ON_SHAPE</code> bits using <code>pgSetDocInfo</code>.</p>
<p>These bits are not set by default, so you should set them soon after <code>pgNew</code> and before inserting or displaying a <code>pg_ref</code> with &quot;containers&quot;. For more information about <code>pgSetDocInfo</code> see section 13.2, <a href='#132-gettingsetting-document-info'>Getting/Setting Document Info</a>.</p>
<h3 id='setting-up-for-containers'>Setting up for containers</h3>
<pre><code>void setup_for_containers (pg_ref pg)
{
	pg_doc_info info;
	pgGetDocInfo(pg, &amp;info);
	info.attributes = BOTTOM_FIXED_BIT | MAX_SCROLL_ON_SHAPE;
	pgSetDocInfo(pg, &amp;info, FALSE);
}
</code></pre>
<p>The purpose of <code>BOTTOM_FIXED_BIT</code> is to keep the last rectangle from &quot;growing&quot; along with text.</p>
<p><code>MAX_SCROLL_ON_SHAPE</code> is optional, but will usually be what you want. Normally, HERMES Paige will assume the maximum vertical scrolling position is the same as the bottom-most text position. In a &quot;containers&quot; application, however, that is often undesirable since a document can contain many &quot;empty&quot; containers. By setting <code>MAX_SCROLL_ON_SHAPE</code>, HERMES Paige will find the bottom-most page area rectangle for computing maximum vertical scrolling.</p>
<h2 id='142-setting-and-maintaining-containers'>14.2 Setting and Maintaining &quot;Containers&quot;</h2>
<h3 id='number-of-containers'>Number of containers</h3>
<pre><code>(pg_short_t) pgNumContainers (pg_ref pg); 
</code></pre>
<p>Returns the number of &quot;containers&quot; currently in <code>pg</code>. This function actually returns the number of rectangles in the page area. Initially, after <code>pgNew</code>, the answer will be however many rectangles were contained in the initial page_area shape, which will be at least one rectangle.</p>
<h3 id='inserting-containers'>Inserting containers</h3>
<pre><code>(void) pgInsertContainer (pg_ref pg, rectangle_ptr container, pg_short_t position, long ref_con, short draw_mode);
</code></pre>
<p>This makes a copy of the rectangle pointed to by <code>container</code> and inserts it into <code>pg</code>&#39;s <code>page_area</code>. Consequently, text will flow within the new shape now including the container rectangle, hence a new &quot;container&quot; is inserted.</p>
<p>Assuming that the current page area shape is a series of rectangles, from 1 to <em>n</em>, the new rectangle is inserted after the rectangle number in the <code>position</code> parameter. However, if <code>position</code> is zero, the new container is inserted at the beginning (becomes first rectangle in the shape). If <code>position</code> is <code>pgNumContainers(pg)</code>, it is inserted as the very last rectangle.</p>
<p>You can also &quot;attach&quot; any long-word value (such as a pointer or some other reference) to the new &quot;container&quot; by passing that value in <code>ref_con</code>. Consequently, you can access this value at any time using <code>pgGetContainerRefCon</code> (see <a href='#container-refcon'>Container refCon</a> under section 14.2).</p>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>typedef enum
{
	draw_none,			// Do not draw at all
	best_way,			// Use most efficient method(s)
	direct_copy,		// Directly to screen, overwrite
	direct_or,			// Directly to screen, &quot;OR&quot;
	direct_xor,			// Directly to screen, &quot;XOR&quot;
	bits_copy,			// Copy offscreen
	bits_or,			// Copy offscreen in &quot;OR&quot; mode
	bits_xor,			// Copy offscreen in &quot;XOR&quot; mode
	bits_emulate_copy	// Copy &quot;fake&quot; offscreen
	bits_emulate_or	// &quot;Fake&quot; offscreen in &quot;OR&quot; mode
	bits_emulate_xor	// &quot;Fake&quot; offscreen in &quot;XOR&quot; mode
};
</code></pre>
<p><strong>NOTE:</strong> The position parameter is not checked for validity! Make sure it is within the boundaries between 0 and <code>pgNumContainers(pg)</code> or a crash can result. (Also note that the other container functions given here require that the range be between 1 and <code>pgNumContainers</code>; only in <code>pgInsertContainer</code> can position be zero).</p>
<h3 id='getting-particular-container'>Getting particular container</h3>
<pre><code>void pgGetContainer (pg_ref pg, pg_short_t position, pg_boolean include_scroll, pg_boolean include_scale, rectangle_ptr container);
</code></pre>
<p>Returns the &quot;container&quot; rectangle defined by the position parameter. This can be any of the rectangles contained in <code>pg</code>&#39;s page area, from 1 to <code>pgNumContainers(pg)</code>. The rectangle is copied to the structure pointed to by the container parameter.</p>
<p>If <code>include_scroll</code> is TRUE, the container returned will be in its &quot;scrolled&quot; position (as it would appear on the screen). If <code>include_scale</code> is TRUE, the container returned will be scaled to the appropriate dimensions (based on the scaling factor in <code>pg</code>).</p>
<p>range-checking on position is not performed. Make sure it is a valid rectangle number.</p>
<h3 id='container-refcon'>Container <code>refCon</code></h3>
<pre><code>(long) pgGetContainerRefCon (pg_ref pg, pg_short_t position);
(void) pgSetContainerRefCon (pg_ref pg, pg_short_t position, long ref_con);
</code></pre>
<p>The application-defined reference that is &quot;attached&quot; to container <code>position</code> is returned from <code>pgGetContainerRefCon</code>; you can also set this value using <code>pgSetContainerRefCon</code>.</p>
<p>Range-checking on <code>position</code> is not performed. Make sure it is a valid rectangle number.</p>
<p><strong>NOTE:</strong> HERMES Paige does not know what you have set in <code>ref_con</code>, hence if you have set some kind of memory structure it is your responsibility to dispose of it before <code>pg</code> Dispose.</p>
<h3 id='143-changing-containers'>14.3 Changing Containers</h3>
<pre><code>(void) pgRemoveContainer (pg_ref pg, pg_short_t position, short draw_mode);
</code></pre>
<p>Deletes the rectangle of the <code>page_area</code> given in position. This value must be between 1 (first rectangle) and <code>pgNumContainers(pg)</code>. Range-checking on <code>position</code> is not performed.</p>
<p><strong>CAUTION:</strong> Never delete the last (and only) &quot;container.&quot; HERMES Paige does not check for this situation, and by deleting the only container you will essentially have no area for the text to flow!</p>
<p><strong>CAUTION:</strong> If you have set a <code>ref_con</code> value attached to the container to be deleted, it is gone forever after calling this function. It is your responsibility to do whatever is appropriate prior to deleting the container, such as disposing any memory structures involved with the <code>refCon</code> value, etc.</p>
<pre><code>(void) pgReplaceContainer (pg_ref pg, rectangle_ptr container, pg_short_t position, short draw_mode);
</code></pre>
<p>Replaces container defined in <code>position</code> with the rectangle given in <code>container</code>. Note that only the rectangle in the page area is replaced; the <code>refCon</code> value will remain intact—unless you change it with <code>pgSetContainerRefCon</code>.</p>
<p>This is the function to use to change a container&#39;s dimensions, be it dragging, resizing, etc.</p>
<pre><code>(void) pgSwapContainers (pg_ref pg, pg_short_t container1, pg_short_t container2, short draw_mode);
</code></pre>
<p>The two containers defined by <code>container1</code> and <code>container2</code> &quot;trade places.&quot; This function is therefore useful for &quot;bring to front&quot; and &quot;send to back&quot; features.</p>
<p>The associated <code>refCon</code> values for <code>container1</code> and <code>container2</code> are also reversed; i.e., both rectangles and attached <code>refCons</code> are swapped.</p>
<p><strong>CAUTION:</strong> Range-checking is not performed. Ensure that <code>container1</code> and <code>container2</code> are valid rectangle numbers, between 1 and <code>pgNumContainers(pg)</code>.</p>
<h5 id='note-24'>Note</h5>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>typedef enum
{
	draw_none,			// Do not draw at all
	best_way,			// Use most efficient method(s)
	direct_copy,		// Directly to screen, overwrite
	direct_or,			// Directly to screen, &quot;OR&quot;
	direct_xor,			// Directly to screen, &quot;XOR&quot;
	bits_copy,			// Copy offscreen
	bits_or,			// Copy offscreen in &quot;OR&quot; mode
	bits_xor,			// Copy offscreen in &quot;XOR&quot; mode
	bits_emulate_copy	// Copy &quot;fake&quot; offscreen
	bits_emulate_or	// &quot;Fake&quot; offscreen in &quot;OR&quot; mode
	bits_emulate_xor	// &quot;Fake&quot; offscreen in &quot;XOR&quot; mode
};
</code></pre>
<h2 id='144-clicking-and-character-support'>14.4 &quot;Clicking&quot; and Character Support</h2>
<h3 id='point-within-container'>Point within container</h3>
<pre><code>(pg_short_t) pgPtInContainer (pg_ref pg, co_ordinate_ptr point, co_ordinate_ptr inset_extra);
</code></pre>
<p>Returns the container rectangle containing <code>point</code>, if any.</p>
<p>If <code>inset_extra</code> is non-NULL, every rectangle in the page area is first inset by <code>inset_extra -&gt; h</code> and <code>inset_extra -&gt; v</code> values before it is checked for containing point. Negative inset values expand the rectangle outwards, and positive numbers shrink the rectangle.</p>
<p>The usual purpose of <code>inset_extra</code> is to detect a certain amount of &quot;slop&quot; when looking for a mouse-click within a container. For example, if you want a container-click detection within four pixels of each container&#39;s edges, pass <code>inset_extra</code> as a pointer to a <code>co_ordinate</code> of (-4, -4).</p>
<p><strong>FUNCTION RESULT:</strong> If no container contains point, zero is returned. Otherwise, the container number is returned (which will always be between 1 and <code>pgNumContainers(pg)</code>).</p>
<p><strong>NOTE:</strong> Both scrolled position and scaling are taken into consideration by this function. In other words, container rectangles will be checked as they appear on the screen.</p>
<h3 id='character-within-container'>Character within container</h3>
<pre><code>(pg_short_t) pgCharToContainer (pg_ref pg, long offset);
</code></pre>
<p>Returns the container number, from 1 to <code>pgNumContainers(pg)</code>, containing the specified text offset. The <code>offset</code> parameter is relative to the start of all text and is a byte offset; it must be between 0 and <code>pgTextSize(pg)</code>.</p>
<p>However, <code>offset</code> can also be <code>CURRENT_POSITION</code> (<code>#define</code>d as -1) which will return the container number for the current insertion point (or the starting selection point if there is a highlight range).</p>
<pre><code>(long) pgContainerToChar(pg_ref pg, pg_short_t position);
</code></pre>
<p>Returns the text offset of the first character that exists in container number <code>position</code>. This function is useful to locate the first character within a container.</p>
<p>However, it is possible that the container has no text at all (text is not large enough to fill all containers), in which case the function result will be -1.</p>
<p>The <code>position</code> parameter must be between 1 and <code>pgNumContainers(pg)</code>.</p>
<p><strong>CAUTION:</strong> Range-checking is not performed!</p>
<h3 id='tech-note-containers-v-repeating-shapes'>TECH NOTE: Containers v. Repeating Shapes</h3>
<blockquote><p>How expensive is containers support in general, compared to repeating shapes?</p>
</blockquote>
<p>Repeating shapes are light-years faster, because they don&#39;t really &quot;repeat,&quot; at least not physically. All a repeating shape does is repeat its display. If you have, say, a single-<code>rect</code> shape, if it is repeating that shape remains a single <code>rect</code> even if the doc repeats a million times.</p>
<p>Containers, on the other hand, consist of a physical array of rectangles. So that&#39;s one big difference—if a single <code>rect</code> repeats 100 times, the &quot;containers&quot; method will have 100 rectangles; a repeating shape of course has just one.</p>
<p>&quot;Repeating&quot; is fastest because HERMES Paige only has to consider one rectangle—and relative positions thereof. On the other hand, when computing word-wrapping within containers, HERMES Paige must continuously walk through <em>all</em> <code>rect</code>s to see which ones intersect the text line, etc. So the processing is much more extensive in this case.</p>
<p>The general rule is: If your shape, regardless of its complexity, must literally &quot;repeat&quot; in its exact form, then use <em>repeating shapes</em>. If your shape does not necessarily repeat as-is—or if the reoccurrence of the shape can be slightly different than the previous occurrence, then you are forced to use containers.</p>
<h1 id='15-exclusion-areas'>15 EXCLUSION AREAS</h1>
<p>An HERMES Paige &quot;exclusion&quot; area is typically used for page layout features in which text will wrap around one or more rectangles, including complex shapes (which are also a series of small rectangles).</p>
<h2 id='151-setting--maintaining-exclusions'>15.1 Setting &amp; Maintaining Exclusions</h2>
<p>As in HERMES Paige&#39;s &quot;container&quot; support in the previous chapter, several functions are provided to insert, delete and change the series of rectangles in the exclude shape of an HERMES Paige object.</p>
<h3 id='number-of-exclusions'>Number of exclusions</h3>
<pre><code>(pg_short_t) pgNumExclusions (pg_ref pg);
</code></pre>
<p>Returns the number of exclusion rectangles currently in <code>pg</code>. This function actually returns the number of rectangles in the exclude area. Initially, after <code>pgNew</code>, the answer will be however many rectangles were in your <code>exclude_area</code> shape, if any.</p>
<p>Unlike <code>pgNumContainers</code>, it is possible (and often likely) to have zero exclusion rectangles, so this function can legitimately report zero.</p>
<h3 id='inserting-exclusion'>Inserting exclusion</h3>
<pre><code>(void) pgInsertExclusion (pg_ref pg, rectangle_ptr exclusion, pg_short_t position, long ref_con, short draw_mode);
</code></pre>
<p>This makes a copy of the rectangle pointed to by exclusion and inserts it into <code>pg</code>&#39;s <code>exclude_area</code>. Consequently, text will flow around (will avoid) the new shape now including the exclusion rectangle.</p>
<p>If <code>position</code> is zero, the new exclusion is inserted at the beginning (becomes first rectangle in the shape). If <code>position</code> is <code>pgNumExclusions(pg)</code>, it is inserted as the very last rectangle.</p>
<p>It is possible that the current exclusion area in pg is empty or does not exist; for example, you might have passed a null pointer for <code>exclude_area</code> in <code>pgNew</code>. This function will recognise that situation and will work correctly, building an initial <code>exclude_area</code> if necessary. However, in this situation, the only valid position for insertion is zero.</p>
<p>You can also &quot;attach&quot; any long-word value (such as a pointer or some other reference) to the new <code>exclusion</code> rectangle by passing that value in <code>ref_con</code>. Consequently, you can access this value at any time using <code>pgGetExclusionRefCon</code> (see &quot;Exclusion <code>refCon</code>&quot; on page 15-267).</p>
<p><strong>CAUTION:</strong> The position <code>parameter</code> is not checked for validity! Make sure it is within the boundaries between 0 and <code>pgNumExclusions(pg)</code> or a crash can result.</p>
<pre><code>(void) pgInsertExclusionShape (pg_ref pg, pg_short_t position, shape_ref exclude_shape, short draw_mode);
</code></pre>
<p>Inserts an entire shape into the exclusion area of <code>pg</code>. The list of rectangles within <code>exclude_shape</code> is inserted after rectangle number <code>position</code>; if <code>position</code> is zero, the shape is inserted at the beginning. If <code>position</code> is <code>pgNumExclusions(pg)</code>, the shape is inserted at the end.</p>
<p>If no exclusion area exists in <code>pg</code> prior to this function, the result is essentially the same as <code>pgSetAreas</code> to change or set a new exclusion area.</p>
<p>The contents of <code>exclude_shape</code> are copied, therefore you can dispose <code>exclude_shape</code> any time after calling this function.</p>
<p><strong>NOTE:</strong> Associated <code>ref_con</code> values for all new rectangles will be initialised to zero.</p>
<h5 id='note-25'>Note</h5>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>typedef enum
{
	draw_none,			// Do not draw at all
	best_way,			// Use most efficient method(s)
	direct_copy,		// Directly to screen, overwrite
	direct_or,			// Directly to screen, &quot;OR&quot;
	direct_xor,			// Directly to screen, &quot;XOR&quot;
	bits_copy,			// Copy offscreen
	bits_or,			// Copy offscreen in &quot;OR&quot; mode
	bits_xor,			// Copy offscreen in &quot;XOR&quot; mode
	bits_emulate_copy	// Copy &quot;fake&quot; offscreen
	bits_emulate_or	// &quot;Fake&quot; offscreen in &quot;OR&quot; mode
	bits_emulate_xor	// &quot;Fake&quot; offscreen in &quot;XOR&quot; mode
};
</code></pre>
<h3 id='152-get-exclusion-information'>15.2 Get exclusion information</h3>
<pre><code>(void) pgGetExclusion (pg_ref pg, pg_short_t position, pg_boolean include_scroll, pg_boolean include_scale, rectangle_ptr exclusion);
</code></pre>
<p>Returns the exclusion rectangle defined by the <code>position</code> parameter. This can be any of the rectangles contained in <code>pg</code>&#39;s exclusion area, from 1 to <code>pgNumExclusions(pg)</code>. The rectangle is copied to the structure pointed to by the exclusion parameter.</p>
<p>If <code>include_scroll</code> is TRUE, the rectangle returned will be in its &quot;scrolled&quot; position (as it would appear on the screen). If <code>include_scale</code> is TRUE, the rectangle returned will be scaled to the appropriate dimensions (based on the scaling factor in <code>pg</code> ).</p>
<h5 id='warnings'>Warnings</h5>
<ol start='' >
<li>Range-checking on position is not performed. Make sure it is a valid rectangle number.</li>
<li>Unlike containers, it is possible to have zero exclusion rectangles. You must not call this function if <code>pgNumExclusions = 0</code>.</li>

</ol>
<h2 id='153-exclusion-refcon'>15.3 Exclusion refCon</h2>
<pre><code>(long) pgGetExclusionRefCon (pg_ref pg, pg_short_t position);
(void) pgSetExclusionRefCon (pg_ref pg, pg_short_t position, long ref_con);
</code></pre>
<p>The application-defined reference that is &quot;attached&quot; to exclusion rectangle position is returned from <code>pgGetExclusionRefCon</code>; you can also set this value using <code>pgSetExclusionRefCon</code>.</p>
<h5 id='warnings-2'>Warnings</h5>
<ol start='' >
<li>Range-checking on position is not performed. Make sure it is a valid rectangle number.</li>
<li>HERMES Paige does not know what you have set in <code>ref_con</code>; hence if you have set some kind of memory structure it is your responsibility to dispose of it before <code>pgDispose</code>.</li>

</ol>
<h2 id='154-changing-exclusion-rectangles'>15.4 Changing Exclusion Rectangles</h2>
<h3 id='removing-exclusions'>Removing exclusions</h3>
<pre><code>(void) pgRemoveExclusion (pg_ref pg, pg_short_t position, short draw_mode);
</code></pre>
<p>Deletes the rectangle of the exclusion area given in <code>position</code>. This value must be between 1 (first rectangle) and <code>pgNumExclusions(pg)</code>. Range-checking on <code>position</code> is not performed.</p>
<p><strong>NOTE:</strong> Unlike containers, it is acceptable to delete the last and only exclusion rectangle.</p>
<p><strong>CAUTION:</strong> If you have set a <code>ref_con</code> value attached to the exclusion rectangle to be deleted, it is gone forever after calling this function. It is your responsibility to do whatever is appropriate prior to deleting the exclusion, such as disposing any memory structures involved with the <code>refCon</code> value, etc.</p>
<pre><code>(void) pgReplaceExclusion (pg_ref pg, rectangle_ptr exclusion, pg_short_t position, short draw_mode);
</code></pre>
<p>Replaces exclusion rectangle defined in <code>position</code> with the rectangle given in exclusion.</p>
<p><strong>NOTE:</strong> Only the rectangle in the exclusion area is replaced; unless you change it with <code>pgSetExclusionRefCon</code>, the <code>refCon</code> value will remain intact.</p>
<p>This is the function used to change an exclusion rectangle&#39;s dimensions, be it dragging, resizing, etc.</p>
<h3 id='swapping-exclusions'>Swapping exclusions</h3>
<pre><code>(void) pgSwapExclusions (pg_ref pg, pg_short_t exclusion1, pg_short_t exclusion2, short draw_mode);
</code></pre>
<p>The two exclusion rectangles defined by <code>exclusion1</code> and <code>exclusion2</code> &quot;trade places&quot;. This function is therefor useful for &quot;bring to front&quot; and &quot;send to back&quot; features.</p>
<p>The associated <code>refCon</code> values for <code>exclusion1</code> and <code>exclusion2</code> are also reversed, i.e. both rectangles and attached <code>refCon</code>s are swapped.</p>
<p>CAUTION: Range-checking is not performed. Make sure <code>exclusion1</code> and <code>exclusion2</code> are valid rectangle numbers, between 1 and <code>pgNumExclusions(pg)</code>.</p>
<h5 id='note-26'>Note</h5>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>typedef enum
{
	draw_none,			// Do not draw at all
	best_way,			// Use most efficient method(s)
	direct_copy,		// Directly to screen, overwrite
	direct_or,			// Directly to screen, &quot;OR&quot;
	direct_xor,			// Directly to screen, &quot;XOR&quot;
	bits_copy,			// Copy offscreen
	bits_or,			// Copy offscreen in &quot;OR&quot; mode
	bits_xor,			// Copy offscreen in &quot;XOR&quot; mode
	bits_emulate_copy	// Copy &quot;fake&quot; offscreen
	bits_emulate_or	// &quot;Fake&quot; offscreen in &quot;OR&quot; mode
	bits_emulate_xor	// &quot;Fake&quot; offscreen in &quot;XOR&quot; mode
};
</code></pre>
<h2 id='155-clicking-exclusion-rectangles'>15.5 &quot;Clicking&quot; Exclusion Rectangles</h2>
<pre><code>(pg_short_t) pgPtInExclusion (pg_ref pg, co_ordinate_ptr point, co_ordinate_ptr inset_extra);
</code></pre>
<p>Returns the exclusion rectangle containing <code>point</code>, if any. It is safe to call this function even if there are no exclusion rectangles (in which case <code>pgPtInExclusion</code> will always return zero).</p>
<p>If <code>inset_extra</code> is non-NULL, every rectangle in the exclusion area is first inset by <code>inset_extra -&gt; h</code> and <code>inset_extra -&gt; v</code> values before it is checked for containing <code>point</code>.</p>
<p>Negative inset values expand the rectangle outwards, and positive numbers shrink the rectangle.</p>
<p>The usual purpose of <code>inset_extra</code> is to detect a certain amount of &quot;slop&quot; when looking for a mouse-click within an exclusion area. For example, if you want a click detection within four pixels of each exclusion&#39;s edges, pass <code>inset_extra</code> as a pointer to a <code>co_ordinate</code> of -4, -4.</p>
<p><strong>FUNCTION RESULT:</strong> If no exclusion contains point, or if no exclusion area exists, zero is returned. Otherwise, the exclusion rectangle number is returned (which will always be between 1 and <code>pgNumExclusions(pg)</code>).</p>
<p><strong>NOTE:</strong> Both scrolled position and scaling are taken into consideration by this function. In other words, rectangles will be checked as they appear on the screen.</p>
<h2 id='156-drawing-exclusion-contents'>15.6 Drawing Exclusion Contents</h2>
<p>If your exclusion rectangle(s) contain some type of graphic image you need to draw, the recommended method for doing this is to use the <code>page_proc</code> hook. HERMES Paige calls this &quot;hook&quot; function after drawing each page of text; this is explained in chapter 27, <a href='#27-customising-hermes-paige'>Customising HERMES Paige</a>.</p>
<h2 id='157-attaching-exclusions-to-paragraphs'>15.7 Attaching Exclusions to Paragraphs</h2>
<p>Any exclusion rectangle can be &quot;attached&quot; to the top of a paragraph. First, create the exclusion rectangle, then call the following function:</p>
<pre><code>void pgAttachParExclusion (pg_ref pg, long position, pg_short_t index, short draw_mode)
</code></pre>
<p>The exclusion rectangle is represented by <code>index</code>; this is a value from 1 to <code>pgNumExclusions(pg)</code>.</p>
<p>The paragraph is represented by the <code>position</code> parameter; this is a text position into the document, and the paragraph to which the exclusion rectangle attaches is the paragraph which contains the position.</p>
<p><strong>NOTE:</strong> The text position does not need to be the exact position of a paragraph beginning, rather it can be anywhere within the paragraph (before the carriage return).</p>
<p>The exclusion rectangle, however, &quot;attaches&quot; to the top line of the paragraph regardless of the text position given.</p>
<p>After this function is called, the exclusion rectangle will constantly and dynamically align to the top line of the paragraph even as the text is changed or deleted. If the paragraph is deleted, the exclusion rectangle will still exist but will remain stationary and attached to no paragraph.</p>
<p>Otherwise, the exclusion rectangle is no different than any other exclusion rectangle—text will wrap around the rectangle appropriately, even if that text is part of the paragraph to which the exclusion is attached.</p>
<h5 id='notes-and-warnings'>Notes and Warnings</h5>
<ol start='' >
<li>Only the vertical position of the exclusion rectangle is aligned to the paragraph; its horizontal position will remain unchanged.</li>
<li>Do not attach more than one exclusion rectangle to the same paragraph or unexpected erroneous results will occur.</li>

</ol>
<p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11. The document will redraw in its entirety if any <code>draw_mode</code> but <code>draw_none</code> is selected; otherwise, the document will not redraw at all.</p>
<pre><code>typedef enum
{
	draw_none,			// Do not draw at all
	best_way,			// Use most efficient method(s)
	direct_copy,		// Directly to screen, overwrite
	direct_or,			// Directly to screen, &quot;OR&quot;
	direct_xor,			// Directly to screen, &quot;XOR&quot;
	bits_copy,			// Copy offscreen
	bits_or,			// Copy offscreen in &quot;OR&quot; mode
	bits_xor,			// Copy offscreen in &quot;XOR&quot; mode
	bits_emulate_copy	// Copy &quot;fake&quot; offscreen
	bits_emulate_or	// &quot;Fake&quot; offscreen in &quot;OR&quot; mode
	bits_emulate_xor	// &quot;Fake&quot; offscreen in &quot;XOR&quot; mode
};
</code></pre>
<h3 id='determining-the-attached-paragraph'>Determining the Attached Paragraph</h3>
<p>To determine if an exclusion rectangle is currently attached to a paragraph, call the following function:</p>
<pre><code>long pgGetAttachedPar(pg_ref pg, pg_short_t exclusion);
</code></pre>
<p>The exclusion rectangle in question is represented by <code>exclusion</code>; this can be any value from 1 through <code>pgNumExclusions(pg)</code>.</p>
<p>This function returns the text position of the paragraph to which the exclusion is attached, if any.</p>
<p>If the exclusion is attached to no paragraph, the function returns -1.</p>
<h1 id='16-scaling-printing--displaying'>16 SCALING, PRINTING &amp; DISPLAYING</h1>
<h2 id='161-scaling'>16.1 Scaling</h2>
<p>An HERMES Paige object can be scaled, which is to say enlarged or reduced by a specified amount.</p>
<p>Scaling, however, must be equal for both vertical and horizontal dimensions.</p>
<p>The scaling factor is maintained by HERMES Paige using the following record:</p>
<pre><code>typedef struct
{
	co_ordinate origin;	// Relative origin
	pg_fixed scale;		// Scaling (hiword/loword fraction)
}
pg_scale_factor, PG_FAR *pg_scale_ptr;
</code></pre>
<p>The <code>origin</code> field <em>supra</em> contains the origin point to compute scaling. Generally, this should be the top-left point of your overall <code>page_area</code> (text flow area). The purpose of the <code>origin</code> value is for HERMES Paige to know what scaling is relative to, or stated more simply, what is the top-left point of the entire area that is being scaled.</p>
<p>The <code>scale</code> field is a <code>long</code> whose high-order and low-order words define a numerator and denominator. Stated as a formula, the <code>scale</code> value is computed as:</p>
<pre><code>high word of (scale) / low word of (scale)
</code></pre>
<p>Hence, if scale is 0x00020001, scaling is 2-to-1 (<code>2 / 1</code>); if scale is 0x00010002, then scaling is 1-to-2 (<code>1 / 2</code>), etc.</p>
<p>If the scale value is zero, that is interpreted as no scaling (same as <code>1 / 1</code>).</p>
<h2 id='162-scaling-a-hermes-paige-object'>16.2 Scaling a HERMES Paige Object</h2>
<pre><code>(void) pgSetScaling (pg_ref pg, pg_scale_ptr scale_factor, short draw_mode);
</code></pre>
<p>This sets the scaling for <code>pg</code>. The scale_factor parameter must be a pointer to a <code>pg_scale_factor</code> <em>supra</em>; it cannot be a null pointer. From that moment on, <code>pg</code> will display and edit in the specified scaled amount.</p>
<p>To obtain the current scaling factor, call:</p>
<pre><code>(void) pgGetScaling (pg_ref pg, pg_scale_ptr scale_factor);
</code></pre>
<p>The scaling factor of <code>pg</code> is returned in the <code>pg_scale_factor</code> pointed to by <code>scale_factor</code> (which cannot be null).</p>
<h5 id='notes-18'>Notes</h5>
<ol start='' >
<li>HERMES Paige makes a copy of your <code>scale_factor</code>, so it does not need to remain static.</li>
<li>On <em>Macintosh</em> only, scaling text may be inaccurate for environments that do not support Color QuickDraw.</li>
<li><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11. If <code>draw_mode</code> is not <code>draw_none</code>, the text is redrawn in the new scale. </li>

</ol>
<p>-</p>
<pre><code>typedef enum
{
	draw_none,			// Do not draw at all
	best_way,			// Use most efficient method(s)
	direct_copy,		// Directly to screen, overwrite
	direct_or,			// Directly to screen, &quot;OR&quot;
	direct_xor,			// Directly to screen, &quot;XOR&quot;
	bits_copy,			// Copy offscreen
	bits_or,			// Copy offscreen in &quot;OR&quot; mode
	bits_xor,			// Copy offscreen in &quot;XOR&quot; mode
	bits_emulate_copy	// Copy &quot;fake&quot; offscreen
	bits_emulate_or	// &quot;Fake&quot; offscreen in &quot;OR&quot; mode
	bits_emulate_xor	// &quot;Fake&quot; offscreen in &quot;XOR&quot; mode
};
</code></pre>
<h2 id='163-scaling-and-vis-areas'>16.3 Scaling and Vis Areas</h2>
<p>A scaled <code>pg_ref</code> normally does not scale its <code>vis_area</code>. If the attribute flag <code>scale_vis_bit</code> has been set in the <code>pg_ref</code>, the <code>vis_area</code> is scaled, otherwise the <code>vis_area</code> remains unscaled.</p>
<p><strong>Fig. 25 needs redrawn!</strong></p>
<p><code>SCALE_VIS_BIT</code> is usually set when one or more <code>pg_ref</code>s are components of a larger document, not the whole document itself. For example, an object-oriented drawing program using HERMES Paige to show text objects would probably want to set <code>SCALE_VIS_BIT</code> to achieve the rendering as shown in the bottom part of the above example.</p>
<p>A general word-processor window, however, would probably not want <code>SCALE_VIS_BIT</code>; instead, it may be more desirable to leave the <code>vis_area</code> alone, as shown in the top part of the above example.</p>
<h2 id='164-additional-scaling-utilities'>16.4 Additional Scaling Utilities</h2>
<pre><code>(void) pgScaleLong(long scale_factor, long origin, long PG_FAR *value);
(void) pgScalePt(pg_scale_ptr scale_factor, co_ordinate_ptr amount_offset, co_ordinate_ptr pt);
(void) pgScaleRect(pg_scale_ptr scale_factor, co_ordinate_ptr amount_offset, rectangle_ptr rect);
</code></pre>
<p>The three functions above will scale a <code>long</code>, a <code>co_ordinate</code> and a <code>rectangle</code>, respectively.</p>
<p>For <code>pgScaleLong</code>, the <code>scale_factor</code> is only the &quot;scale&quot; part of a complete <code>pg_scale_factor</code> and the <code>origin</code> is the appropriate origin position. The value to scale must be pointed to by value and the value will be scaled when the function returns.</p>
<p>For <code>pgScalePt</code>, the <code>pt</code> parameter gets scaled by the scaling factor in <code>scale_factor</code>; for <code>pgScaleRect</code>, the <code>rect</code> parameter is scaled by <code>scale_factor</code>. For both <code>pgScalePt</code> and <code>pgScaleRect</code>, <code>amount_offset</code> should be a pointer to the amount the document is &quot;scrolled&quot;, or a null pointer if this does not matter.</p>
<p>Usually, <code>amount_offset</code> should be a negative compliment of <code>pgScrollPosition(&amp;offset)</code>, as:</p>
<pre><code>co_ordinate offset;
pg_scale_factor scaling;

pgGetScaling(pg, &amp;scaling);
pgScrollPosition(pg, &amp;offset);
pgNegatePt(&amp;offset);
pgScaleRect(&amp;scaling, &amp;amount, &amp;rect);

(void) pgScaleRectToRect(pg_scale_ptr, scale_factor, rectangle_ptr src_rect, rectangle_ptr target_rect, co_ordinate_ptr offset_extra);
</code></pre>
<p>This function is similar to <code>pgScaleRect</code> except the scaled result of <code>src_rect</code> is placed in <code>target_rect</code>. In addition, <code>src_rect</code> is temporarily offset before being scaled by <code>offset_extra</code> amounts (unless <code>offset_extra</code> is a null pointer).</p>
<h3 id='tech-note-scaling-a-point-inside-a-shape'>TECH NOTE: Scaling a point inside a shape</h3>
<blockquote><p>I was looking through the manual and can&#39;t seem to find any function that scales a whole shape. Am I missing something?</p>
</blockquote>
<p>You are right, HERMES Paige does not have a &quot;scale shape&quot; function, probably because it does not need one internally. That is because nothing inside an HERMES Paige document is ever really &quot;scaled,&quot; it&#39;s all an illusion (only the drawing itself is scaled; all shapes and text positions remain the same at all times).</p>
<p>HERMES Paige locates a mouse point in a scaled document by &quot;reverse scaling&quot; the mouse point. By that I mean it scales the <code>co_ordinate</code> in question the opposite amount that the document is (apparently) scaled.</p>
<p>It&#39;s fairly easy to reverse-scale something. All you do is negate the current scale factor, for example:</p>
<pre><code>scale_factor.scale = -scale_factor.scale;
pgScalePt(&amp;scale_factor, &amp;point);
</code></pre>
<p>This brings up an interesting point. Although I can see that your function to find a point in a scaled shape will work, perhaps a much faster method is to reverse-scale the point instead of scaling the whole shape, then just find the point without the non-scaled shape.</p>
<h2 id='165-printing-support'>16.5 Printing Support</h2>
<p><strong>IMPORTANT:</strong> Do not confuse &quot;pages&quot; in the context of printing with &quot;paging&quot; for repeating shapes. These are two different concepts entirely. Printed pages are simply sections of text; &quot;pages&quot; of repeating shapes are simply repeating display of the same shape, and in fact, might not contain text at all. A printed page and repeating shape page are not necessarily the same dimensions. See section 13.3, <a href='#133-repeating-shapes'>Repeating Shapes</a>.</p>
<p>&quot;Printing&quot; for HERMES Paige is simply an alternate method of displaying its text offset and pinned neatly to a specified &quot;page&quot; rectangle. In itself it knows nothing about printing or printer devices.</p>
<p>The following function is intended to handle most printing requirements:</p>
<pre><code>(long) pgPrintToPage (pg_ref pg, graf_device_ptr target, long starting_position, rectangle_ptr page_rect, short draw_mode); 
</code></pre>
<p>The target parameter is an optional pointer to a graphics device other than <code>pg</code>&#39;s default device (see section 3.4, <a href='#34-graphic-devices'>Graphic Devices</a>).</p>
<p>The <code>starting_position</code> parameter is the text offset, in bytes of the first text that should be printed (this is a zero-indexed number).</p>
<p>The function will draw as much text that can completely fit inside <code>page_rect</code>, starting with <code>starting_position</code> in <code>pg</code>, and drawing the first line relative to <code>page_rect</code>&#39;s top-left. No text will be drawn that does not completely fit vertically inside <code>page_rect</code>, hence no &quot;half lines&quot; will exist at <code>page_rect</code>&#39;s bottom. Horizontal fitting is not checked—see note below.</p>
<p>The effective result of this function is that a &quot;page&quot; of text is drawn to some specified device.</p>
<p>The <code>draw_mode</code> parameter should generally be set to <code>best_way</code>, <code>direct_or</code> or <code>bits_emulate_or</code>.</p>
<p>Highlighting and the &quot;caret&quot; is suppressed when the text is drawn by this function and the current <code>vis_area</code> is ignored (it is temporarily replaced with the dimensions of <code>page_rect</code>).</p>
<p><strong>FUNCTION RESULT:</strong> The function returns the next text position following the last line printed. If no more text is available (all text fit from starting_offset to end of document), zero is returned.</p>
<p>To print consecutive pages, you would print the first page with <code>starting_offset = 0</code>, then call <code>pgPrintToPage</code> again with <code>starting_offset = function result</code>, and continue doing so until the function result is zero.</p>
<p>During the time <code>pgPrintToPage</code> is being executed, <code>pg</code>&#39;s attribute flags will have <code>PRINT_MODE_BIT</code> set.</p>
<h5 id='notes-19'>NOTES:</h5>
<ol start='' >
<li>Text is not automatically rewrapped to <code>page_rect</code> even if <code>page_rect</code> is a different width than <code>pg</code>&#39;s <code>page_area</code>. Whether or not the lines will spill off to the right is also not checked. It is therefore your responsibility to make sure <code>page_rect</code> is wide enough and, if necessary, force <code>pg</code> to rewrap by changing the <code>page_area</code> first.</li>
<li>If you want to print in a &quot;scaled&quot; state, simply set <code>pg</code> to the desired scaling then print the pages.</li>

</ol>
<h3 id='printing-in-windows'>Printing in Windows</h3>
<p>HERMES Paige printing for Windows is similar to Macintosh in the sense that drawing is temporarily redirected to some device other than the application document window.</p>
<p>When calling <code>pgPrintToPage</code>, you need to set up a <code>graf_device</code> (a multipurpose output device for platform-independent drawing) and pass a pointer to that record in the target parameter.</p>
<p>To create the <code>graf_device</code>, use:</p>
<pre><code>(void) pglnitDevice(pg_globals_ptr globals, generic_var the_port, long machine_ref, graf_device_ptr device);
</code></pre>
<p>The <code>globals</code> parameter must be a pointer to HERMES Paige globals (same structure given to <code>pgInit()</code> and <code>pgNew()</code>). Pass <code>MEM_NULL</code> to <code>the_port</code>. For Windows, this would normally be type <code>HWND</code> but in this case there isn&#39;t any window associated with the device.</p>
<p>Pass the Device Context handle in <code>machine_ref</code>. This should be the <code>HDC</code> that you will be &quot;printing&quot; to.</p>
<p>After calling <code>pgInitDevice()</code> you then pass the <code>graf_device</code> structure to <code>pgPrintToPage()</code> as the target parameter.</p>
<p>Once you are completely through using the <code>graf_device</code>, you must call the following:</p>
<pre><code>(void) pgCloseDevice (pg_globals_ptr globals, graf_device_ptr device);
</code></pre>
<p>The <code>globals</code> parameter must point to the same HERMES Paige globals as before; the device parameters must be a pointer to the <code>graf_device</code> previously initialised with <code>pgInitDevice</code>.</p>
<h5 id='notes-20'>Notes</h5>
<ol start='' >
<li><code>pgCloseDevice</code> only disposes memory structures created by HERMES Paige. The Device Context is not affected.</li>
<li>When creating a <code>graf_device</code> in this fashion, the Device Context given to <code>pgInitDevice</code> must remain valid until you are completely through drawing to the device (and consequently call <code>pgCloseDevice</code>).</li>

</ol>
<h3 id='printer-resolution'>Printer Resolution</h3>
<p>If you create a <code>graf_device</code> for printing per the instructions above, you do not need to do anything special with regard to the resolution of the target print device. The <code>pgInitDevice()</code> function will resolve all resolution issues and <code>pgPrintToPage()</code> should render the image correctly.</p>
<h3 id='sample-to-print-on-the-macintosh'>Sample to print on the Macintosh</h3>
<p>Here is an example of printing a <code>pg_ref</code> to a standard Macintosh print driver. Note that you must first create a <code>graf_device</code> for HERMES Paige to accept the print driver as the current &quot;port&quot;. This example shows how to do that as well:</p>
<pre><code>void print_pg_doc(pg_ref pg, THPrint print_rec)
{
	Rect page_rect;
	rectangle pg_page;
	graf_device pg_port;
	long print_offset;
	int cancel;
	short page_num;
	TPPrPort print_port;
	TPrStatus p_status;
	page_rect = (**print_rec) prInfo.rPage;
	RectToRectangle(&amp;page_rect, &amp;pg, page);
	// print page rectangle
	
	print_port = PrOpenDoc(print_rec, NULL, NULL);
	pgInitDevice(&amp;paige_rsrv, print_port, 0, &amp;pg_port);
	// Makes graf_device
	cancel = FALSE;
	
	print_offset = 0;
	page_num = 1;
	
	while (page_num &amp;&amp; (!cancel))
	{
		prOpenPage(print_port, NULL);	// Prints a &quot;page&quot;
		print_offset = pgPrintToPage(pg, &amp;pg_port, print_offset, &amp;pg_page, best_way);
		PrClosePage(print_port);

		if (print_offset)	// If more to print, next offset non-zero
			++page_num;
		else
			page_num = 0;		// This way we break the loop
			cancel = (PrError() == iPrAbort);
		}
		
	PrCloseDoc(print_port);
	if (!cancel)
		PrPicFile(print_rec, NULL, NULL, NULL, &amp;p_status);			
		pgCloseDevice(&amp;paige_rsrv, &amp;pg_port);		// Disposes graf_device
</code></pre>
<h3 id='tech-note-what-do-i-need-to-do-about-higher-resolution-coördinate-systems'>TECH NOTE What do I need to do about higher resolution coördinate systems?</h3>
<blockquote><p>I noticed that the coordinate system is in pixels. How do we handle coordinates in for high resolution printing? Are we limited to a 1/8&quot; granularity?</p>
</blockquote>
<p>In Windows, HERMES Paige handles printing resolution by checking the capabilities of the device context you provide. Assuming you have set up a <code>graf</code> device (per examples shown in the Programmer&#39;s Guide), the device resolution is determined and stored within the <code>grafdevice</code> structure. Then when you call <code>pgPrintToPage()</code>, HERMES Paige will scale the image to match the printer&#39;s resolution.</p>
<p>Usually, you don&#39;t need to do anything special for printing the maximum resolution since HERMES Paige handles the difference(s) automatically between the screen and printer.</p>
<h3 id='tech-note-scaled-printing'>TECH NOTE Scaled Printing </h3>
<blockquote><p>[Using Windows version], I am trying to print an HERMES Paige document scaled to something other than 100%. I do this by setting HERMES Paige scaling but it has no effect, the document always prints 100%.</p>
</blockquote>
<p>The reason scaling doesn&#39;t get reflected when you print is that HERMES Paige overrides the scaling you have set to the screen intentionally.</p>
<p>This is because it has to scale everything to match the printer&#39;s resolution, hence it temporarily changes the scaling factor.</p>
<p>The work-around is to trick HERMES Paige into thinking the printer&#39;s resolution is something else. The scaling will reflect the printer&#39;s resolution + whatever you want. This is possible to do as long as you change the resolution in the <code>graf_device</code> <em>after</em> you initialise it (see below).</p>
<p>For example, suppose you are printing to a 300 DPI device. Let&#39;s say you want to reduce the printed image by 50%. All you do is set the resolution to the grafdevice to 300/2=150 DPI. In this case, HERMES Paige will scale only half the size it should for 300 DPI, which would render your output 50% reduced.</p>
<p>The printer resolution is in the graf device.resolution field, and this value is a long word whose high/low words are the horizontal and vertical resolutions (dots per inch).</p>
<h4 id='example-6'>Example</h4>
<pre><code>void print (HDC out_dc)
{
	graf_device print_port;
	rectangle page_rect;
	long offset, print_x, print_y;
	
	pgInitDevice(&amp;pg_globals, MEM_NULL, out_dc, &amp;print_port);
	
	// Get print resolution
	
	print_y = GetDeviceCaps(out_dc, LOGPIXELSY);
	print_x = GetDeviceCaps(out_dc, LOGPIXELSX);
	
	// I want 50% reduction, so put the resolution at 1/2 the norm:
	
	print_y /= 2;
	print_x /= 2;
	print_dev -&gt; resolution = print_x;
	print_dev -&gt; resolution &lt;&lt;- 16;
	print_dev -&gt; resolution |= print_y;
</code></pre>
<h2 id='166-computing-pages'>16.6 Computing Pages</h2>
<pre><code>(short) pgNumPages (pg_ref pg, rectangle_ptr page_rect);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns the number of &quot;pages&quot; that would print with <code>page_rect</code>.</p>
<p>In other words, if <code>page_rect</code> were passed to <code>pgPrintToPage</code> and the whole document were printed, <code>pgNumPages</code> will return how many passes would be made (which implies how many pages would print).</p>
<h5 id='notes-21'>NOTES</h5>
<ol start='' >
<li>This function only works if you have the exact same settings in <code>pg</code> that will exist when <code>pgPrintToPage</code> is called, i.e., scaling factor, page_area size, etc.</li>
<li>Using this function for large documents will consume a lot of time. This is because HERMES Paige has to determine the exact number of pages by paginating every line of text according to the page rectangle you have specified.</li>

</ol>
<h2 id='167-skipping-pages'>16.7 Skipping pages</h2>
<pre><code>(long) pgFindPage (pg_ref pg, short page_num, rectangle_ptr page_rect;
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function will return a text offset that you could pass to <code>pgPrintToPage</code> to print page number <code>page_num</code>, assuming a page rectangle <code>page_rect</code>.</p>
<p>In other words, the following question is answered by this function: if you called pgPrintToPage <code>page_num</code> times using <code>page_rect</code>, what text offset would be returned?</p>
<p>In essence, you could use this function to &quot;skip&quot; pages by computing the offset in advance without printing.</p>
<p>When printing in the Windows environment, the printer font(s) do not always match the screen font(s) in terms of character placement and width. Per Microsoft&#39;s technical notes, if the application prefers that print quality take precedence over screen quality, yet WYSIWYG character placement is equally important, the recommended method is to render the screen image to match the (eventual) printed page. HERMES Paige provides the following function to accomplish this:</p>
<pre><code>pg_boolean pgSetPrintDevice (pg_ref pg, generic_var device);
</code></pre>
<p>Calling this function causes all subsequent wordwrapping and character placement in <code>pg</code> to match the printed result. The device parameter should be the printer <code>HDC</code> you will be using to print the document. Please note that in this case, <code>device</code> is an <code>HDC</code> and not a graf_device.</p>
<p>The appropriate time to call <code>pgSetPrintDevice()</code> is immediately after <code>pgNew()</code>, and any time after the user has changed the print device or printing attributes.</p>
<p><strong>FUNCTION RESULT:</strong> If the new print device is not the same as the previous device within the <code>pg</code>, TRUE is returned.</p>
<p>NOTE: It is your responsibility to delete the printer <code>DC</code>. HERMES Paige will not delete the <code>DC</code> even if you set it to something else or destroy the <code>pg_ref</code>.</p>
<p>CAUTION: If you use this feature, the printer <code>DC</code> must remain valid until the <code>pg_ref</code> is destroyed, or until another device is set. Or, you can clear the existing <code>DC</code> from the <code>pg_ref</code> by passing <code>MEM_NULL</code> for the &quot;device&quot;.</p>
<h5 id='notes-22'>NOTES:</h5>
<ol start='' >
<li>This function changes the way the text appears on the screen, not the printer. Its one and only purpose is to force the screen rendering to match the printing as close as possible.</li>
<li>You should not use this function if the quality of the screen rendering is more important than the printed quality.</li>

</ol>
<p>-</p>
<pre><code>generic_var pgGetPrintDevice (pg_ref pg);
</code></pre>
<p>This function returns the existing printer <code>DC</code> stored in <code>pg</code>, previously set by <code>pgSetPrintDevice()</code>. If no <code>DC</code> exists, <code>MEM_NULL</code> is returned.</p>
<h2 id='169-display-proc'>16.9 Display Proc</h2>
<pre><code>(void) pgDrawPageProc (paige_rec_ptr pg, shape_ptr page_shape, pg_short_tr_qty, pg_short_t page_num, co_ordinate_ptr vis_offset, short draw_mode_used, short call_order);
</code></pre>
<p>The purpose of <code>pgDrawPageProc</code> is to give the app a chance to draw &quot;page stuff&quot; such as grey outlines around page margins, and/or in the demo&#39;s case, it draws outlines around containers. Other ornaments can be drawn such as floating pictures—the demo uses this function to draw <code>pict</code>s that are anchored to document (as opposed to <code>pict</code>s embedded into text).</p>
<p><code>pgDrawPageProc</code> is actually the default procedure for the <code>draw_page_proc</code>, see &quot;<code>draw_page_proc</code>&quot;<!-- on page 27-65-->.</p>
<p>This function only gets called from <code>pgDisplay</code> and/or from internal display following a <code>ScrollRect</code>. It is not called when typing/display of keyboard inserts. The function is called after all text is drawn and just before returning to the app.</p>
<p>If called from <code>pgDisplay</code>, the clip region is set to the <code>vis_area</code> of <code>pg</code>. If called from pgScroll the clip is set to the scrolled &quot;white&quot; space.</p>
<p>This function can appear more complex than it is when you have irregular <code>page_area</code> shapes and/or repeating shapes. But all that is happening is that <code>pgDrawPageProc</code> gets called once for each &quot;page&quot; regardless of how many <code>rect</code>s are inside your <code>page_area</code> shape.</p>
<p>Assume the simplest case: a <code>pg_ref</code> with a single rectangle for page_area and nonrepeating (i.e. one long rectangular document). In this case, <code>pgDrawPageProc</code> is called ONCE after drawing text in <code>pgDisplay</code> (see <code>param</code> description below).</p>
<p>Assume the next most simple case, which is a single <code>rect</code> page area but <code>V_REPEAT_BIT</code> set. In this case, <code>pgDrawPageProc</code> gets called for <em>n</em> number of times, where <em>n</em> is the number of &quot;repeats&quot; that appear in the vis_area.</p>
<p>But here&#39;s what might be confusing: <code>pgDrawPageProc</code> always gets called once only if non-repeating shape, and <em>n</em> times if repeating, regardless of how many &quot;containers&quot; you have (how many rects comprise the page_area shape). If you have multiple rects such as columns or containers, it is up to <em>your</em> <code>pgDrawPageProc</code> to do whatever it needs to, say, draw an outline around each rect. The fact that <code>pgDrawPageProc</code> might get called more than once depends purely on <code>V_REPEAT_BIT</code> being set or not.</p>
<p>If you imagine <code>page_area</code> as being one thing, i.e. a &quot;page,&quot; then <code>pgDrawPageProc</code> makes the most sense.</p>
<p>Stated simply, if you had one huge monitor that showed 3 &quot;pages&quot; (3 occurrences of shape repeat), <code>pgDrawPageProc</code> gets called 3 times. It doesn&#39;t matter how complex the shape or how many columns/containers, etc.</p>
<p>The meaning of each parameter in <code>pgDrawPageProc()</code> is as follows:</p>
<p><code>page_shape</code> - is a pointer to the <em>first</em> rectangle in the <code>page_area</code> shape. This will literally be a <em>used</em> pointer to the <code>page_area</code>&#39;s first <code>rect</code> (a shape is a series of rectangles). The <code>rect</code>(s) are <em>unaltered</em> (they are unchanged as you set them in the <code>pg_ref</code>, i.e. the are neither &quot;scrolled&quot; nor scaled).</p>
<p><code>r_qty</code> — contains number of <code>rect</code>s that <code>page_shape</code> points to.</p>
<blockquote><p><strong>NOTE:</strong> This <em>is not</em> how many &quot;repeating occurrences&quot; exist for repeating shape mode, rather how many physical <code>rect</code>s <code>page_shape</code> points to. This will always be at least 1. For simple docs, it will be 1 (<code>rect</code>); for a three-column doc it will <em>probably</em> be 3, and so on. For example, if your page shape had three <code>rect</code>s representing columns, the &quot;column rects&quot; could be accessed as <code>page_shape[0]</code>, <code>page_shape[1]</code>, and <code>page_shape[2]</code>. Simply stated, <code>page_shape</code> for <code>r_qty</code> <code>rect</code>s represents the unscaled/unscrolled/original <code>page_area</code> of <code>pg</code>.</p>
</blockquote>
<p><code>page_num</code> — contains the logical &quot;page&quot; number for which the function is intended, the first page being &quot;1&quot;. This is a <em>logical</em> number, not a physical <code>rect</code> element (<code>r_qty</code> might only be &quot;1&quot; but <code>page_num</code> could be 900). Note that this parameter makes more sense if you have repeating shapes, otherwise it is always &quot;1&quot;. As mentioned above, if the doc has repeating shapes, HERMES Paige makes repetitive calls to <code>pgDrawPageProc</code> for as many shape-repeats as will fit in the <code>vis_area</code>. Also note that page_num can be literally interpreted as &quot;page number&quot; as it represents the <em>n</em>th repeat of the shape. That also means that if the doc is scrolled to, say, page 100, the first call to <code>pgDrawProc</code> will probably be 100—<em>not</em> &quot;1&quot;. Lastly, note that <code>page_shape</code> points to the <em>same</em> <code>rect</code>s for every repetitive call to <code>pgDrawPageProc</code>.</p>
<p><code>vis_offset</code> — the amount you would need to &quot;offset&quot; each rect in <code>page_shape</code> to achieve the correct visual screen position for page number page num. As stated above, <code>page_shape</code> points to unscrolled <code>rect</code>(s). Suppose you wanted to use <code>pgDrawPageProc</code> to draw page margins. Because the doc might be scrolled and/or because the &quot;page&quot; might be the <em>n</em>th repeating of the shape, you can&#39;t just do <code>FrameRect</code>s—you need to offset each <code>rect</code> by <code>vis_offset</code> amount. This amount also includes the <code>repeat</code> element, i.e. it is supplied to you with extra amounts based on <code>page_num</code>. Hence, all rects in <code>page_shape</code> offset by <code>vis_offset</code> are <em>physical</em> screen locations for <code>page_num</code>.</p>
<p><code>draw_mode_used</code> — the <code>draw_mode</code> that was used by HERMES Paige just before it called <code>pgDrawPageProc</code>. The intended purpose of this is to let an app know if it did a bitmap draw of text. There are <em>future</em> cases where an extension will need to know that for optimisation. </p>
<p><strong>EXAMPLE:</strong> Background <code>pict</code>s that get drawn directly into the offscreen bitmap along with text—have already been drawn before <code>pgDrawPageProc</code> gets called. Hence, it would be useful for the app to know this so that it would not draw <code>pict</code>s unless <code>draw_mode_used</code> was non-bitmap.</p>
<p><code>call_order</code> — tells you how many times <code>pgDrawPageProc</code> has been called so far in this display loop. For example, if you call <code>pgDisplay</code> for a doc that has repeating shape, <code>pgDrawPageProc</code> might get called 2 or 3 times (one for each &quot;page&quot;). The <code>call_order</code> parameter gives you info regarding this. If zero, it is the first call of several; if positive and non-zero, it is the <em>n</em>th call but there will be at least one more; if negative, it is being called for the last time. One thing I use this for is drawing floating <code>pict</code>s—I don&#39;t want to draw pictures until <code>pgDrawPageProc</code> is being called for the LAST time.</p>
<h1 id='17-hermes-paige-import-extension-for-rtf-and-other-types'>17 HERMES Paige IMPORT EXTENSION (for &quot;RTF&quot; and other types)</h1>
<p>The HERMES Paige import extension provides high-level functionality for importing ASCII files, other HERMES Paige files and Rich Text Format (RTF) files. Although it is designed as a C++ framework, files can be imported from straight C if necessary.</p>
<h2 id='171-installation'>17.1 Installation</h2>
<p><strong>NOTE:</strong> The installation procedure mentions the directory, <code>pgtxr</code>.</p>
<p>If you are installing the importer for the Macintosh platform and/or for Win16 or Win32 and are not using MFC, simply add the following files from the <code>pgtxr</code> directory to your project:</p>
<h5 id='minimum-configuration-import-ascii-text-only'>Minimum configuration (import ASCII text only)</h5>
<ul>
<li><code>pgimport.cpp</code></li>
<li><code>pgdeftbl.c</code></li>

</ul>
<h5 id='native-hermes-paige-file-import-in-addition-to-above'>Native HERMES Paige File Import (in addition to above)</h5>
<ul>
<li><code>pgnative.cpp</code></li>

</ul>
<h5 id='rtf-file-import-in-addition-to-minimum-configuration'>RTF File Import (in addition to Minimum Configuration)</h5>
<ul>
<li><code>pgrtfdef.c</code></li>
<li><code>pgrtfimp.cpp</code></li>

</ul>
<h3 id='header-files'>Header Files</h3>
<h5 id='if-you-will-be-importing-files-using-c++'>If you will be importing files using C++:</h5>
<ul>
<li><code>#include &quot;pgtxrcpp.h&quot;</code></li>

</ul>
<h5 id='if-you-will-be-importing-only-from-straight-c'>If you will be importing only from straight C:</h5>
<ul>
<li><code>#include &quot;pgtxr.h&quot;</code></li>

</ul>
<h2 id='172-importing-files-from-c++'>17.2 Importing Files (from C++)</h2>
<p><strong>CUSTOM CONTROL USERS:</strong> There are (intentionally) no control messages that support the HERMES Paige Import extension. Use the method shown below; also, see section 17.9, <a href='17.9-importing-to-the-hermes-paige-custom-control'>Importing to the HERMES Paige Custom Control</a>.</p>
<p>Loading a file with this extension can be accomplished in a few easy steps:</p>
<ol start='' >
<li><p>Start with an existing <code>pg_ref</code> or HERMES Paige control as the target document to receive the import. This may be a, empty document or a document which already has text (in which case the file contents will be inserted at the current insertion point).</p>
</li>
<li><p>To import from a disk file, open the file you wish to import. To import from memory, allocate the memory and fill its contents with the appropriate file data. If you are starting with a Macintosh Handle or Windows <code>HGLOBAL</code> you can convert it to a <code>memory_ref</code> by calling <code>HandleToMemory()</code>.</p>
</li>
<li><p>Create a new object (with <code>new</code> keyword) of the appropriate type for the file. (If you aren&#39;t sure about what type of file you just opened, see section 17.3, <a href='#173-determining-file-type'>Determining File Type</a>. Currently, we support raw text files, RTF files, and files in HERMES Paige&#39;s native format. The following is an example of creating an appropriate import object:</p>
<pre><code>#include &quot;pgTxrCPP.h&quot;
PaigelmportObject filter;

// To import a plain ASCII text file:
filter = new PaigelmportFilter();

// To import an RTF file:
filter = (PaigelmportObject) new PaigeRTFImportFilter();

// To import an HERMES Paige file:
filter =(PaigelmportObject) new PaigeNativeImportFilter();
</code></pre>
</li>
<li><p>Call the initialisation member function <code>pgInitImportFile()</code>. This function is defined as follows:</p>
<pre><code>pg_error pglnitlmportFile (pg_globals_ptr globals, pg_file_unit fileref, memory_ref memory_unit, file_io_proc read_proc, long first_position, long last_position);
</code></pre>
<p>This function prepares for importing a file, setting up whatever is necessary for the file&#39;s native format. A file can be imported from a physical file, or from memory. This is differentiated by the value(s) you pass in the function parameters, as follows:</p>
<ul>
<li><p><code>globals</code> - A pointer to your HERMES Paige globals. Custom control users can get a pointer to the HERMES Paige globals as follows: </p>
<ol start='' >
<li>Getting the <code>pg_ref</code> from the control by sending a <code>PG_GETPGREF</code> message, and</li>
<li>Calling the HERMES Paige API, <code>pgGetGlobals()</code>.</li>

</ol>
</li>
<li><p><code>fileref</code> - If importing from a file on disc, this parameter must be a reference to the opened file (the <code>refNum</code> for <em>Macintosh</em> or a file handle for <em>Windows</em>). If importing from memory, <code>fileref</code> should be zero. <strong>MFC</strong> users on <em>Windows</em> should note that the <code>fileref</code> parameter must be a &quot;real&quot; <code>HFILE</code> (or <code>NULL</code> if importing from memory), not some other MFC-generated class member that you may assume is a file handle.</p>
</li>
<li><p><code>memory_unit</code> — If importing from a file on disc, this parameter must be <code>MEM_NULL</code>. If importing from memory, this must be a <code>memory_ref</code> (see chapter 25, <a href='#25-the-allocation-manager'>The Allocation Manager</a>). Importing from memory requires that <code>memory_unit</code> contains the same information in the same format as it would if it were a disk file.</p>
</li>
<li><p><code>read_proc</code> — This is an optional I/O function to be used instead of the default low-level reading function. Refer to the HERMES Paige Programmer&#39;s Guide for information about custom I/O functions. For reading a standard file from disk or memory, pass NULL for this parameter.</p>
</li>
<li><p><code>first_position</code>, <code>last_position</code> — These two values indicate the beginning and ending file positions to import, respectively. The <code>first_position</code> can be zero or some other byte offset into the file to begin reading. If <code>last_position</code> is unknown (or if you want to read the file whole), pass <code>UNKNOWN_POSITION</code> for <code>last_position</code>. Otherwise, the file will be imported from byte offset <code>first_position</code> to, but not including the byte at <code>last_position</code>. <br> <strong>FUNCTION RESULT:</strong> If this function is successful, zero is returned, otherwise an error code is returned.</p>
</li>

</ul>
</li>
<li><p>To read the file and insert its contents into an HERMES Paige document, call the member function, <code>pgImportFile()</code>:</p>
<pre><code>pg_error pgImportFile (pg_ref pg, long pg_position, long import_flags, pg_boolean keep_selection, short draw_mode)
</code></pre>
<ul>
<li><p><code>pg</code> — The target document. Custom control users: obtain the <code>pg_ref</code> by sending a <code>PG_GETPGREF</code> message.</p>
</li>
<li><p><code>pg_position</code> — The text position (in the HERMES Paige document) to receive the insertion. If this value is <code>CURRENT_POSITION</code>, the file will be imported to the current insertion.</p>
</li>
<li><p><code>import_flags</code> — A set of bits defining which item(s) to import, which can be any or all of the data types shown below. (Note, setting these bits causes that data item to import only if supported by the importer).</p>
<pre><code>#define IMPORT_EVERYTHING_FLAG			0x00FFFFFF	// Import everything
#define IMPORT_TEXT_FLAG				0x00000001	// Import raw text
#define IMPORT_TEXT_FORMATS_FLAG		0x00000002	// Import text formats
#define IMPORT_PAR_FORMATS_FLAG		 	0x00000004	// Import paragraph formats
#define IMPORT_PAGE_INFO_FLAG			0x00000008	// Import page information
#define IMPORT_CONTAINERS_FLAG			0x00000010	// Import container boxes
#define IMPORT_HEADERS_FLAG				0x00000020	// Import headers
#define IMPORT_FOOTERS_FLAG				0x00000040	// Import footers
#define IMPORT_FOOTNOTES_FLAG			0x00000080	// Import footnotes
#define IMPORT_EMBEDDED_OBJECTS_FLAG	0x00000100	// Import embedded graphics
#define IMPORT_PAGE_GRAPHICS_FLAG		0x00000200	// Import page pictures
#define IMPORT_STYLESHEETS_FLAG			0x00000400	// Import style sheets
</code></pre>
<p><br> In addition to the above, setting the following bit causes page dimensions (paper size, margins) to get applied:
	</p>
<pre><code>#define APPLY_PAGE_DIMENSIONS	0x02000000	// Apply page size(s)
#define IMPORT_CACHE_FLAG		0x04000000	// Page-read the file
</code></pre>
<p><br>If <code>APPLY_PAGE_DIMENSIONS</code> is set, the <code>pg_ref</code>&#39;s page shape is changed per the import information (if such information is supported). For example, when importing an RTF file, setting <code>APPLY_PAGE_DIMENSIONS</code> will apply the page size(s) found in the RTF information. If this bit is not set, the page area remains unchanged. If <code>IMPORT_CACHE_FLAG</code> is set, the file is opened in &quot;paging&quot; mode, i.e. its text is not read all at once; rather, its text sections are read as needed. This is particularly useful for opening very large files. 
<br> <strong>NOTE:</strong> <code>IMPORT_CACHE_FLAG</code> is only supported for HERMES Paige and ASCII text files. (See 2.0b release notes, &quot;Huge File Paging”)</p>
</li>
<li><p><code>keep_selection</code> — If TRUE, the selection point in the text does not advance, otherwise the selection point in the document advances by the number of bytes that were imported.</p>
</li>
<li><p><code>draw_mode</code> — If non-zero, the document is redrawn showing the new data contents; otherwise, nothing is redrawn.
<br> <strong>FUNCTION RESULT:</strong> If this function is successful, zero is returned, otherwise an error code is returned.</p>
</li>

</ul>
</li>
<li><p>Delete the object, or if you want to import another file, repeat steps 4 through 5.</p>
</li>

</ol>
<h4 id='import-file-example'>Import File Example</h4>
<pre><code> #include &quot;pgTxrCPP.h&quot;
 
 /* This function imports a file into a pg_ref, first creating an object for the appropriate file type. If all is well, the document is re-drawn and NO_ERROR is returned. */
 
 pg_error ImportFile (pg_ref pg, pg_filetype filetype, long feature_flags, long file_begin, pg_file_unit f_ref)
 {
 	PaigeImportObject filter;
 	pg_globals_ptr globals;
 	long flags;
 	pg_error result = NO_ERROR;
 	
 	if (!(flags = feature_flags))
 		flags = IMPORT_EVERYTHING_FLAG;
 		globals = pgGetGlobals(pg);

 	switch (filetype)
 	{
 		case pg_text_type:
 			filter = new PaigeImportFilter();
 			break;
 		case pg_rtf_type:
 			filter = (PaigeImportObject) new
 			PaigeRTFImportFilter();
 			break;
 		case pg_paige_type:
 			filter = (PaigeImportObject) new
 			PaigeNativeImportFilter();
 			break;
 		default:
 			return (pg_ERROR) BAD_TYPE_ERR;
 	}
 	
 	if((result = filter -&gt; pgInitImportFile
</code></pre>
<h2 id='173-determining-file-type'>17.3 Determining File Type</h2>
<p>There might be cases where the file type is unknown and/or you want to verify that a file is truly the type that you expect. There is a function you can call to determine the type:</p>
<pre><code>pg_filetype pgDetermineFileType (pg_file_unit fileref, file_io_proc io_proc, long starting_position)
</code></pre>
<p><strong>NOTE:</strong> Calling this function examines the appropriate contents of a file looking for a signature recognized by one of the support file import classes. The actual file contents are examined to determine the type.</p>
<p><code>fileref</code> — An opened file reference (the &quot;refNum&quot; for Macintosh or file handle for Windows).</p>
<p><code>io_proc</code> — The low-level function to perform I/O. This is described in the HERMES Paige Programmer&#39;s Guide. Except for implementing very special features, usually you should pass NULL for this parameter.</p>
<p><code>starting_position</code> — Indicates the file position you will (eventually) begin importing.</p>
<p>This function will always return one of the following types:</p>
<pre><code>#include &quot;pgTxr.h&quot;

enum
{
	pg_unknown_type,	// Unknown file type
	pg_text_type,		// Standard ASCII text
	pg_rtf_type,		// Rich text format
	pg_paige_type,	// Standard HERMES Paige file type
}
</code></pre>
<p><strong>NOTE:</strong> An unrecognised file will usually return as <code>pg_text_type</code> because a <code>text</code> file is considered to be practically anything. For this reason, <code>pgDetermineFileType()</code> will first check for <code>pg_rtf_type</code> and <code>pg_paige_type</code> before deciding it is simply a text file.</p>
<h2 id='174-determining-the-feature-set'>17.4 Determining the Feature Set</h2>
<p>You can determine what data type(s) are supported by the importer if you examine <code>object -&gt; feature_bits</code> immediately after creating the import object. This member will be initialised to some combination in list shown on the following page:</p>
<pre><code>IMPORT_TEXT_FEATURE				Can import raw text
IMPORT_TEXT_FORMATS_FEATURE		Can import styled text
IMPORT_PAR_FORMATS_FEATURE		Can import paragraph formats
IMPORT_PAGE_INFO_FEATURE		Can import page dimensions
IMPORT_CONTAINERS_FEATURE		Can import containers
IMPORT_HEADERS_FEATURE			Can import headers
IMPORT_FOOTERS_FEATURE			Can import footers
IMPORT_FOOTNOTES_FEATURE		Can import footnotes
IMPORT_EMBEDDED_OBJECTS_FEATURE	Can import supported embed_refs
IMPORT_PAGE_GRAPHICS_FEATURE	Can import page-layour graphics
IMPORT_CACHE_FLAG				Can disc-page the file
</code></pre>
<h4 id='example-7'>Example</h4>
<pre><code>PaigeImportObject filter;

filter = (PaigeImportObject) new PaigeRTFImportFilter();

if (!(filter -&gt; feature_bits &amp; IMPORT_EMBEDDED_OBJECTS_FEATURE))
	AlertUser(&quot;Any pictures in document will be lost. Open anyway?&quot;)
</code></pre>
<h2 id='175-cross-mapping-font-tables'>17.5 Cross-Mapping Font Tables</h2>
<p>The HERMES Paige importer extension provides a default mapping table for font names when you import a file generated from another platform. For any font name that is imported, if a match is found in the table then the suggested substitute name is used; if no match is found, the default font name (defined in HERMES Paige globals) is used instead. The assumption is that the font name won&#39;t exist in the target platform.</p>
<p>You can override the defaults in one of two ways:</p>
<ol start='' >
<li><p>Substitute your own pointer to a font mapping table (see below). You can substitute your own table after the <code>PaigeImportFilter</code> object is created. For example:
	</p>
<pre><code>PaigeImportObject filter;

filter = (PaigelmportObject) new PaigeRTFImportFilter();
filter -&gt; font_cross_table = (pg_char_ptr)MyOwnFontTable;
</code></pre>
</li>
<li><p>Override the font mapping member function. The function that maps font substitution can be overridden if you subclass the desired import structure. The font mapping function is declared as:</p>
<pre><code>virtual void pgMapFont (font_info_ptr font, long importing_os, long current_os);
</code></pre>
<p>-
Upon entry, &quot;font&quot; is the <code>font_info</code> pointer in question. The <code>importing_os</code> and <code>current_os</code> define the platform of the importing file and the current (runtime) platform, respectively. These platform definitions will be one of the following:</p>
<pre><code>#define MACINTOSH_OS	1
#define WINDOWS_OS		2
#define UNIX_OS			3
</code></pre>
<p>-
To substitute a font, simply change <code>font -&gt; name</code> before returning from the function.</p>
</li>

</ol>
<p>CAUTION: The font name, by default, is a pascal string (first byte is its length). If you replace it with a cstring you must set font-&gt;environs to NAME_IS_CSTR.</p>
<p>If you want no font mapping at all, set the object&#39;s member &quot;font_cross_table&quot; to NULL after creating it.</p>
<h3 id='font-table-format'>Font Table Format</h3>
<p>The font mapping table is a table of null-terminated text strings. Each entry (delimited by a null character) is ordered in ascending alphabetical order, the last entry is terminated with <code>\ff</code> (see default tables below). Each entry contains a font name (with possible asterisk <code>*</code> wildcard) followed by a substitute name in square brackets <code>[]</code>.</p>
<h4 id='example-1'>EXAMPLE 1:</h4>
<pre><code>&quot;WingDings[Zapf Dingbats]\0&quot;
</code></pre>
<p>If the imported font name is &quot;WingDings&quot; then substitute &quot;Zapf Dingbats&quot;.</p>
<h4 id='example-2'>EXAMPLE 2:</h4>
<pre><code>&quot;Times*[Times]\0&quot;
</code></pre>
<p>If imported font&#39;s first five characters are &quot;Times&quot; then substitute &quot;Times&quot;. (Hence, both “Times New Roman” and “Times Roman” would be subtitled with “Times”).</p>
<h2 id='176-default-font-tables'>17.6 Default Font Tables</h2>
<h3 id='importing-to-macintosh-and-file-is-from-windows'>Importing to Macintosh (and file is from Windows)</h3>
<pre><code>static pg_char cross_font_table[] =
{
	&quot;Arial*[Helvetica]\0&quot;
	&quot;Book*[Bookman]\0&quot;
	&quot;Century Gothic[Avant Garde]\0&quot;
	&quot;Century Sch*[New Century Schoolbook]\0&quot;
	&quot;Courie*[Courier]\0&quot;
	&quot;Fixedsys[Chicago]\0&quot;
	&quot;Helvetic*[Helvetica]\0&quot;
	&quot;Monotype Cors*[Zapf Chancery]\0&quot;
	&quot;MS S*[Geneva]\0&quot;
	&quot;Roman[New York]\0&quot;
	&quot;Script[Zapf Chancery]\0&quot;
	&quot;Small Fonts[Monaco]\0&quot;
	&quot;Terminal[Monaco]\0&quot;
	&quot;Times*[Times]\0&quot;
	&quot;Wingdings[Zapf Dingbats]\0&quot;
	&quot;\ff&quot;
};
</code></pre>
<h3 id='importing-to-windows-and-file-is-from-macintosh'>Importing to Windows (and file is from Macintosh)</h3>
<pre><code>static pg_char cross_font_table[] =
{
	&quot;Avant Garde[Arial]\0&quot;
	&quot;Bookman[Times New Roman]\0&quot;
	&quot;Chicago[FixedSys]\0&quot;
	&quot;Courier[Courier New]\0&quot;
	&quot;Geneva[MS Sans Serif]\0&quot;
	&quot;Helvetica[Arial]\0&quot;
	&quot;Monaco[Courier New]\0&quot;
	&quot;Helvetic*[Arial]\0&quot;
	&quot;New York[MS Serif]\0&quot;
	&quot;Palatino[Arial]\0&quot;
	&quot;Symbol[WingDings]\0&quot;
	&quot;Times[Times New Roman]\0&quot;
	&quot;Zapf Chancery[Script]\0&quot;
	&quot;Zapf Dingbats[WingDings]\0&quot;
	&quot;\ff&quot;
};
</code></pre>
<h2 id='177-character-mapping'>17.7 Character Mapping</h2>
<p>The importing mechanism will also map ASCII characters &gt; 0x7F. If you wish to override the defaults you should subclass the <code>import</code> class and override the following function:</p>
<pre><code>virtual void pgMapChars (pg_char_ptr c hars, long num_chars, long file_os, long current_os);
</code></pre>
<p>This function gets called after each block of text is imported. Upon entry, <code>chars</code> points to the block of text and <code>num_chars</code> defines the number of bytes. The <code>file_os</code> and <code>current_os</code> define the platform of the importing file and the current (runtime) platform. The possible values for these will be one of the following:</p>
<pre><code>#define MACINTOSH_OS	1
#define WINDOWS_OS		2
#define UNIX_OS			3
</code></pre>
<p>You can also override the character mapping by substituting your own character mapping table. The character mapping table is a series of unsigned characters, each entry representing consecutive characters from 0x80 to 0xFF.</p>
<p>For example, if the first three bytes being imported were 0x80, 0x81, and 0x82, the following character mapping table would cause 0xAA, 0xBB, and 0xCC to be inserted into the HERMES Paige document:</p>
<pre><code>unsigned char mapping_table[]=
{
	0xAA, 0xBB, 0xCC, ...
}
</code></pre>
<p>An entry in the mapping table of null (zero value character) denotes that the character is not available in the current platform. If so, the <code>unknown_char</code> member in <code>paige_globals</code> is used.</p>
<p>To substitute your own mapping table, first create the import object then change <code>object -&gt; character_table</code>.</p>
<h4 id='example-8'>EXAMPLE:</h4>
<pre><code>PaigeImportObject filter;
filter = (PaigeImportObject) new PaigeRTFImportFilter();
filter -&gt; character_table = (pg_char_ptr)MyOwnCharTable;
</code></pre>
<h2 id='178-importing-from-c'>17.8 Importing from C</h2>
<p><strong>CUSTOM CONTROL USERS:</strong> There are (intentionally) no control messages that support the HERMES Paige Import extension. Use the method shown below; also, see section 17.9, <a href='#179-importing-to-the-hermes-paige-custom-control'>Importing to the HERMES Paige Custom Control</a>. If you need to import a file from a non-C++ environment—or if you want to import a file from a single line of code—you can do so by calling the following function:</p>
<pre><code>pg_error pgImportFileFromC (pg_ref pg, pg_filetype filetype, long feature_flags, long file_begin, pg_file_unit f_ref)
</code></pre>
<p>This function imports a file of type <code>filetype</code> into <code>pg</code>. The <code>filetype</code> parameter must be one of the following:</p>
<pre><code>pg_text_type, 	// Standard ASCII text
pg_rtf_type,		// Rich text format
pg_paige_type		// Standard HERMES Paige file type
</code></pre>
<p>The <code>feature_flags</code> parameter indicates which data type(s) you want to import, which can be any of the following bit settings:</p>
<pre><code>#define IMPORT_EVERYTHING_FLAG			0x00FFFFFF	// Import everything
#define IMPORT_TEXT_FLAG				0x00000001	// Import raw text
#define IMPORT_TEXT_FORMATS_FLAG		0x00000002	// Import text formats
#define IMPORT_PAR_FORMATS_FLAG		 	0x00000004	// Import paragraph formats
#define IMPORT_PAGE_INFO_FLAG			0x00000008	// Import page information
#define IMPORT_CONTAINERS_FLAG			0x00000010	// Import container boxes
#define IMPORT_HEADERS_FLAG				0x00000020	// Import headers
#define IMPORT_FOOTERS_FLAG				0x00000040	// Import footers
#define IMPORT_FOOTNOTES_FLAG			0x00000080	// Import footnotes
#define IMPORT_EMBEDDED_OBJECTS_FLAG	0x00000100	// Import embedded graphics
#define IMPORT_PAGE_GRAPHICS_FLAG		0x00000200	// Import page pictures
#define IMPORT_STYLESHEETS_FLAG			0x00000400	// Import style sheets
</code></pre>
<p>In addition to the above, setting the following bit causes page dimensions (paper size, margins) to get applied:</p>
<pre><code>#define APPLY_PAGE_DIMENSIONS	0x02000000	// Apply page size(s)
#define IMPORT_CACHE_FLAG		0x04000000	// Page-read the file
</code></pre>
<p>The <code>file_begin</code> parameter indicates the first file position to begin reading.</p>
<p>The <code>f_ref</code> parameter must be a reference to an opened file (<code>refNum</code> for Mac, <code>file handle</code> for Windows).</p>
<p>If this function is successful, the contents of the file are inserted into the current position of <code>pg</code> and the document is redrawn and <code>NO_ERROR (0)</code> is returned. Otherwise the appropriate error code will be returned.</p>
<h2 id='179-importing-to-the-hermes-paige-custom-control'>17.9 Importing to the HERMES Paige Custom Control</h2>
<p>There is no message-based support in the custom control to import a file using the methods shown in this document; the lack of message-based importing is an intentional omission to allow optional compiling of the import classes independent of the control. To import a file into the custom control, you may simply obtain the <code>pg_ref</code> using the <code>PG_GETPGREF</code> message.</p>
<p>However, importing a file into a control can cause an out-of-sync situation with scrollbar positions, pagination, etc., so you should always send the following message immediately after importing a file:</p>
<pre><code>SendMessage(hwnd, PG_REALIZEIMPORT, wParam, 0);
</code></pre>
<p>The <code>PG_REALIZEIMPORT</code> message informs the control that you have imported a file and that it should make any adjustments necessary to reflect those changes.</p>
<p>If <code>wParam</code> is TRUE the control repaints itself.</p>
<h2 id='1710-the-paigeimportfilter-overrideables'>17.10 The <code>PaigeImportFilter</code>: Overrideables</h2>
<pre><code>class PaigeImportFilter
{
	public:
	pg_char_ptr font_cross_table;	// Table of cross-fonts
	pg_char_ptr character_table;	// Table of cross-chars
	
	// Overrideable member functions (higher level):
	
	virtual pg_error pgVerifySignature(void);
	virtual pg_error pgPrepareSignature(void);
	virtual pg_boolean pgReadNextBlock(void);
	virtual pg_error pgImportDone();
	virtual void PG_FAR * pgProcessEmbedData (memory_ref ref, long embed_type);
	virtual void pgMapFont (font_info_ptr font, long importing_os, long current_os);
	virtual void pgMapChars (pg_char_ptr chars, long num_chars, long file_os, long current_os);
};
</code></pre>
<p><strong>NOTE:</strong> All of the class definitions are not shown. Only the members of potential interest and usefulness are given. For a complete description of this class, see <code>pgtxrcpp.h</code>.</p>
<h3 id='member-by-member-description'>Member-by-Member Description</h3>
<p><code>font_cross_table</code> — A pointer to the font mapping table. See section 17.5, <a href='#175-cross-mapping-font-tables'>Cross-Mapping Font Tables</a>.</p>
<p><code>character_table</code> — A pointer to the character mapping table (for characters &gt; 0x7F). See section 17.7, <a href='#177-character-mapping'>Character Mapping</a>.</p>
<p><code>pg_error pgVerifySignature()</code> — Called to verify if the file about to be imported contains valid contents for the supported type. For example, <code>pgVerifySignature()</code> for the RTF class checks for the existence of the keyword <code>\rtf</code> at the start of the file to verify if it is truly an RTF file or some other format. If the file is valid, <code>NO_ERROR</code> should be returned, otherwise return <code>BAD_TYPE_ERR</code>.</p>
<p><code>pgPrepareImport()</code> — Called to make any preparations for importing the file. No actual file transfer is performed, but this function should be used to initialise private members to perform the first &quot;read&quot;. There are no parameters to this function. The values taken from the application&#39;s call to <code>pgInitImportFile()</code> will have been placed into the appropriate member values before <code>pgPrepareImport()</code> is called.</p>
<p><code>pg_boolean pgReadNextBlock()</code> — Called to import (read) the next block of text. A &quot;block of text&quot; means a block of one or more characters that are rendered in the same consistent format.</p>
<p>For example, if the incoming text contained &quot;<strong>Bold</strong>_Plain_<em>Italic</em>&quot;, the import class must consider <code>Bold_</code>, <code>Plain_</code> and <code>Italic_</code> as three separate blocks. The first time <code>pgReadNextBlock()</code> gets called, the text <code>Bold_</code> would be returned; the next time <code>Plain_</code> is returned, and so forth.</p>
<p>Most of the text and format information must be placed in the &quot;translator&quot; member of the class; this member is a record defined as follows:</p>
<pre><code>struct pg_translator
{
	memory_ref data;				// Data transferred (read) or to-transfer (write)
	memory_ref stylesheet_table;	// Contains list of possible style sheets
	long bytes_transferred;			// Number of bytes in buffer
	long total_text_read;			// Total transferred to-moment
	style_info format;				// Style(s) and charcter format of text
	par_info par_format;			// Paragraph format(s) of the text
	font_info font;					// Font applied to this text
	pg_doc_info doc_info;			// General document information
	unsigned long flags;			// Attributes of last transfer
	pg_boolean format_changed;		// Set to TRUE - format has changed
	pg_boolean par_format_changed;	// Set to TRUE - para has changed
	pg_boolean font_changed;		// Set to TRUE - font has changed
	pg_boolean doc_info_changed;	// Set to TRUE if document info has changed
</code></pre>
<p>Imported text bytes are inserted into the <code>translator.data</code> <code>memory_ref</code> (using the appropriate HERMES Paige Allocation Manager calls). The byte size returned is assumed to be <code>GetMemorySize(translator.data)</code>. Note, to implement special features, it is acceptable to return zero bytes for each call. Your function will be called repeatedly until you return FALSE.</p>
<p>For the best examples of <code>pgReadNextBlock()</code> consult the source code files for each import class.</p>
<p><strong>FUNCTION RESULT:</strong> If there are no more bytes to transfer, return FALSE. Note that you can return FALSE even if the current function called transferred one or
more bytes, yet end-of-file comes after that position. A result of FALSE indicates that <code>pgReadNextBlock()</code> should not be called again.</p>
<p><code>pgImportDone()</code> — Called when importing has completed. This function essentially balances <code>pgPrepareImport()</code>. Anything you allocated previously in <code>pgPepareImport()</code> should be disposed.</p>
<pre><code>void PG_FAR * pgProcessEmbedData (memory_ref ref, long embed_type);
</code></pre>
<p>Called when the <code>import</code> class has read data that is intended for an <code>embed_ref</code>. (For version 1.02b of the import extension, this function only gets called by the RTF importer.)</p>
<p>Upon entry, <code>ref</code> contains the data read from the file and <code>embed_type</code> is the type of <code>embed_ref</code> that will be inserted. Note that the data in <code>ref</code> <em>is not</em> an <code>embed_ref</code>; rather, it is raw, binary data read from the file. The purpose of <code>pgProcessEmbedData()</code> is to convert that binary data into whatever form necessary to be successfully inserted as an <code>embed_ref</code>.</p>
<p><strong>FUNCTION RESULT:</strong> This function must return the appropriate data type for a subsequent creation and insertion of an <code>embed_ref</code>. Note, however, that the class that calls this function assumes that the <code>memory_ref</code> <code>ref</code> is either no longer valid, or the same <code>memory_ref</code> is returned as the function result (with its contents altered, for instance).</p>
<p>In other words, the assumption is made that the <code>ref</code> parameter has been converted into something else appropriate for the embed type, and that new data element is returned as the function result.</p>
<p>For example, if the <code>embed_type</code> were <code>embed_meta_file</code>, the appropriate function result might be to create a new <code>HMETAFILE</code>, set the bitstream data from <code>ref</code> into the new metafile <code>HANDLE</code>, dispose the <code>embed_ref</code> and return the new <code>HMETAFILE</code>.</p>
<h3 id='default-function'>Default Function</h3>
<p>The default function (when using the RTF import class) processes <code>embed_mac_pict</code> and <code>embed_meta_file</code>; if the type is <code>embed_mac_pict</code>, the <code>memory_ref</code> is converted to a <code>Handle</code> and returned as the function result. If the type is <code>embed_meta_file</code>, the contents of the <code>memory_ref</code> are converted to a new <code>HMETAFILE</code> and the <code>memory_ref</code> is disposed.</p>
<p>See source code for the default function in <code>pgImport.cpp</code>.</p>
<pre><code>pgMapFont(), pgMapChars()
</code></pre>
<p>These are called to cross-map fonts and characters between platforms. See sections 17.5, <a href='#175-cross-mapping-font-tables'>Cross-Mapping Font Tables</a> and 17.7, <a href='#177-character-mapping'>Character Mapping</a>, for a detailed description.</p>
<h2 id='1711-rtf-import-overridables'>17.11 RTF Import Overridables</h2>
<p>There are some lower-level member functions in <code>PaigeRTFImportFilter</code> class that you can override to process unsupported key words:</p>
<pre><code>class PaigeRTFImportFilter: public PaigeImportFilter
{
	public;
	virtual void ProcessInfoCommand (short command, short parameter);
	virtual void UnsupportedCommand (pg_char_ptr command, short parameter);
}
ProcessInfoCommand(short command, short parameter);
</code></pre>
<p><code>ProcessInfoCommand()</code> gets called by the RTF class when a &quot;document information&quot; key word is recognised but not processed. Upon entry, the <code>command</code> parameter will be equivalent to one of the values shown in the table below.</p>
<p>The value in <code>parameter</code> will be the numerical appendage to the keyword, if any. For example, the key word <code>dy23</code> would result in a <code>command</code> value of 5 (for <code>dy</code>) and a <code>parameter</code> value of 23.</p>
<pre><code>1		author
2		buptim
3 	creatim
4		doccomm
5		dy
6		edmins
7		hr
8		id
9		keywords
10	min
11	mo
12	nextfile
13	noofchars
14	nofpages
15	nofwords
16	operator
17	printtim
18	revtim
19	sec
20	subject
21	title
22	verno
23	version
24	yr
</code></pre>
<p>&nbsp;</p>
<pre><code>UnsupportedCommand (pg_char_ptr command, short parameter
</code></pre>
<p><code>UnsupportedCommand()</code> gets called by the <code>RTF</code> class when a key word is encountered that is not understood. The purpose of this overridable member function is to get access and process <code>RTF</code> tokens that are not normally supported.</p>
<p>Upon entry, <code>command</code> is a null-terminated string that contains the literal command (minus the <code>\</code> prefix); the value in <code>parameter</code> will be the numerical appendage to the keyword, if any. For example, the key word <code>bonus99</code> would result in a command string of <code>bonus\0</code> and a parameter value of <code>99</code>).</p>
<h2 id='1712-processing-tables'>17.12 Processing Tables</h2>
<p>Since HERMES Paige does not support the concept of &quot;tables&quot; directly, importing a table from an RTF file results in a tab-delimited text stream which represents each cell of the table. If your application requires more extensive implementation of tables, there are specific functions in the RTF importing class which you may override to implement them differently.</p>
<h3 id='table-processing-member-functions'>Table Processing Member Functions</h3>
<pre><code>void BeginTableImport();
</code></pre>
<p>This function is called when a table is recognized in the <code>RTF</code> input stream, but no data has been processed. The purpose of <code>BeginTableImport()</code> is to prepare whatever structure(s) are necessary to process the table.</p>
<p><strong>NOTE:</strong> The RTF class contains a private variable, <code>doing_table</code>, which must be set to <code>TRUE</code> at this time. Otherwise, the remaining table functions will never be called.</p>
<h3 id='default-implementation'>Default Implementation</h3>
<p>Only <code>table_cell</code>, <code>cell_setright</code> and <code>table_row_end</code> are processed; all other key words are ignored. For <code>table_cell</code>, a tab character is imported; for <code>cell_setright</code>, a paragraph tab position is set; for <code>table_row_end</code>, a carriage return is imported.</p>
<p>The class member <code>doing_table</code> is set to <code>TRUE</code>.</p>
<pre><code>pg_boolean ProcessTableCommand (short command, short parameter);
</code></pre>
<p>This function is called for all table-type <code>RTF</code> key words. Upon entry, <code>command</code> contains the table keyword (below) while <code>parameter</code> contains the appended parameter to the keyword, if any.</p>
<p>For example, the RTF key word <code>cellx900</code> indicates a cell&#39;s right position, in this case 900 (measured in <code>TWIPS</code>). The command value given to this function would be <code>cell_setright</code>, and <code>parameter</code> would be 900.</p>
<p><strong>FUNCTION RESULT:</strong> A result of &quot;TRUE&quot; implies that the current text and formatting should be inserted into the main document, otherwise the current text and formatting is buffered and the next text and/or key words are read.</p>
<h3 id='table-key-words'>Table Key Words</h3>
<p>The following values are defined in <code>PGRTFDEF.H</code>:</p>
<pre><code>enum {
	table_cell = 1,			// Data that follows is next cell
	cell_setright,			// Set cell&#39;s right side
	cell_border_bottom,		// Cell&#39;s bottom has border
	cell_border_left,		// Cell&#39;s left has border
	cell_border_right,		// Cell&#39;s right has border
	cell_border_top,		// Cell&#39;s top has border
	cell_first_merge,		// First table in range of cells to be merged
	cell_merge,				// Contents of cell are merged with preceding cell
	cell_shading,				// Cell is shaded */
	enter_table,		
	table_row_end,		// End current row of cells
	table_border_bottom,	// Table&#39;s bottom has border
	table_border_horizontal,	// Table&#39;s content has horizontalborder
	table_border_left,		// Table&#39;s left has border
	table_border_right,		// Table&#39;s right has border
	table_border_vertical,	// Table&#39;s content has vertical border
	table_border_top,		// Table&#39;s top has border
	table_spacing,		/* Half the space between cells in twips */
	table_header,		/* Data that follows is table header */
	table_keep_together,
	table_position_left,	/* Position table to left */
	table_center,		// Centre-align table
	table_left,		// Left-align table
	table_right,		// Right-aligh table
	table_height		// Indicates total height of table
};

pg_boolean InsertTableText ();
</code></pre>
<p>This function is called if text (cell contents) is processed while in table mode. This function will never get called unless <code>doing_table</code> is TRUE and one or more characters other than key words are read.</p>
<p>This function will also never overlap text formats, i.e. 	<code>InsertTableText()</code> gets called every time the character or paragraph style changes.</p>
<p>Upon entry, all information regarding the text and its format can be found in the <code>translator</code> member of the class:</p>
<pre><code>translator.data					- A memory_ref contains the text
translator.bytes_transferred 	- Number of characters in translator.data
translator.format				- Current text format (style_info)
translator.par_format			- Current paragraph format (par_info)
translator.font					- Current font (font_info) 
</code></pre>
<p><strong>FUNCTION RESULT:</strong> A result of &quot;TRUE&quot; implies that the current text and formatting should be inserted into the main document; otherwise, the current text is discarded (and never inserted into the main document).</p>
<p><strong>NOTE:</strong> A result of FALSE would be necessary if you are processing the text into a target that is not the main document (such as a graphic picture).</p>
<h3 id='default-implementation-2'>Default Implementation</h3>
<p>The <code>doing_table</code> member is cleared to FALSE, then TRUE is returned.</p>
<pre><code>pg_boolean EndTableImport();
</code></pre>
<p>This function is called when the end of the table is reached. The purpose of <code>EndTableImport()</code> is to terminate the table.</p>
<p><strong>FUNCTION RESULT:</strong> If TRUE is returned, any pending text and formatting will be inserted into the main document, otherwise existing text and formatting will be discarded.</p>
<p><strong>NOTE:</strong> This function must clear <code>doing_table</code> to FALSE.</p>
<h2 id='18-hermes-paige-export-extension-<br>-for-rtf-and-other-types'>18 HERMES Paige EXPORT EXTENSION <br> (FOR &quot;RTF&quot; AND OTHER TYPES)</h2>
<p>The HERMES Paige export extension provides high-level functionality for saving files to non-HERMES Paige formats. Version 1.03b supports HERMES Paige format, ASCII text format, and Rich Text Format (RTF). Although the export extension is a C++ framework, it can be called from straight C programs if necessary.</p>
<h2 id='181-installation'>18.1 Installation</h2>
<p><strong>NOTE:</strong> The installation procedure mentions the directory, <code>pgtxr</code>.</p>
<h2 id='182-macintosh-and-windows-users'>18.2 Macintosh and Windows Users</h2>
<p>Simply add the following files from the <code>pgtxr</code> directory to your project:</p>
<h3 id='minimum-configuration-export-ascii-text-only'>Minimum configuration (export ASCII text only):</h3>
<pre><code>pgexport.cpp
pgdeftbl.c
</code></pre>
<h4 id='native-hermes-paige-file-export-in-addition-to-above'>Native HERMES Paige File Export (in addition to above)</h4>
<pre><code>pgnative.cpp
</code></pre>
<h4 id='rtf-file-export-in-addition-to-minimum-configuration'>RTF File Export (in addition to Minimum Configuration)</h4>
<pre><code>pgrtfdef.c
pgrtfexp.cpp
</code></pre>
<p>If you will be exporting files using C++:</p>
<pre><code>#include &quot;pgtxrcpp.h&quot;
</code></pre>
<p>If you will be exporting only from straight C:</p>
<pre><code>#include &quot;pgtxr.h&quot;
</code></pre>
<h2 id='183-exporting-files-from-c++'>18.3 Exporting Files (from C++)</h2>
<p><strong>NOTE:</strong> <em>Exporting</em>, in many cases, is synonymous to <em>saving</em>. We use the term &quot;export&quot; only to distinguish it from earlier methods of saving HERMES Paige files (such as <code>pgSaveDoc</code>); from an implementation viewpoint, however, your application can respond to <code>Save</code> and <code>Save As</code> by &quot;exporting&quot; a file.</p>
<p>Exporting a file with this extension can be accomplished in a few easy steps:</p>
<ol start='' >
<li>To export to a disk file, create and open the file you wish to export. To export to memory, allocate an empty <code>memory_ref</code> (using <code>MemoryAlloc</code>).</li>

</ol>
<p>  <strong>NOTE:</strong> You can discover the recommended file type (Macintosh) or file extension (Windows) by examining the <code>file_kind</code> member of the export class — see section 18.5, <a href='#185-file-type-and-extension'>File Type and Extension</a>).</p>
<ol start='2' >
<li><p>Create a new object (with <code>new</code> keyword) of the appropriate type for the file. Currently we support raw text files, RTF and HERMES Paige files. The following is an example of creating an appropriate export object:</p>
<pre><code>#include &quot;pgTxrCPP.h&quot;
PaigeExportObject filter;

// To export a plain ASCII text file:
filter = new PaigeExportFilter();

// To export an RTF file:
filter = (PaigeExportObject) new PaigeRTFExportFilter();

// To export a HERMES Paige file:
filter = (PaigeExportObject) new PaigeNativeExportFilter();
</code></pre>
</li>
<li><p>Call the initialisation member function, <code>pgInitExportFile()</code>. This function prepares for exporting a file, setting up whatever is necessary to write file&#39;s native format. A file can be exported to a physical file, or to memory, differentiated by the value(s) you pass in the function parameters. The <code>pgInitExportFile()</code> function is defined as follows:
	</p>
<pre><code>pg_error pgInitExportFile (pg_globals_ptr globals, pg_file_unit fileref, memory_ref memory_unit, file_io_proc write_proc, long first_position);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> If this function is successful, zero is returned, otherwise an error code is returned.</p>
</li>
<li><p>Call the member function, <code>pgExportFile()</code>. This exports the data from a <code>pg_ref</code> to the file (or <code>memory_ref</code>) specified in <code>pgInitExportFile()</code>. The <code>pgInitExportFile()</code> function is defined as follows:</p>
<pre><code>pg_error pgExportFile (pg_ref pg, select_pair_ptr range, long export_flags, pg_boolean selection_only);
</code></pre>
<p>-
<strong>FUNCTION RESULT:</strong> If this function is successful, zero is returned; otherwise, an error code is returned.</p>
</li>
<li><p>Delete the object; alternatively, repeat steps 3 through 4 if you want to export another file.</p>
</li>

</ol>
<h3 id='pginitexportfile---parameters'><code>pgInitExportFile()</code> - Parameters</h3>
<ul>
<li><p><code>globals</code> - A pointer to your HERMES Paige globals. Custom control users: You can get a pointer to the HERMES Paige globals as follows: </p>
<ol start='' >
<li>Get the <code>pg_ref</code> from the control by
sending a PG_GETPGREF message, and </li>
<li>Call the HERMES Paige API, <code>pgGetGlobals()</code>.</li>

</ol>
</li>
<li><p><code>fileref</code> - If exporting to a disk file, this parameter must be a reference to the opened file (the <code>refNum</code> for Macintosh, or a file handle for Windows). If exporting to memory, <code>fileref</code> should be zero. If using the <em>Microsoft Foundation Classes</em> on <em>Windows</em>, the <code>fileref</code> parameter must be a &quot;real&quot; <code>HFILE</code> (or NULL if exporting to memory), not some other MFC-generated class member that you may assume is a file handle.</p>
</li>
<li><p><code>memory_unit</code> — If exporting to a disk file, this parameter must be <code>MEM_NULL</code>. If exporting to memory, this must be a <code>memory_ref</code> of zero byte size (see chapter 25, <a href='#25-the-allocation-manager'>The Allocation Manager</a>).</p>
</li>
<li><p><code>write proc</code> — This is an optional I/O function to be used instead of the default lowlevel writing function. Refer to the HERMES Paige Programmer&#39;s Guide for information about custom I/O functions. For writing to standard file from disc or memory, pass <code>NULL</code> for this parameter.</p>
</li>
<li><p><code>first_position</code> — This value indicates the beginning file position to write. The <code>first_position</code> can be zero or some other byte offset into the file to begin writing.</p>
</li>

</ul>
<h3 id='pgexportfile---parameters'><code>pgExportFile()</code> - Parameters</h3>
<ul>
<li><p><code>pg</code> - The source document. Custom control users: obtain the <code>pg_ref</code> by sending a <code>PG_GETPGREF</code> message.</p>
</li>
<li><p><code>range</code> - The selection range (in the HERMES Paige document) to export. This parameter is ignored, however, if <code>selection_only</code> is <code>FALSE</code> (in which case the whole document is exported). If <code>range</code> is <code>NULL</code> and <code>selection_only</code> is <code>TRUE</code>, only the current selection range is exported. If <code>range</code> is <code>NULL</code> and <code>selection_only</code> is <code>FALSE</code>, the entire document is exported.</p>
</li>
<li><p><code>export_flags</code> — A set of bits defining which item(s) to export, which can be any or all of the data types shown below.</p>
<p><strong>NOTE:</strong> Setting these bits causes that data item to export only if supported by the exporter.</p>
</li>

</ul>
<pre><code>	#define EXPORT_TEXT_FLAG				0x00000001L	/* Export raw text */
	#define EXPORT_TEXT_FORMATS_FLAG		0x00000002L	/* Export text formats */
	#define EXPORT_PAR_FORMATS_FLAG			0x00000004L	/* Export paragraph formats */
	#define EXPORT_PAGE_INFO_FLAG			0x00000008L	/* Export page info */
	#define EXPORT_CONTAINERS_FLAG			0x00000010L	/* Export container boxes */
	#define EXPORT_HEADERS_FLAG				0x00000020L	/* Export headers */
	#define EXPORT_FOOTERS_FLAG				0x00000040L	/* Export footers */
	#define EXPORT_FOOTNOTES_FLAG			0x00000080L	/* Export footnotes */
	#define EXPORT_EMBEDDED_OBJECTS_FLAG	0x00000100L	/* Export recognized embed_refs */
	#define EXPORT_PAGE_GRAPHICS_FLAG		0x00000200L	/* Export page-anchored pictures */
	#define EXPORT_STYLESHEETS_FLAG			0x00000400L	/* Export defined stylesheets */
	#define EXPORT_HYPERTEXT_FLAG			0x00000800L	/* Export hypertext links (or index, toc). */
	#define INCLUDE_LF_WITH_CR				0x02000000L	/* Add LF with CR if not already */
	#define EXPORT_CACHE_FLAG				0x04000000L	/* Export cached file */
	#define EXPORT_UNICODE_FLAG				0x08000000L	/* Write text as UNICODE */
	#define EXPORT_EVERYTHING_FLAG			0x00FFFFFFL	/* Export everything you can */
</code></pre>
<ul>
<li><p><code>selection_only</code> — If <code>TRUE</code>, the only current selection (or the selection specified in the range parameter) is exported. If <code>range</code> is <code>NULL</code> and selection_only is <code>TRUE</code>, only the current selection range is exported. If range is <code>NULL</code> and <code>selection_only</code> is <code>FALSE</code>, the whole document is exported.</p>
<p><strong>FUNCTION RESULT:</strong> If this function is successful, zero is returned, otherwise an error code is returned.</p>
</li>

</ul>
<h3 id='export-file-example'>Export File Example</h3>
<pre><code class='language-c' lang='c'>#include &quot;pgTxrCPP.h&quot;

/* This function exports a file from a pg_ref, first creating an object for the appropriate file type. If all is well, NO_ERROR is returned. */

pg_error ExportFile (pg_ref pg, pg_filetype filetype, long feature_flags, select_pair_ptr output_range, pg_boolean use_selection, pg_file_unit f_ref)

{
	PaigeExportObject filter;
	pg_globals_ptr globals;
	long flags, file_begin;
	pg_error result = NO_ERROR;
	
	if (!(flags = feature_flags))
		flags = EXPORT_EVERYTHING_FLAG;
		globals = pgGetGlobals (pg);
		
	switch (filetype)
	{
		case pg_text_type:
			filter = new PaigeExportFilter();
			break;
		case pg_rtf_type:
			filter = (PaigeExportObject) new PaigeRTFExportFilter();
			break;
		case pg_paige_type:
			filter = (PaigeExportObject) new PaigeNativeExportFilter();
			break;
		default:
			return (pg_error)BAD_TYPE_ERR;
	}
	
	if (!output_range)
		file_begin = 0;
	else
		file_begin = output_range -&gt; begin;
		
	if ((result = filter -&gt; pgInitExportFile(globals, f_ref, MEM_NULL, NULL, file_begin)) == NO_ERROR)
		result = filter -&gt; pgExportFile(pg, output_range, flags, use_selection);
		delete filter
		return result;
}
</code></pre>
<h3 id='184-determining-the-feature-set'>18.4 Determining the Feature Set</h3>
<p>You can determine what data type(s) are supported by the exporter if you examine <code>object -&gt; feature_bits</code> immediately after creating the export object. This member will be initialised to some combination of the following:</p>
<pre><code class='language-c' lang='c'>#define EXPORT_TEXT_FEATURE							0x00000001L	/* Can Export raw text */
#define EXPORT_TEXT_FORMATS_FEATURE			0x00000002L	/* Can Export text formats */
#define EXPORT_PAR_FORMATS_FEATURE			0x00000004L	/* Can Export paragraph formats */
#define EXPORT_PAGE_INFO_FEATURE				0x00000008L	/* Can Export page dimensions */
#define EXPORT_CONTAINERS_FEATURE				0x00000010L	/* Can Export containers */
#define EXPORT_HEADERS_FEATURE					0x00000020L	/* Can Export headers */
#define EXPORT_FOOTERS_FEATURE					0x00000040L	/* Can Export footers */
#define EXPORT_FOOTNOTES_FEATURE				0x00000080L	/* Can Export footnotes */
#define EXPORT_EMBEDDED_OBJECTS_FEATURE	0x00000100L	/* Can Export standard, supported embed_refs */
#define EXPORT_PAGE_GRAPHICS_FEATURE		0x00000200L	/* Can Export graphics anchored to page */
#define EXPORT_HYPERTEXT_FEATURE				0x00000400L	/* Can Export hypertext (or index, toc, etc. */
#define EXPORT_CACHE_FEATURE						0x00100000L	/* Can Export cache method */
#define EXPORT_UNICODE_FEATURE					0x00200000L	/* Can export UNICODE */
</code></pre>
<h4 id='example-9'>EXAMPLE:</h4>
<pre><code>PaigeExportObject filter;
filter = (PaigeExportObject) new PaigeRTFExportFilter();

if (!(filter-&gt;feature_bits &amp; EXPORT_EMBEDDED_OBJECTS_FEATURE))
	AlertUser(&quot;Any pictures in document will be lost. Save anyway?&quot;);
</code></pre>
<h3 id='resulting-file-size'>Resulting File Size</h3>
<p>If exporting is successful, the physical end-of-file is set to the first position beyond the last byte written (if writing to a disk file). If exporting to memory, the <code>memory_ref</code> is set to the exact size that was saved.</p>
<h2 id='185-file-type-and-extension'>18.5 File Type and Extension</h2>
<p>For Windows development, it may be convenient to determine what type of file extension to create (e.g., &quot;.txt”, “.rtf”, etc.); for Macintosh it may also be convenient to determine the default type (&quot;TEXT&quot;, &quot;RTF_&quot;, etc.). This might become increasingly important in the future if many export classes are developed.</p>
<p>Every export class will place the recommended file type or extension into the following member by its constructor function:</p>
<pre><code>pg_by tefile_kind[KIND_STR_SIZE];	// Recommended filetype
</code></pre>
<p>If running in a Windows environment, <code>file_kind</code> will be initialised to the recommended 3-character extension (&quot;TXT&quot;, &quot;RTF&quot;, etc.). If running in a Macintosh environment, <code>file_kind</code> will get set to the recommended 4-character file type.</p>
<h2 id='186-exporting-from-c'>18.6 Exporting from C</h2>
<p>If you need to export a file from a non-C++ environment—or if you want to import a file from a single line of code—you can do so by calling the following function:</p>
<pre><code>pg_error pgExportFileFromC (pg_ref pg, pg_filetype filetype, long feature_flags, long file_begin, select_pair_ptr output_range, pg_boolean use_selection, pg_file_unit f_ref);
</code></pre>
<p>This function exports a file of type filetype into <code>pg</code>. The filetype parameter must be one of the following:</p>
<pre><code>pg_text_type,	// Standard ASCII text 
pg_rtf_type,	// RTF format
pg_paige_type	// Standard HERMES Paige file type
</code></pre>
<p>The <code>feature_flags</code> parameter indicates which data type(s) you want to export, which can be any of the following bit settings:</p>
<pre><code>#define EXPORT_TEXT_FLAG				0x00000001	// Export raw text
#define EXPORT_TEXT_FORMATS_FLAG		0x00000002	// Export text formats
#define EXPORT_PAR_FORMATS_FLAG			0x00000004	// Export paragraph formats
#define EXPORT_PAGE_INFO_FLAG			0x00000008	// Export page info
#define EXPORT_CONTAINERS_FLAG			0x00000010	// Export container boxes
#define EXPORT_HEADERS_FLAG				0x00000020	// Export headers
#define EXPORT_FOOTERS_FLAG				0x00000040	// Export footers
#define EXPORT_FOOTNOTES_FLAG			0x00000080	// Export footnotes
#define EXPORT_EMBEDDED_OBJECTS_FLAG	0x00000100	// Export recognized embed_refs
#define EXPORT_PAGE_GRAPHICS_FLAG		0x00000200	// Export page-anchored pictures
#define EXPORT_STYLESHEETS_FLAG			0x00000400L	// Export defined stylesheets
#define EXPORT_HYPERTEXT_FLAG			0x00000800	// Export hypertext links (or index, toc).
#define INCLUDE_LF_WITH_CR				0x02000000	// Add LF with CR if not already
#define EXPORT_CACHE_FLAG				0x04000000	// Export cached file
#define EXPORT_UNICODE_FLAG				0x08000000	// Write text as UNICODE
#define EXPORT_EVERYTHING_FLAG			0x00FFFFFF	// Export everything you can
</code></pre>
<p>&nbsp;</p>
<p>The <code>file_begin</code> parameter indicates the first file position to begin writing.</p>
<p>The <code>output_range</code> and <code>use_selection</code> parameters indicate the range of text to export: if <code>use_selection</code> is FALSE, <code>output_range</code> is ignored and the entire document is exported. If <code>use_selection</code> is TRUE, the selection specified in <code>output_range</code> is specified (or if NULL the current selection in <code>pg</code> is used).</p>
<p>The <code>f_ref</code> parameter must be a reference to an opened file ( <code>refNum</code> for Mac, file handle for Windows).</p>
<p>If this function is successful, the contents of the <code>pg_ref</code> are written to the file, the end-of-file mark is set and <code>NO_ERROR</code> (0) is returned.</p>
<h2 id='187-the-hermes-paige-export-filter-overridables'>18.7 The HERMES Paige Export Filter: Overridables</h2>
<pre><code>class PaigeExportFilter
{
	pg_char file_kind[KIND_STR_SIZE]; // Recommended filetype
	
	virtual pg_char_ptr pgPrepareEmbedData (embed_ref ref, long PG_FAR *byte_count, long PG_FAR *local_storage);
	
	virtual void pgReleaseEmbedData (embed_ref ref, long local_storage);
	virtual pg_error pgPrepareExport (void);
	virtual pg_boolean pgWriteNextBlock (void);
	virtual pg_error pgExportDone ();
</code></pre>
<p><strong>NOTE:</strong> All of the class definitions are not shown. Only the members of potential interest and usefulness are given. For a complete description of this class, see <code>pgtxrcpp.h</code>.</p>
<h3 id='member-by-member-description-2'>Member-by-Member Description</h3>
<p><code>file_kind</code> — Contains the recommended file type (Mac) or file extension (Windows). This is initialised by the class constructor.</p>
<p><code>pgPrepareExport()</code> — Called to make any preparations for exporting the file. No actual file transfer is performed, but this function should be used to initialise private members to perform the first &quot;write&quot;. There are no parameters to this function. The values taken from the application&#39;s call to <code>pgInitExportFile()</code> will have been placed into the appropriate member values before <code>pgPrepareExport()</code> is called.</p>
<p><code>pg_boolean pgWriteNextBlock()</code> — Called to export (write) the next block of text. A &quot;block of text&quot; means a block of one or more characters that are rendered in the same consistent format.</p>
<p>For example, if the outgoing text contained &quot;<strong>Bold</strong>_Plain_<em>Italic</em>&quot;, the export class must consider <code>Bold_</code>, <code>Plain_</code> and <code>Italic_</code> as three separate blocks. The first time <code>pgWriteNextBlock()</code> gets called, the text <code>Bold_</code> would be provided; the next time <code>Plain_</code> is provided, and so forth.</p>
<p>The text and format information is placed in the <code>translator</code> member of the class; this member is a record as defined in the following example:</p>
<pre><code>struct pg_translator 
{
	memory_ref		data;				// Data transferred (read) or to-transfer (write)
	memory_ref		stylesheet_table;	// Contains list of possible stylesheets
	long			bytes_transferred;	// Number of bytes in buffer
	long			total_text_read;	// Total transferred to-moment
	long			cache_begin;		// Beginning file offset (if cache enabled)
	style_info		format;				// Style(s) and character format of text
	par_info		par_format;			// Paragraph format(s) of the text
	font_info		font;				// Font applied to this text
	pg_doc_info		doc_info;			// General document information
	pg_hyperlink	hyperlink;			// Hypertext link
	pg_hyperlink	hyperlink_target;	// Target hypertext link
	unsigned long	flags;				// Attributes of last transfer
	pg_boolean		format_changed;		// Set to TRUE if format is different than last txr
	pg_boolean		par_format_changed;	// Set to TRUE if par format different than last txr
	pg_boolean		font_changed;		// Set to TRUE if font different than last txr
	pg_boolean		doc_info_changed;	// Set to TRUE if document info changed since last txr
	pg_boolean		hyperlink_changed;	// Set to TRUE if a hypertext link gets added
	pg_boolean		hyperlink_target_changed;  // Set to true if hyperlink target changes
	long			par_format_verb;	// Verb that indicates how to apply par_format
	long			par_format_mark;	// Used with par_mark and verb
};
</code></pre>
<p>Text byte(s) are available in <code>translator.data</code>; the byte size can be determined with <code>GetMemorySize(translator.data)</code>.</p>
<p>For each consecutive call to <code>pgWriteNextBlock()</code>, if <code>format_changed</code>, <code>par_format_changed</code>, or <code>font_changed</code> are TRUE then the text format, paragraph format or font is different than the last <code>pgWriteNextBlock()</code> call, respectively.</p>
<p>For the best examples of <code>pgReadWriteBlock()</code> consult the source code files for each import class.</p>
<p><strong>FUNCTION RESULT:</strong> If TRUE is returned, <code>pgWriteNextBlock()</code> will get called again if there is any more text to export; if FALSE is returned, exporting is aborted.</p>
<p><code>pgExportDone()</code> — Called after exporting has completed. This function essentially balances <code>pgPrepareExport(). Anything you allocated previously in</code>pgPepareExport()` should be disposed.</p>
<p><code>pg_error pgPrepareEmbedData()</code> — Called to prepare <code>embed_ref</code> data to be exported. The purpose of this function is to make any data conversions necessary to provide a serialised, binary stream of data to be exported.</p>
<p>Upon entry, the <code>ref</code> parameter is the <code>embed_ref</code> that is about to be exported. This function needs to return a pointer to byte stream to transfer and the byte count of the byte stream should be stored in <code>*byte_count</code>.</p>
<p>The <code>local_storage</code> parameter is a pointer to a long word; whatever is placed in <code>*local_storage</code> will be returned in <code>pgReleaseEmbedData()</code>, below. The purpose of this parameter is to provide a way for <code>pgPrepareEmbedData()</code> to &quot;remember&quot; certain variables required to un-initialise the <code>embed_ref</code> data (for example, <code>*local_storage</code> might be used to save a <code>HANDLE</code> that gets locked, hence it can be unlocked when <code>pgReleaseEmbedData()</code> is called).</p>
<h3 id='default-function-2'>Default Function</h3>
<p>The default <code>pgPrepareEmbedData()</code> function processes a Mac picture by locking the <code>PicHandle</code> and returning a de-referenced pointer to the <code>PicHandle</code> contents; if the runtime platform is Windows, a metafile is processed by returning the metafile bits.</p>
<p><code>pgReleaseEmbedData()</code> is called to balance a previous call to <code>pgPrepareEmbedData()</code>. The purpose of this function is to deïnitialise anything that was done in <code>pgPrepareEmbedData()</code>, and it gets called after the <code>embed_ref</code> data has been exported.</p>
<p>Upon entry, the <code>ref</code> parameter is the <code>embed_ref</code>, the <code>local_storage</code> parameter will contain whatever value was set in <code>*local_storage</code> during <code>pgPrepareEmbedData()</code>.</p>
<h2 id='188-rtf-export-overrideables'>18.8 RTF Export Overrideables</h2>
<p>The RTF export class is derived from <code>PaigeExportFilter</code> and has some RTF-specific functions that can be overridden as well as data members that may prove usefrul:</p>
<pre><code>class PaigeRTFExportFilter : public PaigeExportFilter 
{
	public:
		virtual pg_error OutputHeaders ();
		virtual pg_error OutputFooters ();
		virtual pg_error OutputEmbed ();
		virtual pg_error OutputCustomParams();

		pg_char def_stylename[FONT_SIZE + BOM_HEADER]; // Default &quot;normal&quot; stylesheet name
}
</code></pre>
<p>This member function is called to export document headers; the default function does nothing (since HERMES Paige does not directly support headers). To implement this feature (in terms of export), see section 18.10, <a href='#1810-custom-rtf-output'>Custom RTF Output</a>.</p>
<pre><code>pg_error OutputFooters ();
</code></pre>
<p>This member function is called to export document footers; the default function does nothing (since HERMES Paige does not directly support footers). To implement this feature (in terms of export), see section 18.10, <a href='#1810-custom-rtf-output'>Custom RTF Output</a>.</p>
<pre><code>pg_error OutputEmbed();
</code></pre>
<p>This member function gets called to export an <code>embed_ref</code>. Upon entry, the <code>embed_ref</code> to be exported is available as:</p>
<pre><code>this -&gt; translator.format.embed_object;
</code></pre>
<p>The default function handles the &quot;supported&quot; <code>embed_ref</code> types — <code>embed_mac_pict</code> and <code>embed_meta_file</code>. To implement exporting of other types, you need to override this function and handle the data transfer in some way that is appropriate.</p>
<pre><code>OutputCustomParams();
</code></pre>
<p>This function gets called after all text and paragraph formatting attributes have been exported, but before any text has been exported for each call to <code>pgWriteNextBlock()</code>. The purpose of this function is to output additional formatting information.</p>
<p>For example, HERMES Paige 3.0 does not support paragraph borders, but if they were implemented by your application you might want to output border information when appropriate.</p>
<p>The default function does nothing; to write your own RTF data, see section 18.10, <a href='#1810-custom-rtf-output'>Custom RTF Output</a>.</p>
<h2 id='189-lower-level-export-member-functions'>18.9 Lower-level Export Member Functions</h2>
<p>Typically, to create new or custom export classes, you would override <code>PaigeExportFilter</code> (or a subclass thereof). When you do so, the following lower-level member functions are available to assist you in exporting data to the target file:</p>
<pre><code>void pgWriteByte (pg_char the_byte);
</code></pre>
<p>This sends a single byte to the output file.</p>
<pre><code>pgWriteNBytes (pg_char_ptr bytes, long num_bytes);
</code></pre>
<p>This sends to the output file; the bytes are taken from the bytes pointer.</p>
<pre><code>void pgWriteDecimal (short decimal_value);
</code></pre>
<p>Sends an ASCII representation of <code>decimal_value</code> to the target file. For example, a binary value of -2 would be sent out as (ASCII) &quot;-2&quot;. All leading zeros are suppressed (i.e., a value of 1 is sent as &quot;1&quot;, not &quot;000001&quot;).</p>
<pre><code>void pgWriteHexByte (pg_char the_byte);
</code></pre>
<p>Sends a hex representation of <code>the_byte</code> to the target file. For example, a binary value of 0x0A would be sent out as (ASCII) &quot;0A&quot;.</p>
<pre><code>void pgWriteString (pg_char_ptr the_str, pg_char prefix, pg_char suffix);
</code></pre>
<p>Sends the contents of <code>the_str</code> (a null-terminated string) to the output file. If prefix is non-zero, that byte is sent first before the contents of the string are sent; if suffix is non-zero, that byte is sent after the contents of <code>the_str</code> is sent.</p>
<h2 id='1810-custom-rtf-output'>18.10 Custom RTF Output</h2>
<p>If you have derived a new class from <code>PaigeRTFExportFilter</code>, the following member functions are available to assist you with exporting custom RTF data:</p>
<pre><code>void WriteCommand (pg_char_ptr rtf_table, short table_entry, short PG_FAR *parameter, pg_boolean delimeter);
</code></pre>
<p><code>WriteCommand</code> will write an RTF token word, followed by an optional parameter value and character delimiter to the output file.</p>
<p>The table parameter should be a null-terminated string containing one or more token word entries, each entry separated by a single space character. The <code>table_entry</code> parameter must indicate which of these elements to write.</p>
<h3 id='notes-23'>NOTES:</h3>
<ol start='' >
<li><p>The first element is 1, not zero.</p>
</li>
<li><p>The &quot;token&quot; entries in this string have no significance to this function; rather, the <em>n</em>th element (<code>table_entry</code>) of the space-delineated table is merely written to the output file.</p>
<p>The token word must not contain any special command character — only ASCII characters less than 0x7B should be contained in this string, and the token word must terminate with a space character (the space character is not sent to the output). This function will automatically prefix the token word output with the RTF command character (&quot;\&quot;).</p>
<p>If <code>parameter</code> is non-<code>NULL</code>, then the value in <code>*parameter</code> is appended to the output as an ASCII numeral. For example, if the token were <code>bonus</code> and <code>*parameter</code> contained a value of 3, the resulting output would be: <code>\bonus3</code></p>
<p>If <code>delimeter</code> is <code>TRUE</code>, a single space character is output following the token word; otherwise no extra characters are output.</p>
</li>

</ol>
<h4 id='example-1-2'>EXAMPLE 1</h4>
<pre><code>pgWriteCommand((pg_char_ptr) &quot;border \0&quot;, 1, NULL, FALSE);
</code></pre>
<h5 id='output'>OUTPUT</h5>
<pre><code>&quot;\lborder &quot;
</code></pre>
<h4 id='example-2-2'>EXAMPLE 2</h4>
<pre><code>	short param;
	param = 24;
	pgWriteCommand((pg_char_ptr) &quot;border \0&quot;, 1, &amp;param, TRUE);
</code></pre>
<h5 id='output-2'>OUTPUT:</h5>
<pre><code>&quot;\border24 &quot;
</code></pre>
<h4 id='example-3'>EXAMPLE 3</h4>
<pre><code>pg_char custom_table[] = {&quot;comment footer footerl footerf footerr footnote &quot;};
pgWriteCommand(custom_table, 6, NULL, TRUE);
</code></pre>
<h5 id='output-3'>OUTPUT:</h5>
<pre><code>&quot;\footnote &quot;
</code></pre>
<pre><code>OutputCR (pg_boolean unconditional);
</code></pre>
<p><code>OutputCR</code> outputs a hard carriage return. If <code>unconditional</code> is <code>FALSE</code>, the carriage return is not output unless no carriage returns have been output during the last 128 or more characters; if <code>unconditional</code> is <code>TRUE</code>, the carriage return is output notwithstanding the previously output characters.</p>
<pre><code>short PointConversion (short value, pg_boolean convert_resolution, pg_boolean x10);
</code></pre>
<p><code>PointConversion</code> converts value to points and/or decipoints (a decipoint is a tenth of a point). If <code>convert_resolution</code> is <code>TRUE</code>, the value given to this function is converted to points (1/72 of an inch or equivalently 1/12 of a pica) based on the current screen resolution setting. If <code>x10</code> is <code>TRUE</code>, the resulting output is multiplied times 10 before being returned as the function result.</p>
<p>Hence, if <code>value</code> is a screen size value (for example, the pixel width of a graphic), passing <code>TRUE</code> for both <code>convert_resolution</code> and <code>x10</code> would result in a true decipoint conversion.</p>
<h1 id='19-paragraph-borders-and-shading'>19 PARAGRAPH BORDERS AND SHADING</h1>
<h2 id='191-borders'>19.1 Borders</h2>
<p>A &quot;paragraph border&quot; is a frame drawn around one or more paragraphs and is part of the paragraph format (<code>par_info</code>) definition.</p>
<p>Paragraph borders are defined as four potential sides to a frame. Any one side may be drawn or not. Hence, a paragraph border can be defined to show only part of the frame (such as the bottom side), or two sides, or all four sides, etc.</p>
<h3 id='setting-a-border'>Setting a Border</h3>
<p>Borders are set by changing the &quot;table&quot; structure within the <code>par_info</code> structure, as shown below. Applying the <code>par_info</code> to the desired portion of the text will render the affected paragraphs with that border definition:</p>
<pre><code>struct par_info
{
	// various members in par_info

	pg_table table;	// Table and border info

	// more members in par_info
};
</code></pre>
<p>The table member contains information for both tables and paragraph borders:</p>
<pre><code>struct pg_table
{
	// various members of pg_table
	
	long border_info;	// Borders for paragraph
	
	// more members of pg_table
};
</code></pre>
<p>NOTE: The <code>pg_table</code> record, generally used for defining table formats, also contains the definition for the paragraph borders, if any. If <code>table.table_columns</code> is zero, <code>border_info</code> is applied to the whole paragraph; if <code>table.table_columns</code> is non-zero, <code>border_info</code> applies to frame of the table.</p>
<p>If <code>par_info.table.border_info</code> is zero, the paragraph has no borders. Otherwise, borders are defined by one or more of the following bit combinations:</p>
<pre><code>#define PG_BORDER_LEFT		0x000000FF	/* Left border */
#define PG_BORDER_RIGHT		0x0000FF00	/* Right border */
#define PG_BORDER_TOP		0x00FF0000	/* Top border */
#define PG_BORDER_BOTTOM	0xFF000000	/* Bottom border */
</code></pre>
<p>Each of the above definitions define 8-bit fields within a long word for each side of a border; which bits you should set in each 8-bit field depends upon the desired border effect.</p>
<p>In other words, the lowest-ordered byte defines the properties of the left border line; the second lowest byte defines the properties of the right border line; the next higher bytes define the properties of the top and bottom lines.</p>
<p>For each of these four 8-bit fields, the following properties can be set:</p>
<p><strong>Lower three bits:</strong> define the width of the border line, in pixels. This may be any value between 0 and 0x07, inclusively. If the value is zero, no line is drawn; otherwise, a line is drawn 1 to 7 pixels wide.</p>
<p><strong>Upper five bits:</strong> define additional characteristics for the line, as follows:</p>
<pre><code>#define PG_BORDER_GRAY		0x00000008	// Grey border
#define PG_BORDER_DOTTED	0x00000010	// Dotted line
#define PG_BORDER_SHADOW	0x00000020	// Shadow effect
#define PG_BORDER_DOUBLE	0x00000040	// Double lines
#define PG_BORDER_HAIRLINE	0x00000080	// Hairline
</code></pre>
<p>The following border definitions are also provided that represent commonly applied borders:</p>
<pre><code>#define PG_BORDER_ALLGRAY	0x08080808 // All sides grey
#define PG_BORDER_ALLDOTTED	0x10101010 // All sides dotted
#define PG_BORDER_ALLDOUBLE	0x40404040 // All sides double
#define PG_BORDER_ALLSIDES	0x01010101 // All sides 1 pixel
#define PG_BORDER_SHADOWBOX	0x21012101 // Shadowbox all sides
</code></pre>
<p>Some of these definitions need to be combined. For example, to obtain a four-sided double border you would set <code>par_info.table.border_info</code> to:</p>
<pre><code>PG_BORDER_ALLDOUBLE | PG_BORDER_ALLSIDES
</code></pre>
<p>To set a four-sided gray border you would use:</p>
<pre><code>PG_BORDER_ALLGRAY | PG_BORDER_ALLSIDES
</code></pre>
<h3 id='192-paragraph-shading'>19.2 Paragraph Shading</h3>
<p>Paragraph shading is an optional colour that will fill the background of a paragraph. Usually this shading applies to table formats, yet paragraph shading can be drawn for non-table paragraphs as well.</p>
<p>Shading set by changing the <code>table</code> structure within the <code>par_info</code> structure, as shown below. Applying the <code>par_info</code> to the desired portion of the text will render the affected paragraphs with that shading (colour) definition:</p>
<pre><code>struct par_info
{
	... various members in par_info ...
	
	pg_table table; // Table and border info
	
	... more members in par_info ...
};
</code></pre>
<p>The <code>table</code> member contains information for both tables and paragraph borders:</p>
<pre><code>struct pg_table
{
	// various members of pg_table
	
	long border_shading;	// Background shading
	
	// more members of pg_table
};
</code></pre>
<p>NOTE: The <code>pg_table</code> record, generally used for defining table formats, also contains the definition for paragraph shading, if any. If <code>table.table_columns</code> is zero, <code>border_shading</code> is applied to the whole paragraph; otherwise, <code>border_shading</code> applies to default background shading of the table.</p>
<p>If <code>border_shading</code> is zero, no shading is applied; otherwise, <code>border_shading</code> represents a &quot;red-green-blue&quot; component using bitwise fields <code>0x00BBGGRR</code>. The <code>BB</code> bits represent the blue component of the color, the <code>GG</code> bits represent the green component, and <code>RR</code> represents the red component.</p>
<p><strong>NOTE:</strong> These bits are identical to the bits in a <em>Windows</em> <code>COLORREF</code>.</p>
<h1 id='20-hermes-paige-hypertext-links'>20 HERMES Paige HYPERTEXT LINKS</h1>
<h2 id='201-general-concept'>20.1 General Concept</h2>
<p>A &quot;hypertext link&quot; is similar to a character style and can be applied to groups of characters anywhere in the document. However, its attributes are independent to the text and paragraph formats.</p>
<p>HERMES Paige maintains two hypertext link runs - a source run and target run.</p>
<p>The hypertext link source run generally contains all the visual links (e.g. displayed in a different colour, underlined, and expected to provide some type of response when the user clicks).</p>
<p>The target run generally contains &quot;markers&quot; for the source run links to locate. In actuality, the source and target runs are independent of each other and each run knows nothing about the other. It is therefore the responsibility of the application to provide logical &quot;linking&quot; between them.</p>
<p>Most of the functions and definitions are in <code>pghtext.h</code>; you should therefore add the following to your code:</p>
<pre><code>#include &quot;pghtext.h&quot;
</code></pre>
<h2 id='203-contents-of-a-hypertext-link'>20.3 Contents of a Hypertext Link</h2>
<p>Every hypertext link is stored as a record structure containing the following information:</p>
<h3 id='text-range'>Text range</h3>
<p>The beginning and ending position of the link. This text range is maintained by HERMES Paige as the document is changed.</p>
<h3 id='url-string'>URL string</h3>
<p>Link-specific information represented by a <code>cstring</code>. The HERMES Paige API refers to this mostly as the &quot;URL&quot; parameter, but in reality this is simply a string. Both source and target hypertext links each contain their own URL string; it is the application&#39;s responsibility to understand and/or parse its contents.</p>
<h3 id='display-styles'>Display styles</h3>
<p>Style(s) that define how the hypertext link should be drawn in various states. These styles are represented by HERMES Paige stylesheet ID(s). For each link created there are default stylesheets created; the application can override these defaults, hence displaying the links in any text style that HERMES Paige supports.</p>
<h3 id='note-27'>Note</h3>
<p>This document makes reference to a &quot;URL&quot; member of the hypertext link record. The &quot;URL&quot; in this sense is merely a data string and is not to be confused with a genuine network locator address (although it can be used as such by an application).</p>
<h2 id='204-setting-new-links'>20.4 Setting New Links</h2>
<h3 id='setting-source-links'>Setting Source Links</h3>
<p><code>long pgSetHyperlinkSource (pg_ref pg, select_pair_ptr selection, pg_char_ptr URL, pg_char_ptr keyword_display, ht_callback callback, long type, long id_num, short state1_style, short state2_style, short state3_style, short draw_mode);</code></p>
<h4 id='purpose'>Purpose</h4>
<p>Sets a new source hypertext link. A link is &quot;set&quot; by applying the attributes (defined by the other parameters in this function) to one or more characters in the document.</p>
<h4 id='parameters-2'>Parameters</h4>
<ul>
<li><code>pg</code> — The <code>pg_ref</code> to receive the link.</li>
<li><code>selection</code> — An optional range of text to apply the link. If selection is NULL, then current selection (highlighting) is used.</li>
<li><code>URL</code> — An optional string that will get stored with the link. If NULL, no string is stored; otherwise, the <code>URL</code> parameter is considered a <code>cstring</code> of any length. The <code>URL</code> string can be accessed and/or changed later by your application if necessary.</li>
<li><code>keyword_display</code> An optional string to insert that displays as the key word for the link. If this is NULL, the characters contained in the selection parameter become the &quot;key word&quot;; otherwise, the <code>keyword_display</code> parameter is inserted into the beginning of the specified selection and the character range of the link becomes the beginning of that insertion + the length of
<code>keyword_display</code>.</li>
<li><code>callback</code> — Pointer to a callback function (which you provide) that is called when the hypertext link is clicked. If <code>callback</code> is NULL the default callback function is used.</li>
<li><code>type</code> — An optional type variable. This value can be used by the application to distinguish between different types of links.</li>
<li><code>id_num</code> — An optional unique ID value. This can be used for searching and connecting links. The typical use for <code>id_num</code> is to set this value to a number that exists in the same field for a target link. You can then call <code>pgFindHyperlinkTargetByID()</code>.</li>
<li><code>state1_style</code> through <code>state3_style</code> — Optional stylesheet IDs that define the display attributes for three different hypertext links states. If the parameter is zero, the default style is used (see below). The three &quot;states&quot; are actually arbitrary as the application generally should control the &quot;state&quot; of a link; at the lowest level, a &quot;state&quot; is simply the choice of display style to use any given moment.</li>
<li><code>draw_mode</code> — The drawing mode to use. If <code>draw_none</code>, nothing redraws.</li>

</ul>
<h4 id='function-result-4'>Function result</h4>
<p>The function returns the <code>id_num</code> value (which will be whatever was passed in <code>id_num</code>).</p>
<h4 id='comments'>Comments</h4>
<p>All hypertext links must include at least one character in their selection in order to be valid. In other words, you must not apply a hypertext link to an empty selection (where <code>selection begin == selection end</code>). The single exception, however, is when the <code>keyword_display</code> parameter is a valid non-empty <code>cstring</code>. In this case, the &quot;selection&quot; range becomes the current selection&#39;s beginning + the length of <code>keyword_display</code>.</p>
<h4 id='default-display-states'>Default display states</h4>
<ul>
<li><code>State 1</code> (the initial state when the link is set) — Blue with underline.</li>
<li><code>State 2</code> — Red with underline.</li>
<li><code>State 3</code> — Dark gray (no underline).</li>

</ul>
<h3 id='setting-target-links'>Setting Target Links</h3>
<pre><code>long pgSetHyperlinkTarget (pg_ref pg, select_pair_ptr selection, pg_char_ptr URL, ht_callback callback, long type, long id_num, short display_style, short draw_mode);
</code></pre>
<h4 id='purpose-2'>Purpose</h4>
<p>Sets a new target hypertext link. A link is &quot;set&quot; by applying the attributes (defined by the other parameters in this function) to one or more characters in the document. A target link differs from a source link mainly in the implementation from the application; essentially, both types of links contain the same kind of information.</p>
<h4 id='parameters-3'>Parameters</h4>
<ul>
<li><p><code>pg</code> — The <code>pg_ref</code> to receive the link.</p>
</li>
<li><p><code>selection</code> — An optional range of text to apply the link. If selection is NULL, then current selection (highlighting) is used.</p>
</li>
<li><p><code>URL</code> — An optional string that will get stored with the link. If NULL, no string is stored; otherwise, the <code>URL</code> parameters are considered a <code>cstring</code> of any length. The <code>URL</code> string can be accessed and/or changed later by your application if necessary.</p>
</li>
<li><p><code>callback</code> — Pointer to a callback function (which you provide) that is called when the hypertext link is clicked. If <code>callback</code> is NULL the default callback function is used. (<strong>NOTE:</strong> for target links you will usually want a NULL callback since clicking on a target link probably requires no special action).</p>
</li>
<li><p><code>type</code> — An optional <code>type</code> variable. This value can be used by the application to distinguish between different types of links. For example, an index entry (to generate an index listing) would be different than a link to somewhere else in a document. For convenience there are some predefined types:</p>
<pre><code>/* Hyperlink types */
#define HYPERLINK_NORMAL				0x00000001	// Hyperlink normal
#define HYPERLINK_INDEX					0x00000002	// Hyperlink is an index
#define HYPERLINK_TOC					0x00000004	// Hyperlink is TOC.
#define HYPERLINK_SUBJECT				0x00000008	// Hyperlink is target subject
#define HYPERLINK_SUMMARY				0x00000010	// Summary link (and all those &gt; 0x10)
				// BOG: eudora hyperlink support
#define HYPERLINK_EUDORA_ATTACHMENT 0x00000020  // hyperlink is an eudora attachment
#define HYPERLINK_EUDORA_PLUGIN     0x00000040  // hyperlink is an eudora plugin
#define HYPERLINK_EUDORA_AUTOURL    0x00000080	// hyperlink is an auto-generated url
</code></pre>
<p>=
<strong>NOTE:</strong> The RTF importer will set <code>HYPERLINK_INDEX</code> and <code>HYPERLINK_TOC</code> for index and table-of-contents entries where appropriate.</p>
</li>
<li><p><code>id_num</code> An optional unique ID value. This can be used for searching and connecting links. The typical use for <code>id_num</code> is to initialise this value to a unique <code>id_num</code> that can be searched for. If you have created a source link to connect to this target, that same <code>id_num</code> can be placed in the target. Using the function <code>pgFindHyperlinkTargetByID()</code> allows you to find a link by the value in <code>id_num</code>. If the <code>id_num</code> parameter is zero, <code>pgSetHyperlinkTarget</code> initialises the target link <code>id_num</code> to a unique value (which does not exist in any other target link). </p>
</li>
<li><p><code>display_style</code> — Optional stylesheet ID that defines the display attributes of the link. If the parameter is zero the default style is used (see below).</p>
</li>
<li><p><code>draw_mode</code> — The drawing mode to use. If draw_none, nothing redraws.</p>
</li>

</ul>
<h4 id='function-result-5'>Function result</h4>
<p>The function returns the <code>id_num</code> value (which will be the unique number chosen for the target link if the <code>id_num</code> parameter was zero, or the value in <code>id_num</code> if it was nonzero).</p>
<p><strong>NOTE:</strong> unlike setting a source link, setting a target link automatically assigns a unique <code>ID</code> value if <code>id_num</code> is zero. You can find this link in the document using <code>pgFindHyperlinkTargetByID()</code>.</p>
<h4 id='comments-2'>Comments</h4>
<p>All hypertext links must include at least one character in its selection in order to be valid. In other words, you must NOT apply a hypertext link to an empty selection (where <code>selection begin == selection end</code>).</p>
<h3 id='default-display'>Default display</h3>
<p>Target links display with a yellow background colour. You can turn this display off by setting the following attribute with <code>pgSetAttributes2()</code>:</p>
<pre><code>#define HIDE_HT_TARGETS
</code></pre>
<p>This value must be set with <code>pgSetAttributes2()</code> (note the &quot;2&quot;).</p>
<h4 id='example-10'>Example</h4>
<p>To turn off the default display so target links display in their own native style(s), you would do the following:</p>
<pre><code>long flags;
flags = pgGetAttributes2(pgRef);
flags |= HIDE_HT_TARGETS;
pgSetAttributes2(pgRef);
</code></pre>
<h3 id='205-the-callback-function'>20.5 The Callback Function</h3>
<pre><code>PG_PASCAL (void) ht_callback (paige_rec_ptr pg, pg_hyperlink_ptr hypertext, short command, short modifiers, long position, pg_char_ptr URL);
</code></pre>
<p>This is the function that gets called for various events (usually when a link is clicked). You need to provide a pointer to your own function that handles these events.</p>
<h4 id='parameters-4'>Parameters</h4>
<ul>
<li><code>pg</code> — The <code>paige_rec</code> that owns the link.</li>
<li><code>hypertext</code> — The internal hypertext link record (see structure below).</li>
<li><code>command</code> — The value defining the event (see table below). </li>
<li><code>modifiers</code> — The state of the mouse (where applicable). These will be set to the appropriate bits. For example if modifiers contained <code>EXTEND_MOD_BIT</code>, the application has performed a shift-click. This can be important to determine the nature of a mouse click within a link; typically you may not want to &quot;jump&quot; to a link if the user is performing a <code>shift-click</code> or <code>control-click</code>, etc.</li>
<li><code>position</code> — The text position of the link (relative to the beginning of the document).</li>
<li><code>URL</code> — The <code>URL</code> string contained in the link. This will contain the character string given to the <code>URL</code> parameter when the link was created (or the string that was set using other function calls). Note that the <code>URL</code> parameter will never be NULL; if you created the link with a NULL pointer for <code>URL</code>, the parameter at this time will be an empty <code>cstring</code>.</li>

</ul>
<h4 id='comments-3'>Comments</h4>
<p>Do not try to use the URL data from the 	<code>hyperlink</code> parameter; use the <code>URL</code> parameter instead.</p>
<p>The <code>hyperlink</code> parameter points to a copy of the original record; it is therefore safe to alter (and even delete) the original (via the proper function calls) even from within this hook.</p>
<p>When responding to a hypertext link event you should call the default source callback function if you want the link display to change states. This function is called <code>pgStandardSourceCallback()</code>; when you do so, the link that has been clicked will change its display to <code>state 2</code> and all other links in the document will change to <code>state 1</code>.</p>
<h4 id='example-11'>Example</h4>
<pre><code>PG_PASCAL (void) HyperlinkCallback (paige_rec_ptr pg, pg_hyperlink_ptr hypertext, short command, short modifiers, long position, pg_char_ptr URL)
{
	// Call the standard callback first to get default behaviour:
	pgStandardSourceCallback(pg, hypertext, command, modifiers, position, URL);
	switch(command)
	{
		case hyperlink_mousedown_verb:
			// etc
			break;
	}
}		
</code></pre>
<h4 id='callback-command-values'>Callback command values</h4>
<ul>
<li><code>hyperlink_mousedown_verb</code> — Called when link is first clicked</li>
<li><code>hyperlink_doubleclick_verb</code> – Called if link is double-clicked</li>
<li><code>hyperlink_mouseup_verb</code> — Called when mouse is up</li>
<li><code>hyperlink_delete_verb</code> — Called when link gets deleted</li>

</ul>
<h2 id='206-hyperlink-record-struct'>20.6 Hyperlink Record Struct</h2>
<pre><code>struct pg_hyperlink
{
	select_pair applied_range;				// Offset(s) of source
	pg_char URL[FONT_SIZE + BOM_HEADER];	// String data
	memory_ref alt_URL;						// URL (if &gt; FONT_SIZE -1)
	ht_callback callback;					// Callback function
	short active_style;						// Style to show
	short state1_style;						// Primary state style
	short state2_style;						// Secondary state style
	short state3_style;						// Style to show when invalid
	long unique_id;							// Unique ID used for searching
	long type;								// Type of link
	long refcon;								// App can keep whatever
};
</code></pre>
<p>The <code>applied_range</code> member contains the current text positions for the beginning and ending of the link. The URL member contains the URL string if it is &lt; <code>FONT_SIZE</code> - 1. Otherwise, the string is inside <code>alt_URL</code>. The <code>unique_id</code>, <code>type</code>, and <code>refcon</code> members are optional values that can be used by the application for locating specific links.</p>
<h2 id='207-findinglocating-links'>20.7 Finding/Locating Links</h2>
<h3 id='finding-by-url-strings'>Finding by URL Strings</h3>
<pre><code>long pgFindHyperlinkSource (pg_ref pg, long starting_position, long PG_FAR *end_position, pg_char_ptr URL, pg_boolean partial_find_ok, pg_boolean case_insensitive, pg_boolean scroll_to);

long pgFindHyperlinkTarget (pg_ref pg, long starting_position, long PG_FAR *end_position, pg_char_ptr URL, pg_boolean partial_find_ok, pg_boolean case_insensitive, pg_boolean scroll_to);
</code></pre>
<p>These functions can be used to perform a &quot;search&quot; that locates a specific link based on its URL string value. The <code>pgFindHyperlinkTarget</code> function searches for a target link while <code>pgFindHyperlinkSource</code> searches for a source link.</p>
<h4 id='parameters-5'>Parameters</h4>
<ul>
<li><code>starting_position</code> — The text position to begin the search; this is a zero-indexed value.</li>
<li><code>end_position</code> — Optional pointer to a long word. If this is non-null, the long word gets initialised to the text position following the link if found (the <code>*end_position</code> value remains unchanged if a match is not found).</li>
<li><code>URL</code> — The string to search for (<code>cstring</code>).</li>
<li><code>partial_find_ok</code> — If TRUE, a match is considered valid if URL matches only the first part of the link&#39;s URL. For example, if searching for <code>Book</code>, a match will be made on <code>Book1</code> and <code>Book2</code>, etc. </li>
<li><code>case_insensitive</code> — If TRUE, the comparison is not case-sensitive. </li>
<li><code>scroll_to</code> — If TRUE, the document is scrolled to the found location.</li>

</ul>
<h4 id='function-result-6'>Function result</h4>
<p>If the link is found, the function returns the text position where the link begins (and if <code>*end_offset</code> is non-null it gets set to the link&#39;s ending position). If no match is found, the function returns <code>-1</code>.</p>
<h3 id='finding-by-id-number'>Finding by &quot;ID&quot; Number</h3>
<pre><code>long pgFindHyperlinkSourceByID (pg_ref pg, long starting_position, long PG_FAR *end_position, long id_num, pg_boolean scroll_to);

long pgFindHyperlinkTargetByID (pg_ref pg, long starting_position, long PG_FAR *end_position, long id_num, pg_boolean scroll_to);
</code></pre>
<p>These functions can be used to perform a &quot;search&quot; that locates a specific link based on its value in <code>id_num</code>. The link&#39;s <code>id_num</code> is usually set when you set the original source or target link. The <code>pgFindHyperlinkTargetByID</code> function searches for a target link while <code>pgFindHyperlinkSourceByID</code> searches for a source link.</p>
<h4 id='parameters-6'>Parameters</h4>
<ul>
<li><code>starting_position</code> — The zero-indexed text position to begin the search.</li>
<li><code>end_position</code> Optional pointer to a long word. If this is non-null, the long word gets initialised to the text position following the link if found (the <code>*end_position</code> value remains unchanged if a match is not found).</li>
<li><code>id_num</code> The value being searched for. The <code>id_num</code> member in the link is compared to the <code>id_num</code> parameter passed to this function. The link&#39;s <code>id_num</code> is usually set when you set the original source or target link.</li>
<li><code>scroll_to</code> If TRUE, the document is scrolled to the found location. If the link is found, the function returns the text position where the link begins (and if <code>*end_offset</code> is non-null it gets set to the link&#39;s ending position). If no match is found, the function returns -1.</li>

</ul>
<h2 id='208-changing-existing-links'>20.8 Changing Existing Links</h2>
<pre><code>void pgChangeHyperlinkSource (pg_ref pg, long position, select_pair_ptr selection, pg_char_ptr URL, ht_callback callback, short display_style, short draw_mode);
void pgChangeHyperlinkTarget (pg_ref pg, long position, select_pair_ptr selection, pg_char_ptr URL, ht_callback callback, short display_style, short draw_mode);
</code></pre>
<p>These two functions are used to change the attributes of an existing hypertext link; <code>pgChangeHyperlinkSource()</code> changes a source link and <code>pgChangeHyperlinkTarget()</code> changes a target link.</p>
<p>All parameters are completely identical to <code>pgSetHyperlinkTarget()</code> and <code>pgSetHyperlinkSource()</code> except for the additional <code>position</code> parameter — this specifies where the link is located, i.e. its character position in the text. (There are several ways to find the character position, not the least of which is simply getting the selection range from the <code>pg_ref</code>, assuming it is within a link). See also the various utility functions that return a text position of a link.</p>
<p>For each parameter that is non-zero, that value is changed to the value specified; otherwise, the current corresponding value remains unchanged.</p>
<p>For example, a non-null URL parameter changes the URL string, while a null pointer leaves the existing string unchanged.</p>
<h2 id='209-detecting-mouse-points'>20.9 Detecting Mouse Points</h2>
<pre><code>long pgPtInHyperlinkSource(pg_ref pg, co_ordinate_ptr point);
long pgPtInHyperlinkTarget(pg_ref pg, co_ordinate_ptr point);
</code></pre>
<p>These two functions are used to detect which link, if any, contain a point. Use <code>pgPtInHyperlinkSource</code> for detecting a point in a source link and <code>pgPtInHyperlinkTarget</code> for detecting one in a target link.</p>
<p>The point parameter is a point in screen coordinates (<em>not</em> scrolled and <em>not</em> scaled).</p>
<h4 id='function-result-7'>FUNCTION RESULT</h4>
<p>If a link contains the point, its beginning text position is returned. If no link contains a point, point -1 is returned.</p>
<h2 id='2010-changing-display-state'>20.10 Changing Display State</h2>
<pre><code>void pgSetHyperlinkSourceState (pg_ref pg, long position, short state, pg_boolean redraw);
void pgSetHyperlinkTargetState (pg_ref pg, long position, short state, pg_boolean redraw);
</code></pre>
<p>These functions can be used to change the display state of a link; <code>pgSetHyperlinkTargetState</code> changes the display state of target links and <code>pgSetHyperlinkSourceState</code> changes the display state of source links.</p>
<h4 id='parameters-7'>Parameters</h4>
<ul>
<li><code>position</code> — The text position of the link. Or, if <code>position</code> is -1 the <code>state</code> is applied to all the links of this type (i.e. all target links or all source links). For example, to force all source links to state 0 you could call <code>pgSetHyperlinkSourceState(pg, -1, 0, TRUE)</code>.</li>
<li><code>state</code> — One of three states ( 0,1 or 2 ). The <code>state</code> simply defines which of the three possible styles to display the link.</li>
<li><code>redraw</code> — If TRUE the link(s) redraw their new <code>state</code>.</li>

</ul>
<h2 id='2011-file-io'>20.11 File I/O</h2>
<p>There is no special function you need to call to read or write HERMES Paige hypertext links. However, after reading or importing a file with possible links you must reinitialise your callback function pointers, if any:
	</p>
<pre><code>void pgSetHyperlinkCallback (pg_ref pg, ht_callback source_callback, ht_callback target_callback);
</code></pre>
<p>This function walks through all existing links, sets the callback function in the source links to <code>source_callback</code> and the callback function in target links to <code>target_callback</code>. Either function can be null, in which case the default callback is used.</p>
<h2 id='2012-removing-links'>20.12 Removing Links</h2>
<pre><code>void pgDeleteHyperlinkSource (pg_ref pg, long position, pg_boolean redraw);
void pgDeleteHyperlinkTarget (pg_ref pg, long position, pg_boolean redraw);
</code></pre>
<p>These functions remove a source link or target link, respectively.</p>
<h4 id='parameters-8'>Parameters</h4>
<ul>
<li><code>position</code> — indicates which link to remove; this must be a text position that exists somewhere within the link.</li>
<li>redraw — if TRUE, the document is redrawn showing the change.</li>

</ul>
<h4 id='note-28'>Note</h4>
<p>Only the applied link and its displayed styles, etc. are removed; the text itself as it exists in the document is not changed. For example, if the word <code>Book</code> existed in the document and had a target hypertext link applied to it, removing the link simply means there is no longer any associated link to this word yet the word <code>Book</code> remains in the text, drawn in its normal (non-link) style.</p>
<h2 id='2013-miscellaneous'>20.13 Miscellaneous</h2>
<h4 id='pggetsourceurl'><code>pgGetSourceURL()</code></h4>
<pre><code>pg_boolean pgGetSourceURL (pg_ref pg, long position, pg_char_ptr URL, short max_size);
pg_boolean pgGetTargetURL (pg_ref pg, long position, pg_char_ptr URL, short max_size);
</code></pre>
<p>These functions return the contents of the URL string from a specific source or target link, respectively.</p>
<h4 id='parameters-9'>Parameters</h4>
<ul>
<li><code>position</code> – The text position of the link.</li>
<li>URL — Pointer to a character buffer (to receive the string).</li>
<li><code>max_size</code> — The maximum number of characters that can be received in the buffer, including the null terminator of the <code>cstring</code>.</li>

</ul>
<h4 id='function-result-8'>Function result</h4>
<p>If there is no link found at the specified text position, FALSE is returned (and no characters are copied into URL). Otherwise the string is set at URL (and truncated, if necessary, if the <code>string</code> size &gt; <code>max_size</code>).</p>
<h4 id='pggetsourceid'><code>pgGetSourceID</code></h4>
<pre><code>long pgGetSourceID (pg_ref pg, long position);
long pgGetTargetID (pg_ref pg, long position);
</code></pre>
<p>These functions return the unique &quot;ID&quot; value in a specific source or target link, respectively.
position The text position of the link.</p>
<h4 id='parameters-10'>Parameters</h4>
<ul>
<li><code>position</code> — The zero-indexed text position of the link.</li>

</ul>
<h4 id='function-result-9'>Function result</h4>
<p>The unique ID value, if any, belonging to the specified link is returned.</p>
<p>NOTE: a value of zero is returned if the link&#39;s id_num member is zero or if there is not a link associated to the specified position.</p>
<h4 id='pggethyperlinksourceinfo'><code>pgGetHyperlinkSourceInfo</code></h4>
<pre><code>pg_boolean pgGetHyperlinkSourceInfo (pg_ref pg, long position, pg_boolean closest_one, pg_hyperlink_ptr hyperlink);
pg_boolean pgGetHyperlinkTargetInfo (pg_ref pg, long position, pg_boolean closest_one, pg_hyperlink_ptr hyperlink);
</code></pre>
<p>These two functions return the actual hyperlink record for a specific source or target link, respectively.</p>
<h4 id='parameters-11'>Parameters</h4>
<ul>
<li><code>position</code> — The zero-indexed text position of the link.</li>
<li><code>closest_one</code> — If FALSE, the link must be found at the specified position; otherwise, the link is found nearest to, or to the right of the specified position.</li>
<li><code>hyperlink</code> — Pointer to a <code>pg_hypertext</code> record. If the link is found, the record is copied to this structure.</li>

</ul>
<h4 id='function-result-10'>Function result</h4>
<p>FALSE is returned if no link is found at the specified position (or no link is found between the position and end of document when closest_one is TRUE).</p>
<h4 id='pginitdefaultsource'><code>pgInitDefaultSource</code></h4>
<pre><code>void pgInitDefaultSource (pg_ref pg, pg_hyperlink_ptr link);
void pgInitDefaultTarget (pg_ref pg, pg_hyperlink_ptr link);
</code></pre>
<p>These functions initialise a hypertext record to the defaults. Usually you won&#39;t need to call this function. It is mainly used for building hypertext links while importing files.</p>
<h4 id='pgnewhyperlinkstyle'><code>pgNewHyperlinkStyle</code></h4>
<pre><code>short pgNewHyperlinkStyle (pg_ref pg, pg_short_t red, pg_short_t green, pg_short_t blue, long stylebits, pg_boolean background);
</code></pre>
<p>This function creates a stylesheet that can be subsequently passed to a function that sets a new hypertext link.</p>
<h4 id='parameters-12'>Parameters</h4>
<ul>
<li><p><code>red</code>, <code>green</code>, <code>blue</code> — define the R-G-B components of a colour (&quot;black&quot; is the result of red, green and blue all zeros). This colour is applied to the text if the background parameter is FALSE; otherwise, the colour is applied to the text background.</p>
</li>
<li><p><code>stylebits</code> — Defines optional style(s) to apply to the text. This is a set of bits which can be a combination of the following:</p>
<pre><code>#include &quot;pgHLevel.h&quot;
#define X_PLAIN_TEXT	 		0x00000000
#define X_BOLD_BIT				0x00000001
#define X_ITALIC_BIT			0x00000002
#define X_UNDERLINE_BIT			0x00000004
#define X_OUTLINE_BIT 			0x00000008
#define X_SHADOW_BIT			0x00000010
#define X_CONDENSE_BIT			0x00000020
#define X_EXTEND_BIT			0x00000040
#define X_DBL_UNDERLINE_BIT		0x00000080
#define X_WORD_UNDERLINE_BIT	0x00000100
#define X_DOTTED_UNDERLINE_BIT	0x00000200
#define X_HIDDEN_TEXT_BIT		0x00000400
#define X_STRIKEOUT_BIT			0x00000800
#define X_SUPERSCRIPT_BIT		0x00001000
#define X_SUBSCRIPT_BIT			0x00002000
#define X_ROTATION_BIT			0x00004000
#define X_ALL_CAPS_BIT			0x00008000
#define X_ALL_LOWER_BIT			0x00010000
#define X_SMALL_CAPS_BIT		0x00020000
#define X_OVERLINE_BIT			0x00040000
#define X_BOXED_BIT				0x00080000
#define X_RELATIVE_POINT_BIT	0x00100000
#define X_SUPERIMPOSE_BIT		0x00200000
#define X_ALL_STYLES			0xFFFFFFFF
</code></pre>
</li>
<li><p><code>background</code> — If TRUE, the colour is applied to the text background; otherwise, the colour is applied to the text.</p>
</li>

</ul>
<h4 id='function-result-11'>Function result</h4>
<p>A new <code>stylesheet</code> ID is returned. If the exact <code>stylesheet</code> already exists its ID is returned instead (hence, you will not create duplicate styles). This stylesheet ID can be given to the function(s) that set new hypertext links.</p>
<h4 id='pgscrolltolink'><code>pgScrollToLink</code></h4>
<pre><code>void pgScrollToLink (pg_ref pg, long text_position);
</code></pre>
<h4 id='function-result-12'>Function result</h4>
<p>This function causes the document to scroll to the specified, zero-indexed text position.</p>
<h4 id='note-29'>Note</h4>
<p>The text position does not necessarily contain a link; rather, this is a convenience function that forces the document to scroll to the location specified.</p>
<h1 id='21-tables-and-borders'>21 TABLES AND BORDERS</h1>
<h2 id='211-general'>21.1 General</h2>
<p>A table is tab-delimited text formatted as rows and columns of &quot;cells.&quot; The formatting information itself is paragraph-based, while the text itself is internally maintains each cell as tab or CR-delimited text and each row is delimited by a CR.</p>
<p>At a very low level, table attributes are applied with <code>pgSetParInfo()</code>. Higher level functions, described in this document, provide methods to insert new tables and format existing ones.</p>
<p>Table attributes are part of <code>par_info.table</code> represented by the following record:</p>
<pre><code>struct pg_table
{
	long table_columns;			// Number of columns (tables)
	long table_column_width;	// Default column width
	long table_cell_height;		// MINIMUM cell height
	long border_info;			// Borders
	long border_spacing;		// Extra spacing (for borders)
	long border_shading;		// Border background shading
	long cell_borders;			// Default borders around cells
	long grid_borders;			// Non-printable cell borders
	long unique_id;				// Unique table ID
	long cell_h_extra;			// Extra inset inside cells
};
</code></pre>
<h4 id='parameters-13'>Parameters</h4>
<ul>
<li><code>table_columns</code> — Number of columns in the table. If this is zero, the paragraph is not a table.</li>
<li><code>table_column_width</code> — The default width for each cell. If this is zero, cell widths are determined dynamically according to the width of the paragraph. For example, if the width of the paragraph after subtracting paragraph indents is 6 inches, a 6-column table will render 1&quot; cells. Note that individual column widths can be altered after a table is inserted.</li>
<li><code>table_cell_height</code> — The default height for a row. This is the minimum height for all rows. If zero, the height is determined by the height(s) of the text within the row.</li>
<li><code>border_info</code> — Paragraph border information. If <code>table_columns</code> is zero, <code>border_info</code> defines the surrounding paragraph border lines (see section 19.1, <a href='#19.1-paragraph-borders'>Paragraph Borders</a>).</li>
<li><code>border_spacing</code> — The amount of extra spacing between border line(s) and the text, in pixels. This value is applied to paragraph borders.</li>
<li><code>border_shading</code> — The background colour for the paragraph or table. If this is zero, the normal window colour is used. Otherwise, this is a 24-bit representation of an RGB value (see &quot;RGB Values&quot; <em>infra</em>).</li>
<li><code>cell_borders</code> — The default border line(s) around each cell. This differs from <code>border_info</code> because it applies only to cells within a table.</li>
<li><code>grid_borders</code> — The amount of extra spacing between border line(s) and the text, in pixels. This value is applied to paragraph borders. The default border line(s) to display around cells if no other borders are present. These cell borders are not drawn when the document is printed; they apply only to table cells.</li>
<li><code>unique_id</code> — <strong>Used internally.</strong> The <code>table_id</code> is used to maintain unique paragraph records; <em>do not</em> alter this value.</li>
<li><code>cell_h_extra</code> — Extra space, in pixels, between cells.</li>

</ul>
<h2 id='213-rgb-values'>21.3 RGB Values</h2>
<p>Border and cell shading is represented by the following bitwise settings in a long word:</p>
<pre><code>0x00BBGGRR
</code></pre>
<p>The <code>BB</code> bits represent the blue component of the colour, the <code>GG</code> bits represent the green component, and <code>RR</code> represents the red component.</p>
<p><strong>NOTE:</strong> These bits are identical to the bits in a Windows <code>COLORREF</code>.</p>
<h2 id='214-table-functions'>21.4 Table Functions</h2>
<p><strong>NOTE:</strong> These functions are defined in <code>pgTable.h</code>.</p>
<h3 id='inserting-new'>Inserting New</h3>
<pre><code>void pgInsertTable (pg_ref pg, long position, pg_table_ptr table, long row_qty, short draw_mode);
</code></pre>
<p>Inserts a new table beginning at the text position specified. The position parameter can be <code>CURRENT_POSITION</code>.</p>
<h4 id='parameters-14'>Parameters</h4>
<ul>
<li><code>table</code> is a pointer to a <code>pg_table</code> record defining all the table attributes.</li>
<li><code>row_qty</code> indicates the desired number of rows. If this is zero at least one row is inserted.</li>
<li><code>draw_mode</code> causes the text to redraw if nonzero.
NOTE: Since tables are a paragraph format, this function may insert carriage return(s) before and after the specified position so as more clearly to delimit the format run.</li>

</ul>
<h3 id='changing-columns-and-cells'>Changing Columns and Cells</h3>
<pre><code>void pgSetColumnWidth (pg_ref pg, long position, short column_num, short width, short draw_mode);
</code></pre>
<p>Changes the width of a specific column in a table.</p>
<h4 id='parameters-15'>Parameters</h4>
<ul>
<li><code>position</code> indicates the text position of the table, which can also be <code>CURRENT_POSITION</code>. This value can be the position of any character within the table (i.e. it does not need to be the very beginning of the table or a cell). If the specified <code>position</code> is not part of a table, this function does nothing.</li>
<li><code>column_num</code> The column defined by <code>column_num</code> gets set to the value in width; this is a zero-indexed number.</li>

</ul>
<p>-</p>
<pre><code>void pgSetColumnBorders (pg_ref pg, long position, short column_num, long border_info, short draw_mode);
</code></pre>
<p>Changes the cell border line(s) of a specific column in a table.</p>
<h4 id='parameters-16'>Parameters</h4>
<ul>
<li><code>position</code> indicates the text position of the table, which can also be <code>CURRENT_POSITION</code>. This value can be the position of any character within the table (i.e. it does not need to be the very beginning of the table or a cell). If the specified <code>position</code> is not part of a table, this function does nothing.</li>
<li><code>column_num</code> The column defined by <code>column_num</code> changes its cell borders to <code>border_info</code>; this is a zero-indexed number.</li>

</ul>
<p>-</p>
<pre><code>void pgSetColumnShading (pg_ref pg, long position, short column_num, long shading, short draw_mode);
</code></pre>
<p>Changes the cell shading (background color) of a specific column in a table.</p>
<h4 id='parameters-17'>Parameters</h4>
<ul>
<li><code>position</code> indicates the text position of the table, which can also be <code>CURRENT_POSITION</code>. This value can be the position of any character within the table (i.e. it does not need to be the very beginning of the table or a cell). If the specified <code>position</code> is not part of a table, this function does nothing.</li>
<li><code>column_num</code> The column defined by <code>column_num</code> changes its background colour to <code>shading</code>; this is a zero-indexed number.</li>

</ul>
<p>-</p>
<pre><code>void pgSetColumnAlignment (pg_ref pg, long position, short column_num, short alignment, short draw_mode);
</code></pre>
<p>Changes the cell text alignment (&quot;justification&quot;) of a specific column in a table.</p>
<h4 id='parameters-18'>Parameters</h4>
<ul>
<li><code>position</code> indicates the text position of the table, which can also be CURRENT_POSITION. This value can be the position of any character within the table (i.e. it does not need to be the very beginning of the table or a cell). If the specified <code>position</code> is not part of a table, this function does nothing.</li>
<li><code>column_num</code> — The column defined by <code>column_num</code> changes its alignment to the value specified; columns are zero-indexed. Alignment values are the same as paragraph justification values (<code>justify_left</code>, <code>justify_center</code>, <code>justify_right</code>, <code>justify_full</code>).</li>

</ul>
<p>-</p>
<pre><code>pg_boolean pgIsTable (pg_ref pg, long position);
</code></pre>
<p>Returns TRUE if the specified position is within any part of a table.</p>
<h4 id='parameters-19'>Parameters</h4>
<ul>
<li><code>position</code> can be <code>CURRENT_POSITION</code>.</li>

</ul>
<p>-</p>
<pre><code>pg_boolean pgPtInTable (pg_ref pg, co_ordinate_ptr point, pg_boolean non_focus_only, select_pair_ptr offsets);
</code></pre>
<p>Returns TRUE if the specified <code>point</code> is anywhere within a table.</p>
<h4 id='parameters-20'>Parameters</h4>
<ul>
<li><code>non_focus_only</code> — value is ignored; pass FALSE for compatibility.</li>
<li><code>offsets</code> — if non-NULL and the <code>point</code> is within a table, <code>offsets -&gt; begin</code> and <code>offsets -&gt; end</code> get set to the beginning and ending text position for the whole table. (If the <code>point</code> was not within any table, <code>offsets</code> is unchanged).</li>

</ul>
<p>-</p>
<pre><code>memory_ref pgTableColumnWidths (pg_ref pg, long position);
</code></pre>
<p>Returns a <code>memory_ref</code> containing the width(s) for each column. The memory size of the reference will be equal to the number of columns in the table.</p>
<h4 id='parameters-21'>Parameters</h4>
<ul>
<li><code>position</code> indicates the text position of the table, which can also be <code>CURRENT_POSITION</code>. This value can be the position of any character within the table (i.e. it does not need to be the very beginning of the table or a cell). If the specified position is not part of a table, this function returns <code>MEM_NULL</code>.</li>

</ul>
<p>-</p>
<pre><code>void pgCellOffsets (pg_ref pg, long position, select_pair_ptr offsets);
</code></pre>
<p>Returns the text positions of the text contents of a specific cell.</p>
<h4 id='parameters-22'>Parameters</h4>
<ul>
<li><code>position</code> indicates the text position of the table, which can also be <code>CURRENT_POSITION</code>. This value can be the position of any character within the table. If the specified position is not part of a table, this function does nothing; otherwise, <code>offsets -&gt; begin</code> and <code>offsets -&gt; end</code> will return with the beginning and ending of the contents of the cell containing the original position.
<strong>NOTE:</strong> If the cell contents are empty, <code>offsets -&gt; begin</code> and <code>offsets -&gt; end</code> will be equivalent.</li>

</ul>
<p>-</p>
<pre><code>void pgTableOffsets (pg_ref pg, long position, select_pair_ptr offsets);
</code></pre>
<p>Returns the text positions for the beginning and ending of the whole table.</p>
<h4 id='parameters-23'>Parameters</h4>
<ul>
<li><code>position</code> indicates the text position of the table, which can also be <code>CURRENT_POSITION</code>. This value can be the position of any character within the table. If the specified position is not part of a table, this function does nothing; otherwise, <code>offsets -&gt; begin</code> and <code>offsets -&gt; end</code> will return with the beginning and ending of the whole table.</li>

</ul>
<h3 id='inserting--deleting-rows-and-columns'>Inserting / Deleting Rows and Columns</h3>
<pre><code>void pgInsertColumn (pg_ref pg, long position, short column_num, tab_stop_ptr info, short draw_mode);
</code></pre>
<p>Inserts a new, empty column into the table that contains the text position specified.</p>
<h4 id='parameters-24'>Parameters</h4>
<ul>
<li><code>position</code> can be <code>CURRENT_POSITION</code>; if it is not contained in a table, this function does nothing.</li>
<li><code>column_num</code> — The new column is inserted before <code>column_num</code> (zero-indexed). To append a column to the far right side of the table, <code>column_num</code> should be equal to the current number of columns (see <code>pgNumColumns</code> <!-- on page bugger all -->).</li>
<li><code>tab_stop.position</code> — Column width, in pixels. (Zero = automatic widths). </li>
<li><code>tab_stop.type</code> — Justification. Set to <code>left_tab</code>, <code>center_tab</code>, etc. Default cell borders.</li>
<li><code>tab_stop.leader</code> — Default cell borders.</li>
<li><code>tab_stop.ref_con</code> — Default background shading (zero for none).</li>

</ul>
<p>=</p>
<pre><code>void pgInsertRow (pg_ref pg, long position, long row_num, short draw_mode);
</code></pre>
<p>Inserts a new, empty row into the table that contains the text position specified.</p>
<h4 id='parameters-25'>Parameters</h4>
<ul>
<li><code>position</code> can be <code>CURRENT_POSITION</code>; if it is not contained in a table, this function does nothing.</li>
<li><code>row_num</code> — The new row is inserted before <code>row_num</code> (zero-indexed). To append a row to the bottom end of the table, <code>row_num</code> should be equal to the current number of rows (see <code>pgNumColumns</code> <!-- on page bugger all -->).</li>

</ul>
<p>-</p>
<pre><code>void pgDeleteColumn (pg_ref pg, long position, short column_num, short draw_mode);
</code></pre>
<p>Removes a column (including its text contents).</p>
<h4 id='parameters-26'>Parameters</h4>
<ul>
<li><code>position</code> — specifies a text position anywhere within a table and can be <code>CURRENT_POSITION</code>. If the <code>position</code> is not contained in a table, or if there is only one column, this function does nothing.</li>
<li><code>column_num</code> — specifies the column to delete and must be between zero and <code>pgNumColumns()</code> - 1.</li>

</ul>
<p>-</p>
<pre><code>void pgDeleteRow (pg_ref pg, long position, long row_num, short draw_mode);
</code></pre>
<p>Removes a row (including its text contents).</p>
<h4 id='parameters-27'>PARAMETERS</h4>
<ul>
<li><code>position</code> — specifies a text position anywhere within a table and can be <code>CURRENT_POSITION</code>. If the <code>position</code> is not contained in a table, or if there is only one row, this function does nothing.</li>
<li><code>row_num</code> — specifies the row to delete and must be between zero and <code>pgNumRows()</code> - 1.</li>

</ul>
<h3 id='miscellaneous'>Miscellaneous</h3>
<pre><code>short pgNumColumns (pg_ref pg, long position);
</code></pre>
<p>Returns the number of columns in the table containing <code>position</code>. If <code>position</code> is not contained in a table, this function returns zero.</p>
<pre><code>long pgNumRows (pg_ref pg, long position);
</code></pre>
<p>Returns the number of rows in the table containing <code>position</code>. If <code>position</code> is not contained in a table, this function returns zero.</p>
<p><strong>NOTE:</strong> the total number of rows is returned for the whole table regardless of the position parameter. For instance, a 10-row column would cause <code>pgNumRows()</code> to return 10 whether the position is in the first row, middle row or last row, etc.</p>
<h3 id='changing-row-information'>Changing &quot;Row&quot; Information</h3>
<p>There are no row-specific functions for tables since a table &quot;row&quot; is really a paragraph. Hence, to change attributes to a row you should use <code>pgSetParInfo()</code> and make the desired changes.</p>
<p>For example, setting the justification value for a table row (paragraph) will cause each of the cells in that row to assume the justification. Setting paragraph borders or shading for the row will affect all the cells in that row, etc.</p>
<p><strong>CAUTION:</strong> Do <em>not</em> alter the tab settings or tab quantity in a paragraph format applied to tables; the tab array is used to record column attributes. Also, do <em>not</em> alter the number of columns in the table record.</p>
<h2 id='getting-other-table-info'>Getting Other Table Info</h2>
<p>Table information is simply a member of <code>par_info</code>. To get information about a table that is not covered in one of the functions above, use <code>pgGetParInfo()</code>.</p>
<h1 id='22-file-standards-input-and-output'>22 FILE STANDARDS, INPUT, AND OUTPUT</h1>
<p><strong>NOTE:</strong> If you will only be saving files as HERMES Paige native format or RTF and will be including no customised file formatting, see chapters 17, <a href='#17-hermes-paige-import-extension'>HERMES Paige Import Extension</a>, and 18, <a href='#18-hermes-paige-export-extension'>HERMES Paige Export Extension</a>. Importing and exporting may be a simpler approach.</p>
<p>The HERMES Paige technology includes a file handling system to help implement the following:</p>
<ul>
<li><em>Platform-independent file transfers</em> — a proposed standard and function set that enables HERMES Paige software to read files saved by other C.P.O.S. as well as save or re-save files to be understood in reverse.</li>
<li><em>Upgrade/update independent file transfers</em> — the proposed standard guarantees upward and even backwards compatibility for future enhancements to HERMES Paige with regards to file transfer. For example, every internal record structure, including style records, can theoretically be altered and enhanced, yet older files will still be loaded correctly and older software will even be able to read the newer files (eliminating, of course, any new feature set that was inherently saved).</li>
<li><em>Application-independent file transfers</em> — diverse applications, even on the same platforms, are able to read file saved by other applications even if unknown elements have been saved. Using HERMES Paige&#39;s file transfer methods, application-specific data embedded in the file is simply &quot;skipped&quot; without any adverse consequences.</li>
<li><em>Subset of functions for app-specific saves</em> — HERMES Paige makes it fairly easy to save and read your own data structures along with the HERMES Paige object data, all the while maintaining compatibility with each concept listed above.</li>
<li><em>Preserves HERMES Paige structures that have <code>long</code>s</em> — If you roll your own I/O, HERMES Paige structures containing long words would get flipped around (backwards). For example, if you just slam an HERMES Paige <code>struct</code> to a file as a byte stream it won&#39;t work on the other end. Fortunately HERMES Paige&#39;s built-in I/O handler takes care of this problem. I strongly recommend you utilize the file &quot;key&quot; system provided. If special/custom I/O is required anywhere, take a look at the latest release notes regarding files—there are now ways to &quot;roll your own&quot; while still using HERMES Paige&#39;s system.</li>

</ul>
<h2 id='221-up-and-running'>22.1 Up and Running</h2>
<p>Since the information in this chapter can be somewhat complex in its entirety, the following example is provided for you to be &quot;up and running&quot; with file I/O by simply using the defaults.</p>
<pre><code>/* DoSave saves the current pg_ref to a file. If file_stuff is not NULL a new file is to be saved (first-time saves and Save As) */
void DoSave (HWND hWnd, OPENFILENAME far *file_stuff)
{
	int file_ref, far *f_ptr;
	long position;
	memory_ref file_map;
	
	if ((file_ref = _lcreat(file_stuff -&gt; lpstrFile, 0)) != -1
	{
		file_map = MemoryAlloc(&amp;mem_globals, sizeof(int), 1, 0);
		f_ptr = UseMemory(file_map);
		*f_ptr = file_ref;
		UnUseMemory(file_map);
		position = 0;
		pgSaveDoc(test_pg, &amp;position, NULL, 0, NULL, file_map, 0);
		
		DisposeMemory(file_map);
		_lclose(file_ref);
	}
}
</code></pre>
<h3 id='up-and-running-io-example-mac'>Up and Running I/O Example (Mac)</h3>
<pre><code>/* In this file saving example, the ref_num parameter is a file reference created and opened using File OS functions. If there is a problem, an error result is returned. */

static OSErr save_file (pg_ref pg, short ref_num)
{
	OSErr error;
	file_ref filemap;
	long file_position;
	short *filemap_ptr;

	filemap = MemoryAlloc(&amp;mem_globals, sizeof(short), 1, 0);
	filemap_ptr = UseMemory(filemap);
	*filemap_ptr = ref_num;
	UnuseMemory(filemap);
	error;
}

file_position = 0;
error = pgSaveDoc(pg, \&amp;file_position, NULL, 0, NULL, filemap, 0);
DisposeMemory(filemap);
return
</code></pre>
<h5 id='note-30'>NOTE</h5>
<p>The &quot;save&quot; code is quite small. If you aren&#39;t saving anything special, writing a document is fairly straightforward.</p>
<h3 id='reading-a-document-mac'>Reading a document (Mac)</h3>
<pre><code>/* In this file reading example, the ref_num parameter is a file reference opened using File OS functions. The app assumes it is an HERMES Paige file (saved with the example above). If there is a problem, NULL is returned, otherwise a new pg_ref is returned. */
pg_ref read_file (short ref_num)
{
	pg_ref pg;
	OSErr error;
	file_ref filemap;
	long file_position;
	short *filemap_ptr;

	pg = pgNewShell(&amp;paige_rsrv);	// Creates empty HERMES Paige object
	filemap = MemoryAlloc(&amp;paige_rsrv.mem_globals, sizeof(short), 1, 0);
	filemap_ptr = UseMemory(filemap);
	*filemap_ptr= ref_num;
	UnuseMemory(filemap);
	file_position = 0;
	
	// NOTE: You can also use HERMES Paige&#39;s PG_TRY, PG_CATCH here for exception handling
	error = pgReadDoc(pg, \&amp;file_position, NULL, 0, NULL, filemap); 
	if (error != noErr)
	{
		show_error(error);
		pgDispose(pg);
		pg = NULL;
	}
	DisposeMemory(filemap);
	return pg;
}
</code></pre>
<h3 id='reading-an-hermes-paige-file-on-windows'>Reading an HERMES Paige file on Windows</h3>
<pre><code>/* DoFileOpen opens an HERMES Paige file which has already been specified by user. */

void DoFileOpen (HWND hWnd, OPENFILENAME far *file_stuff)
{
	int file_ref, far *f_ptr;
	long position;
	RECT view_area;
	memory_ref file_map;

	if ((file_ref = _lopen(file_stuff -&gt; lpstrFile, OF_READ)) != -1)
	{
		file_map = MemoryAlloc(&amp;mem_globals, sizeof(int), 1, 0);
		f_ptr = UseMemory(file_map);
		*f_ptr = file_ref;
		UnuseMemory(file_map);
		position = 0;
		pgReadDoc(test_pg, &amp;position, NULL, 0, NULL, file_map);
		DisposeMemory(file_map);
		_lclose(file_ref);
		GetClientRect(hWnd, &amp;view_area);
		InvalidateRect(hWnd, &amp;view_area, FALSE);
	}
}
</code></pre>
<h3 id='222-saving-a-document'>22.2 Saving a Document</h3>
<p>If you want to &quot;save&quot; a pg_ref in the native, default format, call the following:</p>
<pre><code>(pg_error) pgSaveDoc (pg_ref pg, long PG_FAR *file_position, pg_file_key_ptr keys, pg_short_t num_keys, file_io_proc write_proc, file_ref filemap, long doc_element_info);
</code></pre>
<p>This function writes all the information within <code>pg</code> to a specified file; the first byte is written to <code>*file_position</code>. When the function returns, <code>*file_position</code> will be updated to the next file location (hence, <code>*file_position</code> minus the position before the function is called = total byte size written to the file).</p>
<p>If the ending file position of all HERMES Paige data will not necessarily be the physical end-of-file, you must terminate the file properly. <!--(Please see "The pgWriteKeyData and ReadHandler method" <!--Section on page 398.--></p>
<p>The keys parameter is an optional pointer to a list of file keys known as file handlers. If this is a null pointer, all components of <code>pg</code> are written.</p>
<p>If the keys parameter is non-null, then <code>num_keys</code> must indicate how many items are in the list pointed to by keys, and <code>pgSaveDoc</code> only writes the components in the list of keys.</p>
<p>The <code>write_proc</code> is a pointer to a function that should do the physical I/O. However, this parameter can be a null pointer, in which case the standard file transfer function is used.</p>
<p>If <code>write_proc</code> is non-null, it must point to valid <code>file_io_proc</code> function — see section 34.5, <a href='#34.5-the-`file_io_proc`'>The <code>file_io_proc</code></a> if you want to write your own io function.</p>
<p>The filemap parameter is a <code>memory_ref</code> allocation that contains machine-specific information referencing the physical file that is to be written to.</p>
<p><strong>NOTE:</strong> The <code>filemap</code> must be a file reference to an opened file with write permission. The way to accomplish this is shown in the following function example (the <code>f_ref</code> parameter is a file reference obtained from <code>FSOpen</code>, or <code>PBOpen</code>, etc. for <em>Macintosh</em> or <code>_lopen</code>, etc. for Windows).</p>
<p>The <code>doc_element_info</code> parameter is used for identifying multiple <code>pg_ref</code> &quot;documents&quot; written to the same file. For a single document (or first in a series of <code>pg_ref</code> writes), <code>doc_element_info</code> should be zero.</p>
<p><strong>CAUTION:</strong> If you intend to write any data following the HERMES Paige data, or if the physical end-of-file will not exactly match the ending file position after <code>pgSaveDoc()</code>, it is essential that you terminate the HERMES Paige file by calling <code>pgTerminateFile()</code>. Not doing so will result in unexplained crashes when the file is reöpened.</p>
<p><strong>CAUTION:</strong> HERMES Paige does not set the physical end-of-file. In other words, if you created a file 1 megabyte in size and HERMES Paige wrote only 10 K of data, your physical file size will still be 1 megabyte. If appropriate you must truncate your file once all the data is saved.</p>
<h3 id='how-to-create-an-hermes-paige-filemap'>How to create an HERMES Paige filemap</h3>
<pre><code>file_ref make_paige_filemap (short_f_ref)
{
	file_ref ref_for_file;				// will be function result
	short *f_ptr;						// needs to init the &quot;filemap&quot;
	
	// creates an allocation, 2 bytes
	ref_for_file = MemoryAlloc(&amp;paige_rsrv.mem_globals, sizeof (short), 1, 0);
	f_ptr = UseMemory(ref_for_file);	// gets pointer to allocation *f_ptr_ref
	
	// fill in file ref
	UnuseMemory(ref_for_file);			// unlock the application
	return ref_for_file;
}

/* Once you have finished saving the file, you dispose the filemap as follows: */
DisposeMemory(filemap);
</code></pre>
<p><strong>NOTE:</strong> For a complete understanding of memory allocations, as shown in the above examples, see chapter 25, <a href='#25-the-allocation-manager'>The Allocation Manager</a>.</p>
<p>If <code>pgSaveDoc</code> is successful, zero is returned (implying no I/O errors). If unsuccessful, the appropriate error code will be returned (see chapter 39, <a href='#39-error-codes'>Error Codes</a>).</p>
<h3 id='saving-text-only'>Saving text only</h3>
<p>The best/fastest way to save text only is to walk through each block of text and write the text to a file. (HERMES Paige maintains text as separate records, each record containing a piece of the whole document). The following is a brief example of how you can do this:</p>
<pre><code class='language-c' lang='c'>paige_rec_ptr pg_rec;
pg_char_ptr text;
text_block_ptr block;
long num_blocks, text_size;

pg_rec = UseMemory(pg); 	// First get pointer to &quot;real&quot; HERMES Paige record
num_blocks = GetMemorySize(pg_rec -&gt; t_blocks); // = number of blocks
block = UseMemory(pg_rec -&gt; t_blocks);			// = first block

while (num_blocks)
{
	text_size = GetMemorySize(block -&gt; text);
	text = UseMemory(block -&gt; text);
	/* At this point, text_size is number of text bytes and text is pointer to text; hence, you can save *text to a file for text_size bytes. */
	UnuseMemory(block -&gt; text);
	++block;
	--num_blocks;
}
UnuseMemory(pg_rec -&gt; t_blocks);
UnuseMemory(pg);
</code></pre>
<h3 id='terminating-the-file'>Terminating the File</h3>
<p>If the ending file position of all HERMES Paige data will not be the physical end-of-file, you must terminate the file properly using <code>pgTerminateFile</code> as shown below.</p>
<p>For example, if you were to call <code>pgSaveDoc</code>, then set the physical end-of-file to the ending file position, your file save is complete (you do not need to terminate the file in any other way). If, however, you were to call pgSaveDoc but you then wanted to write additional data of your own beyond that point, you would first have to call the following function:</p>
<pre><code>(pg_error) pgTerminateFile (pg_ref pg, long PG_FAR *file_position, file_io_proc write_proc, file_ref filemap);
</code></pre>
<p>This function writes a file key that specifies the logical end-of-file for the HERMES Paige document. Later, when the file is read with <code>pgReadDoc</code>, HERMES Paige will recognise this key as the logical end-of-file and discontinue reading any data beyond that position.</p>
<p>Upon entry, <code>pg</code>, <code>file_position</code>, and <code>write_proc</code> should all be the same parameters that were given to <code>pgSaveDoc</code>.</p>
<h5 id='notes-24'>NOTES:</h5>
<ul>
<li>You <em>do not</em> need to call this function if the end of the HERMES Paige document and physical end-of-file is identical (but it does not hurt to do so).</li>
<li>The term &quot;logical end of file&quot; implies the end of the very last piece of data that can be read (later) by <code>pgReadDoc</code>. That includes all data written by <code>pgSaveDoc</code> and/or <code>pgWriteKeyData</code>.</li>
<li>When and if <code>pgReadDoc</code> encounters the logical end-of-file, the file offset returned by <code>pgReadDoc</code> will be positioned at the first byte after the end-of-file (which would have been the first byte written by your application if you wrote nonHERMES Paige data after this position).</li>

</ul>
<h2 id='223-reading-a-document'>22.3 Reading a Document</h2>
<p>To read a document previously saved with <code>pgSaveDoc</code>, call the following:</p>
<pre><code>(pg_error) pgReadDoc (pg_ref pg, long PG_FAR *file_position, pg_file_key_ptr keys, pg_short_t num_keys, file_io_proc read_proc, file_ref filemap);
</code></pre>
<p>In this function, <code>pg</code> must be a valid HERMES Paige object reference for which all data that is read can be placed; <code>pg</code>, however, can be completely empty. If it does contain data (text, styles, etc.), those items get replaced with data that is read from the file; items that are not processed from the file (i.e., data components not recognized or components that don&#39;t even exist in the file) will leave that component in <code>pg</code> unchanged.</p>
<p><strong>NOTE:</strong> It may be helpful to know that a function exists to create a completely &quot;empty&quot; <code>pg_ref</code> for purposes of <code>pgReadDoc</code> — see section 34.15, <a href='#3415-a-quick-and-easy-empty-hermes-paige-object'>A Quick and Easy Empty HERMES Paige Object</a>.</p>
<p>When <code>pgReadDoc</code> is called, what occurs is as follows: a data component is read beginning at the specified file offset; the data component always includes a &quot;header&quot; that includes the data key as well as the data size. The file handler (<code>pg_handler</code>) is searched for that contains the data key and, if found, the file handler function is called to process the data. If a <code>pg_handler</code> is not found, a special &quot;exception handler&quot; is called which will be described later in this section, and then the data is skipped.</p>
<p>Each data component is handled in this way, one element at a time, until the end-of-file is reached.</p>
<p><strong>NOTE:</strong> The &quot;end-of-file&quot; is not necessarily the physical end-of-file; rather, it is determined by the file position given to <code>pgTerminateFile()</code>.</p>
<p>The <code>file_position</code> parameter must point to the first file offset to read, in bytes. The offset is zero-indexed, relative to the beginning of the file, and must be the same position given to <code>pgSaveDoc()</code> when the file was written.</p>
<p>If <code>keys</code> is a null pointer, <code>pgReadDoc</code> will try to process every data element it reads. If keys is non-null, it must be a pointer to a list of <code>num_key</code> keys; if such a list is given, <code>pgReadDoc</code> will only consider processing the <code>keys</code> that are in the list.</p>
<p>The <code>read_proc</code> is a pointer to a function that should do the physical I/O. However, this parameter can be a null pointer, in which case the standard file transfer function is used.</p>
<p>If <code>read_proc</code> is non-null, it must point to valid <code>file_io_proc</code> function — see section 34.5, <a href='#34.5-the-`file_io_proc`'>The <code>file_io_proc</code></a> if you want to write your own I/O function.</p>
<p>The <code>filemap</code> parameter is a <code>memory_ref</code> allocation that contains a file reference, native to the runtime platform.</p>
<p><strong>NOTE:</strong> The <code>filemap</code> must be a file reference to an opened file with at least read permission. The way to accomplish this is shown in the example above for <code>pgSaveDoc</code>.</p>
<p>If <code>pgReadDoc</code> is successful, zero is returned (implying no I/O errors). If unsuccessful, the appropriate error code will be returned (see chapter 39, <a href='#39-error-codes'>Error Codes</a>).</p>
<h2 id='224-verifying-an-hermes-paige-formatted-file'>22.4 Verifying an HERMES Paige-formatted File</h2>
<p>You can verify if a file is a true HERMES Paige file or not by calling the following:</p>
<pre><code>(pg_error) pgVerifyFile (file_ref filemap, file_io_proc io_proc, long position);
</code></pre>
<p>Use this function to &quot;test&quot; any file to find out if it is truly an HERMES Paige file. Upon entry, <code>filemap</code> and <code>io_proc</code> must be the same parameters you would pass to <code>pgReadDoc()</code>.</p>
<p>The position parameter specifies the file position, in bytes.</p>
<p><strong>FUNCTION RESULT:</strong> If the function returns zero, the file is a valid HERMES Paige file. Otherwise the appropriate error code is returned (usually <code>BAD_TYPE_ERR</code>).</p>
<h2 id='225-do-you-need-the-remaining-info'>22.5 Do you need the remaining info?</h2>
<p>The rest of this chapter explains the details of extending the HERMES Paige saving mechanisms to your own applications. If you are saving only the contents of a <code>pg_ref</code>, you do not need to read anything else in this chapter. If you are saving &quot;custom&quot; information, read on.</p>
<h2 id='226-saving-your-own-data-format'>22.6 Saving Your Own Data Format</h2>
<p><strong>NOTE:</strong> There is nothing preventing you from writing and reading whatever you want before and after HERMES Paige transfers the contents of a <code>pg_ref</code>. Calling <code>pgSaveDoc()</code> simply serialises a stream of objects beginning at the file position you have specified, and there is nothing to prevent you from writing other data after that location. If you consider the composite stream of HERMES Paige data as one single &quot;record&quot; in a file, the concept of integrating your own data may be simplified.</p>
<p>On more than one occasion, an HERMES Paige user has asked how some particular data format can be forced using the HERMES Paige file mechanism, or how text can be saved as one continuous block of text, etc.</p>
<p>The answer is possibly non-intuitive, yet fairly simple once it is grasped:</p>
<ol start='' >
<li>If you have no reason to make HERMES Paige automatically read your custom data, just write the data before or after the HERMES Paige data and read it back the same way (see note <em>supra</em>).</li>
<li>If you want HERMES Paige to save the data for you and notify you when it reads it back, use <code>pgWriteKeyData</code> to save the structure, and then use a custom handler to read the structure (see example <em>infra</em>).</li>

</ol>
<p>If you want HERMES Paige to write your data and notify you when it is read, the easiest way to go is to write the data with <code>pgWriteKeyData</code> and retrieve it with a read handler. If this method seems appropriate to your situation, the following sample code illustrates how this can be done:</p>
<pre><code>void SaveMyData (some_arbitrary_struct *myData, long myDataSize, pg_file_key myFileKey)
{

/* First, save pg_refusing all the defaults. The &quot;myFileRef&quot; is a memory_ref containing the file reference specific to the machine. For Macintosh, the memory_ref contains the file refNum. For Windows, the memory_ref contains the integer result from OpenFile (or _lopen, etc.). */

long position;
position = 0; 	// We save file starting at first byte (but don&#39;t have to) 
pgSaveDoc(pg, \&amp;position, NULL, 0, NULL, myFileRef, 0);
pgWriteKeyData(pg, myFileKey, (void *)myData, myDataSize, myRefCon, NULL, &amp;position, myFileRef);
}
</code></pre>
<h5 id='notes-25'>Notes:</h5>
<ol start='' >
<li><code>myRefCon</code> represents any value you want to save as a reference. You will get this value handed back to you in the read handler (below). </li>
<li><code>MyFileKey</code> can be any number &gt;= <code>CUSTOM_HANDLER_KEY</code>. This value is used to identify the data item when the file is read later. </li>
<li>You can call a similar function as above multiple times. When the file is read, your read handler will get called for each occurrence of the data as it is read.</li>

</ol>
<h3 id='the-read-handler'>The Read Handler</h3>
<p>To read the data structure(s) back, you first install a read handler:</p>
<pre><code>pgSetHandler(&amp;paige_globals, myFileKey, myReadHandler, NULL, NULL, NULL, NULL);
</code></pre>
<p>The value for <code>myFileKey</code> should be the same as the value used in the above example for writing the data.</p>
<p>Your read handler should look like this:</p>
<pre><code>PG_PASCAL (pg_boolean) myReadHandler (paige_rec_ptr pg, pg_file_key the_key, memory_ref key_data, long PG_FAR *element_info, void PG_FAR *aux_data, long PG_FAR *unpacked_size)
{
	/* ... */
}
</code></pre>
<p>HERMES Paige calls this function each time it reads data from the file that was saved as <code>the_key</code> (previously written as <code>myFileKey</code> in the example contained in the section preceding). You can ignore almost all of the parameters; the only two you probably care about are <code>key_data</code> (which holds the data that has been read from the file) and <code>element_info</code> (which points to &quot;myRefCon&quot; saved earlier).</p>
<p>Retrieving the data in the read handler: the data, as originally written to the file, will be contained in <code>key_data</code>. To get a pointer to the data, simply do:</p>
<pre><code>ptr = UseMemory(key_data);
</code></pre>
<p>NOTE: be sure to do <code>UnuseMemory</code> after accessing the data in <code>ptr</code>. To learn how large the data is, do:—</p>
<pre><code>data_size = GetMemorySize(key_data);
</code></pre>
<h3 id='the-hybrid'>The Hybrid</h3>
<p>Sometimes you need to save file data in some specific format, bypassing the HERMES Paige file I/O system altogether, yet you want HERMES Paige to save most of the <code>pg_ref</code> data items.</p>
<p>To do so, perform the following logic:</p>
<h4 id='to-save'>To save</h4>
<ol start='' >
<li>Call <code>pgSaveDoc</code> in the normal way (if you need to save regular <code>pg_ref</code> items).</li>
<li>Call <code>pgTerminateFile</code> (which tells HERMES Paige there will be no more HERMES Paige-based data).</li>
<li>At this point the file position will be known (i.e. the next byte offset to write some additional data). Write this data in any way you choose.</li>

</ol>
<h4 id='to-retrieve-the-data'>To retrieve the data</h4>
<ol start='' >
<li>Call <code>pgReadDoc</code> (if you used <code>pgSaveDpc</code> to save).</li>
<li>The file offset will return to you positioned on the first byte you originally wrote. Read the data in whatever method is appropriate.</li>

</ol>
<p><strong>NOTE:</strong> You can perform the &quot;reverse,&quot; if necessary, by calling <code>pgSaveDoc</code> <em>after</em> you write your own data. This will still work so long as you provide the correct file position to <code>pgSaveDoc</code> to begin saving that same file position for <code>pgReadDoc</code> to begin reading.</p>
<p>HERMES Paige file mechanism provides some <em>optional</em> utilities to &quot;compress&quot; a series of numbers so your data transfer is smaller. You can certainly use your own instead of these.</p>
<p>These functions make data portable between platforms. This is because they resolve the saving and retrieving certain numbers between Macintosh and Windows which save those numbers backwards from each other. These function make those numbers portable.</p>
<p>By &quot;series of numbers&quot; is meant an array of longs or shorts, or consecutive fields in a record structure, etc.</p>
<p>For example, suppose you need to save a large record structure that consists mostly of zeros. Using the &quot;pack&quot; and &quot;unpack&quot; methods described below you can conserve a great deal of space.</p>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgSetupPacker (pack_walk_ptr walker, memory_ref ref, long first_offset);
</code></pre>
<p><code>pgSetupPacker</code> sets up a special record to begin packing or unpacking numbers. For &quot;packing&quot; numbers, you begin with a zero-size <code>pg_ref</code> and the packing functions append data to it; for unpacking, you begin with a <code>memory_ref</code> that already has packed data (or contains packed data read from a file) and retrieve the data with the unpacking functions (see below).</p>
<p>The <code>walker</code> parameter must be a pointer to a <code>pack_walk</code> record (defined in <code>pgFiles.h</code>). If you are packing/unpacking from a read or write handler, the <code>ref</code> parameter should be the <code>key_data</code> <code>memory_ref</code> given to you when a read or write handler is called. Or, if you are using the pack/unpack functions outside of a read or write handler, <code>ref</code> must be a valid <code>memory_ref</code> with a record size of one byte and a memory size of zero for packing, or a valid <code>memory_ref</code> containing previously packed data for unpacking.</p>
<p>The <code>first_offset</code> parameter should be zero.</p>
<p>Once the <code>pack_walk</code> record is set up, you can use the functions given below.</p>
<p><strong>NOTE:</strong> If packing numbers, once you are through, call <code>pgFinishPack</code>.</p>
<h3 id='packing'>Packing</h3>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgPackNum (pack_walk_ptr out_data, short code, long value);
</code></pre>
<p>Adds a long or short numeric value to the packed data. The <code>out_data</code> parameter must point to an initialised <code>pack_walk</code> record previously set up with <code>pgSetupPacker</code>.</p>
<p>The <code>code</code> parameter should be <code>short_data</code> if packing an integer or <code>long_data</code> for packing a <code>long</code>. The value parameter is the numeric value to pack.</p>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgPackNumbers (pack_walk_ptr out_data, void PG_FAR *ptr, short qty, short data_code);
</code></pre>
<p>Identical to <code>pgPackNum</code> except an array of numbers are packed. The <code>ptr</code> parameter must point to the first number in the array, the <code>qty</code> parameter indicates the number of elements in the array, and <code>data_code</code> must be <code>short_data</code> if the elements are integers or <code>long_data</code> if the elements are <code>long</code>s. All elements must be the same type (all must be either <code>short</code>s or <code>long</code>s, not a mixture).</p>
<pre><code>#include &quot;pgFiles.h&quot;
(memory_ref) pgFinishPack (pack_walk_ptr walker);
</code></pre>
<p>Completes the packing within <code>walker</code> (by optimising the compression and terminating the internal packed data structure).</p>
<p>If you have packed anything at all, you <em>must</em> call this function.</p>
<p><strong>CAUTION:</strong> <em>Do not</em> call <code>pgFinishPack</code> if you have not actually packed any data (i.e., the original <code>memory_ref</code> is still zero size).</p>
<p>The function returns the same <code>memory_ref</code> you originally gave <code>pgSetupPacker</code>.</p>
<h3 id='unpacking'>Unpacking</h3>
<pre><code>#include &quot;pgFiles.h&quot;
(long) pgUnpackNum (pack_walk_ptr in_data);
</code></pre>
<p>Returns a number that was previously packed. The <code>in_data</code> parameter must be a pointer to an initialised <code>pack_walk</code> record (using <code>pgSetupPacker</code>).</p>
<p><strong>NOTE:</strong> Numbers must be unpacked in the same order as they were packed. However, <code>pgUnpackNum</code> will simply return zero(s) if you ask for more numbers than were packed.</p>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgUnpackNumbers (pack_walk_ptr out_data, void PG_FAR *ptr, short qty, short data_code);
</code></pre>
<p>Identical to <code>pgUnpackNum</code> except an array of numbers are unpacked. The <code>ptr</code> parameter must point to the first number in the array to receive the numbers, the <code>qty</code> parameter indicates the number of elements in the array, and <code>data_code</code> must be <code>short_data</code> if the elements are integers or <code>long_data</code> if the elements are <code>long</code>s. All elements must be the same type (all must be either <code>short</code>s or <code>long</code>s, not a mixture) and they must be the same type(s) that were originally packed. If more numbers are asked for than were packed, this function fills the extra array elements with zeros.</p>
<p><strong>NOTE:</strong> You <em>do not</em> call <code>pgFinishPack</code> for unpacking—that function is only used to terminate data after using the &quot;pack&quot; functions.</p>
<h3 id='additional-packunpack-utilities'>Additional Pack/Unpack Utilities</h3>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgPackBytes (pack_walk_ptr out_data, pg_char_ptr the_bytes, long length);
</code></pre>
<p>Appends <code>the_bytes</code> data of size <code>length</code> to the packed data in <code>out_data</code>.</p>
<p><strong>NOTE:</strong> The data is not actually &quot;compressed&quot; but is simply included in the data stream and can be retrieved with <code>pgPackBytes</code> or <code>pgUnpackPtrBytes</code> below.</p>
<p>It is OK to mix <code>pgPackBytes</code> with <code>pgPackNum</code> or <code>pgPackNumbers</code> as long as you retrieve the data in the same order that you packed it.</p>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgUnpackPtrBytes (pack_walk_ptr in_data, pg_char_ptr out_ptr);
</code></pre>
<p>Unpacks data previously packed with <code>pgPackBytes</code>. The bytes are written to <code>*out_ptr</code> in the same order they were originally packed. It is your responsibility to make sure <code>out_ptr</code> can contain the number of bytes about to be unpacked. (If you aren&#39;t sure about the size of the unpacked data, or if the data might be arbitrarily huge, it might be better to use <code>pgUnpackBytes</code> below).</p>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgUnpackBytes (pack_walk_ptr in_data, memory_ref out_data);
</code></pre>
<p>Identical to <code>pgUnpackPtrBytes</code> except the unpack data is placed in <code>out_data</code> <code>memory_ref</code>. The <code>memory_ref</code> will be sized to hold the total number of unpacked
bytes. The advantage of using this method versus <code>pgUnpackPtrBytes</code> is that you do not need to know how large the data is.</p>
<pre><code>#include &quot;pgFiles.h&quot;
(long) pgGetUnpackedSize (pack_walk_ptr walker);
</code></pre>
<p>Returns the size, in bytes, of the next data in <code>walker</code>. This function works for all types of data that have been packed, both numbers and bytes.</p>
<h4 id='rectangle-2'>Rectangle</h4>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgPackRect (pack_walk_ptr walker, rectangle_ptr r);
(void) pgUnpackRect (pack_walk_ptr walker, rectangle_ptr r);
</code></pre>
<p>Packs/unpacks a rectangle <code>r</code>.</p>
<h4 id='coordinate-2'>Co_ordinate</h4>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgPackCoOrdinate (pack_walk_ptr walker, co_ordinate_ptr point);
(void) pgUnpackCoOrdinate (pack_walk_ptr walker, co_ordinate_ptr point);
</code></pre>
<p>Packs/unpacks a <code>co_ordinate</code>.</p>
<h4 id='colour'>Colour</h4>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgPackColor (pack_walk_ptr walker, color_value PG_FAR *color);
(void) pgUnpackColor (pack_walk_ptr walker, color_value PG_FAR *color);
</code></pre>
<p>Packs/unpacks a <code>color_value</code> colour into the packed data.</p>
<h4 id='shape'>Shape</h4>
<pre><code>#include &quot;pgFiles.h&quot;
(long) pgPackShape (pack_walk_ptr walker, shape_ref the_shape); 
(void) pgUnpackShape (pack_walk_ptr walker, shape_ref the_shape);
</code></pre>
<p>Packs/unpacks a shape <code>the_shape</code>.</p>
<h4 id='select-pair'>Select pair</h4>
<pre><code>#include &quot;pgFiles.h&quot;
(void) pgPackSelectPair (pack_walk_ptr walker, select_pair_ptr pair);
(void) pgUnpackSelectPair (pack_walk_ptr walker, select_pair_ptr pair);
</code></pre>
<p>Packs/unpacks a <code>select_pair</code> pair.</p>
<h1 id='23-huge-file-paging'>23 HUGE FILE PAGING</h1>
<p>&quot;File paging&quot; is a method in which large files are not read into memory all at once; rather, only the portion(s) that are needed to display are read dynamically as the user scrolls or &quot;pages&quot; through the document.</p>
<h2 id='231-paging-hermes-paige-files'>23.1 Paging HERMES Paige Files</h2>
<p>Any file that has been saved with <code>pgSaveDoc()</code> (or with the custom control message <code>PG_SAVEDOC</code>) can be opened in &quot;paging&quot; mode by calling a different function instead of <code>pgReadDoc()</code>:</p>
<pre><code>pg_error pgCacheReadDoc (pg_ref pg, long PG_FAR *file_position, const pg_file_key_ptr keys, pg_short_t num_keys, file_io_proc read_proc, file_ref filemap);
</code></pre>
<p>This function is 100% identical to <code>pgReadDoc()</code> except that the document is set to disc-paging mode. This means that the text portion of the document is not loaded into memory all at once; rather, only the portions that are needed are loaded dynamically.</p>
<p>The parameter values should be completely identical to what you would pass to <code>pgReadDoc()</code>. However, the physical disc file must remain open for disc paging to be successful, and closed only after the <code>pg_ref</code> is finally disposed.</p>
<p>Not only should the file remain open, but the filemap parameter must also remain valid. For example, if <code>filemap</code> is a <code>memory_ref</code> (which it will be for the standard &quot;open&quot; function), that <code>memory_ref</code> and its content must remain intact until the <code>pg_ref</code> has been disposed.</p>
<p>If <code>pgCacheReadDoc()</code> returns without error, all portions of the document except for its text will have been loaded into memory; the text portions will be loaded as needed during the course of the user&#39;s session with this document.</p>
<p>Similarly, for tight memory situations, HERMES Paige will unload text portions as required (if they have not been altered) to make room for other allocations. This unloading process occurs transparently even if you have not enabled virtual memory.</p>
<p><strong>NOTE:</strong> Calling <code>pgDispose()</code> does not close the file; your application must close the file after the <code>pg_ref</code> has been destroyed. If you need to obtain the original file reference, see &quot;<code>pgGetCacheFileRef()</code>&quot;<!-- on page 23-409 this document-->. If you are using your own <code>file_io_proc</code>, that <code>file_io_proc</code> must be available at all times until the document is disposed.</p>
<h2 id='232-hermes-paige-import-extension'>23.2 HERMES Paige Import Extension</h2>
<p>If you are opening file(s) with the HERMES Paige import extension, instead of calling <code>pgReadDoc()</code>, file paging is enabled by setting the <code>IMPORT_CACHE_FLAG</code> bit in the <code>import_flags</code> parameter as explained in section 17.2, <a href='#172-importing-files-from-c++'>Importing Files (from C++)</a>.</p>
<h3 id='text-file-paging'>Text file paging</h3>
<p>You can set a raw ASCII text file for file paging by using the HERMES Paige import extension for ASCII text files. To enable file paging, set the <code>IMPORT_CACHE_FLAG</code> bit in the <code>import_flags</code> parameter.</p>
<p>Paging text files causes only the text that is required for displaying to be loaded into memory.</p>
<p><strong>NOTE:</strong> You must keep the text file open until the document is disposed.</p>
<h2 id='233-custom-control'>23.3 Custom Control</h2>
<p>Use the message <code>PG_CACHEREADDOC</code> instead of <code>PG_READDOC</code> to enable disk paging.</p>
<p><strong>NOTE:</strong> <code>wParam</code> and <code>lParam</code> are identical with both messages. The file must remain open, however, until the control window is closed.</p>
<h2 id='234-getting-the-file-reference'>23.4 Getting the File Reference</h2>
<pre><code>file_ref pgGetCacheFileRef (pg_ref pg);
</code></pre>
<p>This function returns the file, if any, that was given to <code>pgCacheReadDoc()</code>. Or, if you enabled file paging with the HERMES Paige import extension, the value returned from this function will be the original file reference given to the import class.</p>
<p>The usual reason for calling this function is to obtain the file reference before disposing the <code>pg_ref</code> so the file can be closed.</p>
<h3 id='235-file-paging-save'>23.5 File Paging Save</h3>
<pre><code>pg_error pgCacheSaveDoc (pg_ref pg, long PG_FAR *file_position, const pg_file_key_ptr keys, pg_short_t num_keys, file_io_proc write_proc, file_ref filemap, long doc_element_info);
</code></pre>
<p>This function is identical to <code>pgCacheReadDoc()</code> except it should be called to save a file that is currently enabled for file paging (i.e., the document was previously opened with <code>pgCacheReadDoc()</code> or imported with the <code>IMPORT_CACHE_FLAG</code> bit).</p>
<p>Calling <code>pgCacheSaveDoc()</code> creates an identical file to <code>pgSaveDoc()</code> and accepts the same parameters to its function; the difference, however, is how it handles certain situations that might otherwise fail (for example, saving to the same file that is currently open for file paging).</p>
<p>It is safe to use <code>pgCacheSaveDoc()</code> even if the document is not enabled for file paging.</p>
<p>If this function is successful, the filemap parameter becomes the new file paging reference (the same as if you had reopened the file with <code>pgCacheReadDoc()</code>). It is therefore important that you close the previous file (if it was different) and that you do not close the new file just saved.</p>
<p><strong>NOTE:</strong> Opening a file with <code>pgCacheReadDoc()</code> then re-saving to that same file with <code>pgCacheSaveDoc()</code> will only work correctly if the filemap parameter is exactly the same <code>file_ref</code> for both opening and saving.</p>
<h2 id='236-writing-additional-data'>23.6 Writing Additional Data</h2>
<p>If you need to write additional data to an HERMES Paige file it is safe to do so after <code>pgCacheSaveDoc()</code> returns; or, if you are certain that the file being written is a different file than the original file given to <code>pgCacheReadDoc()</code>, it is safe to write data before and/or after <code>pgCacheSaveDoc()</code>.</p>
<p>You may also call extra functions such as <code>pgSaveAllEmbedRefs()</code> and <code>pgTerminateFile()</code> in the same way they are used with <code>pgSaveDoc()</code>.</p>
<h2 id='237-hermes-paige-export-extension'>23.7 HERMES Paige Export Extension</h2>
<p>If you are saving file(s) with the HERMES Paige export extension, you can cause the same effect as <code>pgCacheSaveDoc()</code> by setting the <code>EXPORT_CACHE_FLAG</code> bit in the <code>export_flags</code> parameter—see chapter 18, <a href='#18-hermes-paige-export-extension'>HERMES Paige Export Extension</a>.</p>
<h1 id='24-miscellaneous-utilities'>24 MISCELLANEOUS UTILITIES</h1>
<h2 id='241-require-recalc'>24.1 Require <code>recalc</code></h2>
<pre><code>(void) pgInvalSelect (pg_ref pg, long select_from, long select_to);
</code></pre>
<p>The text from <code>select_from</code> to <code>select_to</code> in <code>pg</code> is <em>invalidated</em>, i.e., marked to require recalculation, new word wrap, etc.</p>
<p>Both parameters are zero-indexed byte offsets. No actual calculation is performed until <code>pgPaginateNow</code> is called (see section 24.3, <a href='#243-paginate-now'>Paginate Now</a>) or the text (or highlighting) is drawn.</p>
<h2 id='242-highlight-region'>24.2 Highlight Region</h2>
<pre><code>pg_boolean pgGetHiliteRgn (pg_ref pg, select_pair_ptr range, memory_ref select_list, shape_ref rgn);
</code></pre>
<p>This function sets <code>rgn</code> to the &quot;highlight&quot; shape for the specified range of text.</p>
<p>The <code>rgn</code> parameter must be a valid <code>shape_ref</code> (which you create); when the function returns, that shape will contain the appropriate highlight region.</p>
<p>The text offsets that are used to compute the region are determined as follows: if <code>range</code> is not a NULL pointer, that selection pair is used; if <code>range</code> is NULL but <code>select_list</code> is not <code>MEM_NULL</code>, then <code>select_list</code> is used as a list of selection pairs (see below). If both are NULL, the current selection range in <code>pg</code> is used.</p>
<p>The <code>select_list</code> parameter, if not <code>MEM_NULL</code>, must be a valid <code>memory_ref</code> containing a list of <code>select_pair</code> records. Usually, a selection list of this type is used for discontinuous selections (see &quot;Discontinuous Selections&quot;<!-- on page 10-161--> for information about <code>pgGetSelectionList</code> and <code>pgSetSelectionList</code>).</p>
<p><strong>FUNCTION RESULT:</strong> <code>TRUE</code> is returned if the resulting highlight region is not empty.</p>
<h2 id='243-paginate-now'>24.3 Paginate Now</h2>
<pre><code>(void) pgPaginateNow (pg_ref pg, long paginate_to, short use_best_guess);
</code></pre>
<p>The HERMES Paige object is forcefully &quot;paginated&quot; (lines computed) from the start of the document up to the text offset <code>paginate_to</code>.</p>
<p>If <code>use_best_guess</code> is <code>TRUE</code>, HERMES Paige does not calculate every single line, rather it makes a guess as to the document&#39;s height.</p>
<p>If the document is already calculated, this function does nothing.</p>
<h5 id='notes-26'>NOTES:</h5>
<ol start='' >
<li>On a large document, full pagination from top to bottom can take several seconds; be that as it may, it is the only <em>guaranteed</em> method to produce 100% accuracy on text height or line positions.</li>
<li>HERMES Paige automatically calls this function for you in most cases that require it.</li>

</ol>
<h2 id='244-style-info'>24.4 Style Info</h2>
<pre><code>(pg_boolean) pgFindStyleInfo (pg_ref pg, long PG_FAR *begin_position, long PG_FAR *end_position, style_info_ptr match_style, style_info_ptr mask, style_info_ptr AND_mask);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns <code>TRUE</code> if a specific style—or portions thereof—can be found in <code>pg</code>.</p>
<p>Upon entry, <code>begin_position</code> must point to a text offset (i.e., a zero-indexed byte offset); when this function returns and a style is found, <code>*begin_position</code> will get set to the offset where the found style begins and <code>*end_position</code> to the offset where that style ends in the text.</p>
<p>Styles are searched for by comparing the fields in <code>match_style</code> to all the <code>style_info</code> records in <code>pg</code> as follows: Only the fields corresponding to the non-zero fields in <code>mask</code> are compared; before the comparison, the corresponding value in <code>AND_mask</code> is <code>AND</code>ed temporarily with the value in the <code>style_info</code> record in question. If all fields match in this way, the function returns <code>TRUE</code> and sets <code>begin_position</code> and <code>end_position</code> accordingly.</p>
<p>If <code>match_style</code> is a null pointer, the function will always return <code>TRUE</code> (it will simply advance to the next style). If <code>mask</code> is null, then all fields are compared (such that the whole style must match to be <code>TRUE</code>). If <code>AND_mask</code> is null, no <code>AND</code>ing is performed (and the whole field is compared).</p>
<h2 id='245-examine-text'>24.5 Examine Text</h2>
<pre><code>pg_char_ptr pgExamineText (pg_ref pg, long offset, text_ref *text, long PG_FAR *length);
</code></pre>
<p>This function provides a way for you to examine text directly in an HERMES Paige object.</p>
<p>The <code>offset</code> parameter should be set to the absolute, zero-indexed byte offset you wish to return. The text parameter is a pointer to a <code>text_ref</code> variable which will get set to a <code>memory_ref</code> by HERMES Paige before the function returns. The length parameter must point to a <code>long</code>, which also gets set by HERMES Paige.</p>
<p>FUNCTION RESULT: A pointer is returned that points to the first character of offset; <code>*text</code> is set to the <code>memory_ref</code> for that text, which you must &quot;unuse&quot; after you are through looking at the text (see below); <code>*length</code> will get set to the text length of the pointer, which will be the number of characters to the end of the text block from which the text was taken (it won&#39;t necessarily be the remaining length of all text in <code>pg</code>).</p>
<pre><code>// This shows getting the text at offset 123:
text_ref ref_for_text;
long_t length;
pg_char_ptr the_text;
the_text = pgExamineText(pg, 123, &amp;ref_for_text, &amp;t_length);

// ... do whatever with the text, then:
UnuseMemory(ref_for_text);	
// .. otherwise it stays locked! */
</code></pre>
<h3 id='tech-note-examining-some-text'>TECH NOTE: Examining some text</h3>
<blockquote><p>I&#39;d like to know how to fetch the text from an HERMES Paige document. I&#39;ve read the manual and still don&#39;t get it. I&#39;ve created an HERMES Paige document in a dialog so I can allow the user to enter more than 255 characters. Inserting text is no problem. How do I get it back out. A hint would be fine, a snippet of code would be marvelous.</p>
</blockquote>
<p>Although some of the solutions below will work, the method above described is more for high-speed direct text access used for find/replace features, or spell checking, etc.</p>
<p>In your case, however, I think walking through the text blocks using pgExamineText might be unnecessarily complex. Just use the following function:</p>
<pre><code>text ref pgCopyText (pg_ref pg, select_pair_ptr selection, short data_type;
/* See section &quot;Copying Text Only&quot; &lt;!-- on page 5-109--&gt; */
</code></pre>
<p>Given a specific selection of text in <code>selection</code>, this returns a <code>memory_ref</code> that has the text you want. Very simple. The <code>data_type</code> parameter should be one of the following:</p>
<pre><code>enum
{
	all_data,				// Return all data
	all_text_chars,			// All text that is writing script
	all_roman,				// All Roman ASCII chars
	all_visible_data,		// Return all visible data
	all_visible_text_chars,	// All visible text that is writing script
	all_visible_roman		// All visible Roman ASCII chars
};
</code></pre>
<p>The one you want is probably <code>all_data</code> or <code>all_text_chars</code>.</p>
<p>If <code>selection</code> is NULL, the text returned will be the currently selected (highlighted) text; otherwise, it returns the text within the specified selection (which is probably what you want). This parameter should therefore point to a <code>select_pair</code> record which is defined as:</p>
<pre><code>typedef struct select_pair
{
long begin;	// beginning of selection
long end;		// end of selection
};
</code></pre>
<p>To copy all text, <code>begin</code> should be zero and <code>end</code> should be <code>pgTextSize(pg)</code>.</p>
<p>The function returns a <code>text_ref</code> which is a <code>memory_ref</code>. To get the text inside, do this:</p>
<pre><code>Ptr text;
text = UseMemory(ref); /* .. where &quot;ref&quot; is function result */
</code></pre>
<p>Then when you&#39;re finished looking at the text, do:</p>
<pre><code>UnuseMemory(ref);
</code></pre>
<p>Finally, to dispose the <code>text_ref</code> call <code>DisposeMemory(ref)</code>.</p>
<p>This should be the way to go.</p>
<h3 id='tech-note-examining-text-across-the-text-blocks'>TECH NOTE: Examining text across the text blocks</h3>
<blockquote><p>I am using <code>pgExamineText</code> to access the text in the HERMES Paige object I am searching. This creates some problems because of the HERMES Paige text blocks.</p>
</blockquote>
<p>It depends on what you are searching for. Under normal conditions, HERMES Paige always splits a block on a CR (carriage return) character (including the CR as its last character, which means it can&#39;t ever break in the middle of a line or word. And by &quot;normal&quot; conditions I mean a document composed of reasonably sized paragraphs where CRs exist at, say, every few hundred characters. If you have some mongo paragraph that goes for pages, the block gets split somewhere else with no other choice. Even then, however, it tries to break it at a word boundary and not in the middle.</p>
<p>Hence you might improve your searching by checking for CR at the end of the block—it would only be when you&#39;re searching on something that must cross a CR boundary would it be necessary to cross the block.</p>
<p>In any event, it also depends on how you are actually doing the search/compare. If you&#39;re using some black-box code that requires a continuous text pointer, then I see why you have a problem. But if you rolled your own, why can&#39;t you just increment to the next buffer with a new <code>pgExamineText</code>?</p>
<blockquote><p>A second related issue has to do with non-case sensitive searches. To handle this I convert the find string &amp; all the text in the HERMES Paige target to upper case (<code>CtoUpper</code> <!-- ??? --> function) and search in the regular way.</p>
</blockquote>
<p>Again, I am wondering if you&#39;re doing your own compare-character function versus calling someone&#39;s &quot;compare&quot; black box. I&#39;ve written character compare searches many times, and to do case insensitive compares I simply convert the character from each pointer to upper case (in a separate variable) before comparing. Of course you can do all that at once by copying all of it to a buffer. I&#39;m not sure which way is fastest.</p>
<blockquote><p>… it appears that I need to allocate memory, move the text into it and work with the copy. It looks like <code>MemoryDuplicate</code> may be the way to go.</p>
</blockquote>
<p>Maybe, but what would be a lot faster is to allocate a worst-case <code>memory_ref</code>, then use <code>MemoryCopy</code>. The reason this would be a lot faster is you wouldn&#39;t need to keep creating a <code>memory_ref</code>, rather you would just slam the text straight into your allocation for each block. And, the way HERMES Paige Allocation Manager works is that almost no <code>SetHandleSize</code> would ever occur.</p>
<p>If you want to concatenate two text blocks together in your <code>memory_ref</code>, you should first do <code>MemoryCopy</code> for the first one, then for the second you do:</p>
<pre><code>ptr = AppendMemory(memory_ref, size_of_2nd_block, FALSE);
BlockMove(text_ptr_of_send_block, ptr, size_of_2nd_block);
UnuseMemory(memory_ref);
</code></pre>
<p>For additional speed, if you elect to do the <code>MemoryCopy</code> method, you might consider bypassing <code>pgExamineText</code> and going directly to the block. You can do this using the same functions HERMES Paige uses (the <code>offset</code> parameter is the desired text offset):</p>
<pre><code>paige_rec_ptr pg rec;
text_block_ptr block;
pg_rec = UseMemory(pg);	// pg = your pg_ref
block = pgFindTextBlock(pg_rec, offset, NULL, FALSE);
text_ptr = UseMemory(block -&gt; text);
</code></pre>
<p>… then, when through with block:</p>
<pre><code>UnuseMemory(block -&gt; text);
UnuseMemory(pg_rec -&gt; t_blocks);
UnuseMemory(pg);
</code></pre>
<p>You can also get total number of blocks as:</p>
<pre><code>num_blocks = GetMemorySize(pg_rec -&gt; t_blocks);
</code></pre>
<p><strong>NOTE:</strong> you need to include <code>pgText.h</code> which contains the lowlevel function prototype for <code>pgFindTextBlock</code>.</p>
<h3 id='tech-note-things-to-know-about-text-blocks'>TECH NOTE: Things to know about text blocks</h3>
<blockquote><p>Text blocks are an important part of HERMES Paige. We have found that only by using text blocks can you get acceptable performance. In fact, these text blocks are around 2 K in size by default. If text was not put into blocks you would get performance like TextEdit when text exceeds small blocks. As you know, it comes to a crawl when the text is larger than about 5 K.</p>
</blockquote>
<p>There are some important things you may want to know about text blocks however.</p>
<p>First of all, you should not look at the text using <code>HandleToMemory</code>, etc. HERMES Paige provides functions for getting a locked pointer to a chunk of text.</p>
<p>Second, you should not change the text by inserting directly into a block. You can exchange a character while in <code>pgExamineText</code>. But if you try and do any direct insertions, the block will be messed up, and all the subsequent styles will be wrong.</p>
<p>Third, HERMES Paige does its very best to break text blocks at a carriage return. If there is a carriage return within the block, HERMES Paige breaks there. If not, it simply breaks it at a convenient place. Therefore, you cannot be assured what the
last character is. You must use the length given you by <code>pgExamineText</code>. There is no character that you can check to know where the end of the text block is. HERMES Paige cannot assume you will want to use any particular character. No matter what character we might pick, someone will be using it in their data.</p>
<p>To access all the text, you simply walk through the blocks using <code>pgExamineText</code>.</p>
<h2 id='246-information-about-a-particular-character'>24.6 Information About a Particular Character</h2>
<pre><code>(long) pgCharType (pg_ref pg, long offset, long mask_bits); 
(pg_short_t) pgCharByte (pg_ref pg, long offset, pg_char_ptr char_bytes);
</code></pre>
<p>The two functions above will return information about a character.</p>
<p><strong>FUNCTION RESULT:</strong> The function result of <code>pgCharType</code> will be a set of bits describing specific attributes of the character in <code>pg</code> at byte location <code>offset</code>.</p>
<p>The <code>mask_bits</code> parameter defines which characteristics you wish to know; this parameter should contain the bit(s) set, according to the values listed <em>infra</em>, that you wish to be &quot;tested&quot;.</p>
<p>For example, if all you want to know about a character is whether or not it is &quot;blank&quot;, you would call <code>pgCharType</code> and pass <code>BLANK_BIT</code> in <code>mask_bits</code>; if you wanted to know if the character was blank or if the character is a control character, you would pass <code>BLANK_BIT | CTL_BIT</code>, etc. Selecting specific character info bits greatly enhances the performance of this function.</p>
<p>The result (and mask) can contain one or more of the following bits:</p>
<pre><code>#define BLANK_BIT				0x00000001	// Character is blank
#define WORD_BREAK_BIT			0x00000002	// Word breaking char
#define WORD_SEL_BIT			0x00000004	// Word select char
#define SOFT_HYPHEN_BIT			0x00000008	// Soft hyphen char
#define INCLUDE_BREAK_BIT		0x00000010	// Word break but include with word
#define INCLUDE_SEL_BIT			0x00000020	// Select break but include with word
#define CTL_BIT					0x00000040	// Char is a control code
#define INVIS_ACTION_BIT		0x00000080	// Char is not a display char, but arrow, bksp, etc
#define PAR_SEL_BIT				0x00000100	// Char breaks a paragraph
#define LINE_SEL_BIT			0x00000200	// Char breaks a line (soft CR)
#define TAB_BIT					0x00000400	// Char performs a TAB
#define FIRST_HALF_BIT			0x00000800	// First half of a multi-byte char
#define LAST_HALF_BIT			0x00001000	// Last half of a multi-byte char
#define MIDDLE_CHAR_BIT			0x00002000	// Middle of a multi-byte char run
#define CONTAINER_BRK_BIT		0x00004000	// Break-container bit
#define PAGE_BRK_BIT			0x00008000	// Break-repeating-shape bit
#define NON_BREAKAFTER_BIT		0x00010000	// Char must stay with char(s) after it
#define NON_BREAKBEFORE_BIT		0x00020000	// Char must stay with char(s) before it
#define NUMBER_BIT				0x00040000	// Char is numeric
#define DECIMAL_CHAR_BIT		0x00080000	// Char is decimal mark (for decimal tab)
#define UPPER_CASE_BIT			0x00100000	// Char is MAJUSCULE
#define LOWER_CASE_BIT			0x00200000	// Char is minuscule
#define SYMBOL_BIT				0x00400000	// Char is a symbol
#define EUROPEAN_BIT			0x00800000	// Char is ASCII-European
#define NON_ROMAN_BIT			0x01000000	// Char is not Roman script
#define NON_TEXT_BIT			0x02000000	// Char is not really text
#define FLAT_QUOTE_BIT			0x04000000	// Char is a typewriter quote
#define SINGLE_QUOTE_BIT		0x08000000	// Quote char is single &#39; quote
#define LEFT_QUOTE_BIT			0x10000000	// Char is a left quote
#define RIGHT_QUOTE_BIT			0x20000000	// Char is a right quote
#define PUNCT_NORMAL_BIT		0x40000000	// Char is normal punctuation
#define OTHER_PUNCT_BIT 		0x80000000	// Char is other punctuation in multi-byte

/* Convenient char_info macro for any quote char in globals: */
#define QUOTE_BITS (FLAT_QUOTE_BIT | SINGLE_QUOTE_BIT | LEFT_QUOTE_BIT |RIGHT_QUOTE_BIT)

/* CharInfo/pgCharType convenient mask_bits */
#define NON_MULTIBYTE_BITS ( (FIRST_HALF_BIT | LAST_HALF_BIT))
#define WORDBREAK_PROC_BITS (WORD_BREAK_BIT | WORD_SEL_BIT |NON_BREAKAFTER_BIT | NON_BREAKBEFORE_BIT)
</code></pre>
<p><strong>NOTE:</strong> When <code>pgCharType</code> is called, HERMES Paige calls the <code>char_info</code> function for the style assigned to the character at the specified offset.</p>
<p>If you need additional information about a character—or to obtain the character itself—use <code>pgCharByte</code>. This function will return the length of the character at byte location offset (remember that a character can be more than one byte). In addition to returning the length, the character itself will be copied to the buffer pointed to by <code>char_bytes</code>; make sure that this buffer contains enough space to hold a potential multi-byte character.</p>
<p>When calling <code>pgCharByte</code>, if the specified offset calls for a byte in the middle of a character, the appropriate adjustment will be made by HERMES Paige so the whole character is returned in <code>char_bytes</code>; the function result (length of character) will also reflect that adjustment. Hence, it will always return the whole character size even if offset indicates the last byte of a multi-byte character.</p>
<p>You can also use <code>pgCharByte</code> just to determine the length of a character: by passing a NULL pointer to <code>char_bytes</code>, <code>pgCharByte</code> simply returns the character size.</p>
<h3 id='tech-note-control-characters-dont-draw'>TECH NOTE: Control characters don&#39;t draw</h3>
<blockquote><p>HERMES Paige makes the assumption that all control characters (less than ASCII space) should be &quot;invisible.&quot; Rightly or wrongly, this is the default behavior we chose to avoid drawing unwanted, garbage characters. Hence, if you insert a &quot;command&quot; char (ASCII 17) it will be drawn as a blank.</p>
</blockquote>
<p>The correct workaround is to override HERMES Paige&#39;s default character handling in this one special case. This is not as difficult or complex as it may first seem and I will illustrate the exact code you need to implement:</p>
<p>Right after <code>pgInit</code>, you need to place a function pointer in HERMES Paige globals default style &quot;hook&quot; for getting character info. This function pointer will point to some small code that you will write (which I will show you). Let&#39;s suppose your HERMES Paige globals is called <code>paigeGlobals</code> and this (new) function you will write is called <code>CommandCharInfo</code>. Right after <code>pgInit</code>, you do this:</p>
<pre><code>paigeGlobals.def_style.procs.char_info = CommandCharInfo;
</code></pre>
<p>This sets <code>CommandCharInfo</code> as the &quot;default&quot; function for all future styles, and HERMES Paige calls that function to find out about a character of text. The <code>CommandCharInfo</code> function definition must look like the function example below. This function&#39;s main duty in life is to tell HERMES Paige that the command character <em>is not</em> blank, otherwise it just falls through and calls the standard <code>charInfo</code> function:</p>
<pre><code>// This function can be used to override &quot;get character info&quot;

#include &quot;defprocs.h&quot;	// You MUST INCLUDE this for function to compile

PG_PASCAL (long) CommandCharInfo (paige_rec_ptr pg, style_walk_ptr style_walker, pg_char_ptr data, long global_offset, long local_offset, long mask_bits)
{
	if (data[local_offset] == 17)	// If &quot;command char&quot;
		return (mask_bits &amp; (WORD_BREAK_BIT | WORD_SEL_BIT));
		
	// otherwise, just call the standard HERMES Paige charInfo function:
	
	return pgCharInfoProc(pg, style_walker, data, global_offset, local_offset, mask_bits);
}
</code></pre>
<p>For more information on <code>char_info_proc</code>, see <code>char_info_proc</code><!-- on page 27-498-->.</p>
<p>Many applications that want to display the Command Character may want to display other special characters, so I thought you
might prefer including something like the attached code in your examples as an alternative to the above.</p>
<pre><code>#include &lt;Fonts.h&gt;
PG_PASCAL (long) CommandCharInfo(paige_rec_ptr pg, style_walk_ptr style_walker, pg_char_ptr data, long global_offset, long local_offset, long bits)
{
	switch(data[local_offset])
	{
		case commandMark:
		case checkMark:
		case diamondMark:
		case appleMark:
			return (bits &amp; (WORD_BREAK_BIT | WORD_SEL_BIT));
	}
	return pgCharInfoProc(pg, style_walker, data, global_offset, local_offset, bits);
}
</code></pre>
<h2 id='247-finding-the-boundaries-word-line-or-paragraph'>24.7 Finding The Boundaries (word, line or paragraph)</h2>
<pre><code>(void) pgFindWord (pg_ref pg, long offset, long PG_FAR *first_byte, long PG_FAR *last_byte, pg_boolean left_side, pg_boolean smart_select);
(void) pgFindCtIWord (pg_ref pg, long offset, long PG_FAR *first_byte, long PG_FAR *last_byte, short left_side);
(void) pgFindPar (pg_ref pg, long offset, long PG_FAR *first_byte, long PG_FAR *last_byte);
(void) pgFindLine (pg_ref pg, long offset, long PG_FAR *first_byte, long PG_FAR *last_byte);
</code></pre>
<p><strong>NOTE:</strong> The term &quot;find&quot; in these functions does not imply a context search; rather, it refers to locating the bounding text positions at the beginning and ending of a section of text.</p>
<p>These function can be used to locate words, paragraphs, or lines.</p>
<p>For all functions, the <code>offset</code> parameter should indicate where to begin the search. This is a zero-indexed byte offset.</p>
<p>For <code>pgFindWord</code>, <code>*first_byte</code> and <code>*last_byte</code> will get set to the nearest word boundary beginning from <code>offset</code>.</p>
<p><strong>NOTE:</strong> <code>*first_byte</code> can be less than <code>offset</code>, but <code>*last_byte</code> will always be equal to or greater than <code>offset</code>. If <code>left_side</code> is <code>TRUE</code>, the word to the immediate left is located if <code>offset</code> is not currently in the middle of a word.</p>
<p>For example, suppose the specified <code>offset</code> sat right after the word <code>the</code> and before a <code>.</code> (full stop). If <code>left_side</code> is <code>FALSE</code>, the &quot;word&quot; that is found would be <code>.</code> but if <code>left_side</code> is <code>TRUE</code>, the word found would be <code>the</code>.</p>
<p>The <code>smart_select</code> parameter tells <code>pgFindWord</code> whether or not to include trailing blank characters for the word that has been found. If <code>smart_select</code> is <code>TRUE</code>, then trailing blanks (&quot;spaces&quot;) that follow the word are included. Example: If the text contained <code>This is a test for find word,</code> if <code>smart_select</code> is <code>TRUE</code> then finding the word <code>test</code> will return the offsets for <code>test__</code> (where <code>_</code> represent spaces).</p>
<p>The <code>pgFindCtlWord</code> function works exactly the same as <code>pgFindWord</code> except &quot;words,&quot; in this case, are sections of text separated by control codes such as tab and CR. (&quot;Control codes&quot; is used here to explain this function, but in actuality a character is considered only a &quot;control&quot; char by virtue of what is returned from the <code>char_info_proc</code>—see “Customising HERMES Paige”<!-- on page 27-485-->.</p>
<p>The <code>pgFindPar</code> and <code>pgFindLine</code> return the nearest paragraph boundaries or the nearest line boundaries to offset, respectively.</p>
<h2 id='248-line-and-paragraph-numbering'>24.8 Line and Paragraph Numbering</h2>
<p><strong>NOTE:</strong> The attribute bit <code>COUNT_LINES_BIT</code> <em>must</em> be set in the <code>pg_ref</code> for any of the following functions to work. This attribute can be set either by including it with other bits in the <code>flags</code> parameter for <code>pgNew</code>, or can be set with <code>pgSetAttributes</code>.</p>
<p><strong>CAUTION:</strong> Constantly counting lines and paragraphs, particularly within a large document with word wrapping enabled and complex style changes can consume considerable processing time. Hence, the <code>COUNT_LINES_BIT</code> has been provided to enable line counting only for applications that truly need this feature.</p>
<h3 id='line-numbering'>Line Numbering</h3>
<pre><code>(long) pgNumLines (pg_ref pg);
</code></pre>
<p>Returns the total number of lines in <code>pg</code>. This function will return zero if <code>COUNT_LINES_BIT</code> has not been set in <code>pg</code> (see previous note).</p>
<p><strong>NOTE:</strong> A &quot;line&quot; in an HERMES Paige object is simply a horizontal line of text which may or may not end with a CR or LF character. If word wrapping has been enabled, a line can terminate either because it word-wrapped or because it ended with CR.</p>
<p><strong>CAUTION:</strong> This function may consume a lot of time if the document is relatively large and has not been paginated to the end of the document. This is because HERMES Paige cannot possibly know how many word-wrapping lines exist unless it computes every line in the document from beginning to end; even if word-wrapping is disabled, HERMES Paige must still count all the line breaks (CR characters) if text has recently been inserted. </p>
<p><strong>NOTE:</strong> HERMES Paige will always take the fastest approach wherever possible, e.g. if the document has already been fully paginated this function will return a relatively instant response.</p>
<pre><code>(long) pgOffsetToLineNum (pg_ref pg, long offset, pg_boolean line_end_has_precedence);
</code></pre>
<p>Returns the line number that contains <code>offset</code> text position. The line number is <em>one-indexed</em> (i.e., the first line in <code>pg</code> is <code>1</code>). The <code>offset</code> parameter can be any position from 0 to <code>pgTextSize(pg)</code>, or <code>CURRENT_POSITION</code> for the current insertion point.</p>
<p>This function will always return at least one line even if the document has no text (since an empty document still has one line, albeit blank).</p>
<p>If <code>line_end_has_precedence</code> is <code>TRUE</code>, then the line number to the immediate left of <code>offset</code> is returned in situations where that offset is on the boundary between two lines.</p>
<p><strong>NOTE:</strong> The only time this happens is when the specified offset is precisely at the end of a word-wrapping line and there is another line below that.</p>
<p>For example, consider the insertion point within the following two lines:</p>
<pre><code>This is a line of text in HERMES Paige and the insertion
|
point is sitting on the end of the line above.
</code></pre>
<p><strong>NOTE:</strong> In the example above, the &quot;|&quot; point text offset could be interpreted to be the end of the first line <em>or</em> the beginning of the next line. Since HERMES Paige can&#39;t possibly know which one is desired, the <code>line_end_has_precedence</code> parameter has been provided. From the above example, if <code>line_end_has_precedence</code> is <code>TRUE</code>, the first line would be returned; otherwise, the second line would be returned.</p>
<pre><code>(void) pgLineNumToOffset (pg_ref pg, long line_num, long *begin_offset, long *end_offset);
</code></pre>
<p>Returns the text offset(s) of <code>line_num</code> line. The <code>line_num</code> parameter is one-indexed (i.e., the first line of text is <code>1</code> and not <code>0</code>).</p>
<p>The beginning text position of the line is returned in <code>*begin_offset</code> and the ending position is returned in <code>*end_offset</code>; both values will be zero-indexed (first position of text is zero). Either <code>begin_offset</code> or <code>end_offset</code> can be a null pointer, in which case it is ignored.</p>
<h3 id='paragraph-numbering'>Paragraph numbering</h3>
<pre><code>(long) pgNumPars (pg_ref pg);
</code></pre>
<p>Returns the total number of paragraphs in <code>pg</code>. This function will return zero if <code>COUNT_LINES_BIT</code> has not been set in <code>pg</code> (see note at the top of this section).</p>
<p><strong>NOTE:</strong> A &quot;paragraph&quot; in an HERMES Paige object is simply a block of text that terminates with a CR character (or CR/LF), or the last (or only) block of text in the document. This has nothing to do with word wrapping; in fact, if word wrapping has been disabled, lines and paragraphs are considered to be one and the same (since a line would only break on a CR character).</p>
<pre><code>(long) pgOffsetToParNum (pg_ref pg, long offset);
</code></pre>
<p>Returns the paragraph number that contains <code>offset</code> text position. The paragraph number is one-indexed (i.e., the first paragraph in pg is <code>1</code>). The <code>offset</code> parameter can be any position from <code>0</code> to <code>pgTextSize(pg)</code>, or <code>CURRENT_POSITION</code> for the current insertion point.</p>
<p>This function will always return at least one paragraph even if the document has no text (since an empty document still has one &quot;paragraph&quot; albeit empty).</p>
<pre><code>(void) pgParNumToOffset (pg_ref pg, long par_num, long *begin_offset, long *end_offset);
</code></pre>
<p>Returns the text offset(s) of <code>par_num</code> paragraph. The <code>par_num</code> parameter is one-indexed (i.e., the first paragraph of text is <code>1</code> and not <code>0</code>).</p>
<p>The beginning text position of the paragraph is returned in <code>*begin_offset</code> and the ending position is returned in <code>*end_offset</code>; both values are zero-indexed (first position of text is zero). Either <code>begin_offset</code> or <code>end_offset</code> can be a null pointer, in which case it is ignored.</p>
<p><strong>NOTE:</strong> The ending offset of a &quot;paragraph&quot; will be the position after its CR character (or the end of text if last or only paragraph in the document).</p>
<h3 id='line-and-paragraph-bounds'>Line and paragraph bounds</h3>
<pre><code>(void) pgLineNumToBounds (pg_ref pg, long line_num, pg_boolean want_scrolled, pg_boolean want_scaled, line_end_has_precedence, rectangle_ptr bounds);
</code></pre>
<p>Returns the bounding rectangular area that encloses <code>line_num</code> line. The line number is one-indexed (first line in <code>pg</code> is <code>1</code> and not <code>0</code>).</p>
<p>The bounding rectangle is returned in <code>*bounds</code> (which must not be a null pointer).</p>
<p>If <code>want_scrolled</code> is <code>TRUE</code>, the bounding rectangle will be offset to reflect the current scrolled position of <code>pg</code>, if any; if <code>want_scaled</code> is <code>TRUE</code>, the bounding rectangle will be scaled to <code>pg</code>&#39;s current scaling factor, if any.</p>
<p><strong>NOTE:</strong> The width of the rectangle that is returned will be the width of the text in the line, which is not necessarily the width of the visible area nor is it necessarily the same as the document&#39;s page width; the line width can also be zero if the line is completely empty.</p>
<pre><code>(void) pgParNumToBounds (pg_ref pg, long par_num, pg_boolean want_scrolled, pg_boolean want_scaled, rectangle_ptr bounds);
</code></pre>
<p>Returns the bounding rectangular area that encloses <code>par_num</code> paragraph. The paragraph number is one-indexed (first paragraph in <code>pg</code> is <code>1</code> and not <code>0</code>).</p>
<p>The bounding rectangle is returned in <code>*bounds</code> (which must not be a null pointer).</p>
<p>If <code>want_scrolled</code> is <code>TRUE</code>, the bounding rectangle will be offset to reflect the current scrolled position of <code>pg</code>, if any; if <code>want_scaled</code> is <code>TRUE</code>, the bounding rectangle will be scaled to <code>pg</code>&#39;s current scaling factor, if any.</p>
<p><strong>NOTE:</strong> The width of the rectangle that is returned will be the width of all composite lines within the paragraph, which is not necessarily the width of the visible area nor is it necessarily the same as the document&#39;s page width; the paragraph width can also be zero if the paragraph is completely empty.</p>
<h3 id='tech-note-getting-pixel-height-between-lines'>TECH NOTE: Getting pixel height between lines</h3>
<blockquote><p>What&#39;s the best way to calculate the pixel height of the text between given startline and endline? (replacing <code>TEGetHeight (endLine, startLine, macTE)</code>).</p>
</blockquote>
<p>The easiest approach depends on how you are currently determining the text location of these two &quot;lines.&quot; In your question you mention copying the lines to another <code>pg_ref</code>. But how did you figure out where the boundaries are of these two lines?</p>
<p>I will assume that you already know the text offset position for the start of each line. In this case, you can simply use <code>pgCharacterRect</code> for each text position and subtract the first rectangle&#39;s top from the second rectangle&#39;s bottom, which would be the line height difference between them.</p>
<p>Another method which is not as fast (but is certainly faster than your chosen method of copying the text into a temporary <code>pg_ref</code>) is to make a temporary highlight region for the text range, then get the enclosing bounds <code>rect</code> for the highlight. To get a highlight region, use <code>pgGetHiliteRgn</code> (you also have to know the text positions for each line). The way this function works is that you first create a shape (using <code>pgRectToShape(&amp;pgm_globals, NULL)</code>) and passing that shape to <code>pgGetHiliteRgn</code>. Then to get the &quot;bounds&quot; area of the shape, you use <code>pgShapeBounds(shape, &amp;rectangle)</code>.</p>
<h2 id='249-character-type'>24.9 Character type</h2>
<pre><code>(long) pgFindCharType (pg_ref pg, long char_info, long PG_FAR *offset, pg_char_ptr the_byte);
</code></pre>
<p>This function locates the first character in <code>pg</code> that matches <code>char_info</code>, beginning at byte offset <code>*offset</code>.</p>
<p>The <code>char_info</code> parameter should be set to one or more of the character info bits as explained for <code>char_info_proc</code>. See section 24.6, <a href='#246-information-about-a-particular-character'>Information About a Particular Character</a>.</p>
<p>For example, to search for a <code>return</code> character, you would pass <code>PAR_SEL_BIT</code> for <code>char_info</code> (which will locate a character that can break a paragraph).</p>
<p>If <code>the_byte</code> pointer is non-null, the character located, if any, gets placed into the buffer to which it points.</p>
<p><strong>CAUTION:</strong> Given that characters in HERMES Paige can be more than one byte, you <em>must</em> be sure that the character found will fit into the buffer. If you aren&#39;t sure, then pass a null pointer for <code>the_byte</code> until you get the information about the character, then make another call to get the data.</p>
<p><strong>FUNCTION RESULT:</strong> The complete character type is returned (all the appropriate <code>char_info_proc</code> bits will be set). The <code>offset</code> parameter will be updated to the byte offset for the character found. If the character in question was <em>not</em> found, this function will return <code>*offset</code> equal to the text size in <code>pg</code>.</p>
<h2 id='2410-change-counter'>24.10 Change counter</h2>
<pre><code>(long) pgGetChangeCtr (pg_ref pg);
(long) pgSetChangeCtr (pg_ref pg, long ctr);
</code></pre>
<p>HERMES Paige maintains a &quot;changes made&quot; counter which you can use to detect changes made to the object; for every change made (insertions, deletions, style changes, etc.), the change counter is incremented. Additionally, a <code>pgUndo</code> will decrement the counter.</p>
<p>This counter begins at zero when a new <code>pg_ref</code> is created; to get the counter, call <code>pgGetChangeCtr</code>. To set it, call <code>pgSetChangeCtr</code> with <code>ctr</code> as the new value.</p>
<h3 id='tech-note-when-does-change-counter-change'>TECH NOTE: When does change counter change?</h3>
<blockquote><p>I&#39;m using this counter to tell myself whether I need to resave the document. Why is the count different from what I expect?</p>
</blockquote>
<p>This counter is changed by HERMES Paige anytime <strong>it</strong> thinks it needs to be changed. It changes for <em>everything</em>. We use our own change counter in the demo to keep track of when we need to resave the document.</p>
<p>I suggest that you may want to keep your own change counter.</p>
<h2 id='2411-text-and-selection-positions'>24.11 Text and selection positions</h2>
<pre><code>(void) pgTextRect (pg_ref pg, select_pair_ptr range, pg_boolean want_scroll, pg_boolean want_scaled, rectangle_ptr rect);
(void) pgCharacterRect (pg_ref pg, long position, short want_scrolled, short want_scaled, rectangle_ptr rect);
</code></pre>
<p>These functions can be used to compute outline(s) around one or more characters.</p>
<p>For <code>pgTextRect</code>, a rectangle is returned in <code>rect</code> that exactly encloses the text range in range. If <code>want_scroll</code> is <code>TRUE</code>, the rectangle is &quot;scrolled&quot; to the location where it would appear on the screen, otherwise it remains relative to <code>pg</code>&#39;s top-left of <code>page_area</code>. If <code>want_scaled</code> is <code>TRUE</code>, the rectangle is scaled to the scale factor set in <code>pg</code>.</p>
<p>To get the rectangle surrounding a single character, call <code>pgCharacterRect</code> which does exactly the same thing as <code>pgTextRect</code>, except in that you give it a single-byte offset.</p>
<pre><code>(long) pgPtToChar (pg_ref pg, co_ordinate_ptr point, co_ordinate_ptr offset_extra);
</code></pre>
<p><strong>FUNCTION RESULT:</strong> This function returns the (byte) offset of the first character that contains point. If <code>offset_extra</code> is non-null, the point is first offset by that much before the character is located.</p>
<h2 id='2412-getting-the-maximum-text-bounds'>24.12 Getting the Maximum Text Bounds</h2>
<p>HERMES Paige computes the smallest rectangle that will fit around all text when you call:</p>
<pre><code>(void) pgMaxTextBounds (pg_ref pg, rectangle_ptr bounds, pg_boolean paginate);
</code></pre>
<p>Returns the smallest bounding rectangle pointed to in <code>bounds</code> that encloses all the text in <code>pg</code>. The <code>bounds</code> parameter must point to a rectangle and can&#39;t be a null pointer.</p>
<p>The dimensions of <code>bounds</code> essentially gets set to the top of the first line for the rectangle&#39;s top, the line furthest to the left and right for the rectangle&#39;s left and right sides, and the furthest line to the bottom for the rectangle&#39;s bottom.</p>
<p>If <code>paginate</code> is <code>TRUE</code> then HERMES Paige will repaginate the document if necessary to render the most accurate possible dimensions.</p>
<p><strong>NOTE:</strong> When paginate is <code>TRUE</code> the pagination can be slower, but if you pass <code>FALSE</code> you won&#39;t always get an accurate measurement.</p>
<p><strong>CAUTION:</strong> Paginating a large document can consume a lot of time. However, the only way HERMES Paige can possibly return exact dimensions is if every line has been calculated from top to bottom.</p>
<h3 id='how-to-call-pgmaxtextbounds'>How to call <code>pgMaxTextBounds</code></h3>
<pre><code>rectangle bounds; long doc_width;
pgMaxTextBounds(pg, &amp;bounds, TRUE);
doc_width = bounds.bot_right.h - bounds.top_left.h;
</code></pre>
<p>The <code>doc_width</code> in the above example would be the width of the <em>widest</em> text line (from the left margin to the right side of the last character).</p>
<h3 id='tech-note-expanding-the-pagearea-as-text-is-typed'>TECH NOTE: Expanding the <code>page_area</code> as text is typed</h3>
<blockquote><p>I want to set an ever-expanding <code>page_area</code> that grows as the user types, but only if I need to. How and when should I do that with <code>pgMaxTextBounds</code>?</p>
</blockquote>
<p>As for changing the page area of the <code>pg_ref</code>, yes, you should use <code>pgSetAreas</code> and/or <code>pgSetAreaBounds</code>—but only when it really changes and/or only when you physically want to expand it.</p>
<p>To answer your question as to <em>when</em> you figure out the doc width, I would not do it every key insertion (you are right, that would be <em>very</em> slow, particularly when text gets fairly large). The best way to detect the document&#39;s height has grown is to examine a field inside the <code>pg_ref</code> called <code>overflow_size</code>. This field gets set by HERMES Paige if and when one or more characters have flowed below the bottom of your page area.</p>
<p>For this feature to work, however, you need to set <code>CHECK_PAGE_OVERFLOW</code> with <code>pgSetAttributes2()</code>. By setting this attribute, HERMES Paige will check the &quot;character overflow&quot; situation after every operation that can cause text to change.</p>
<p>So after anything that might cause an overflow (which would notify the need to change the page rectangle), check <code>overflow_size</code> as follows:</p>
<pre><code>long CheckOverflow(pg_ref pg)
{
	paige_rec_ptr pg_rec;
	long overflow_amt;
	
	pg_rec = UseMemory(pg);
	overflow_amt = pg_rec -&gt; overflow_size;
	UnuseMemory(pg);
	
	return (overflow_amt);
}
</code></pre>
<p>In the above example, the function result is the number of character(s) that overflow the bottom of the page rectangle. If <code>overflow_size</code> is <code>-1</code>, the text overflows the bottom only by a single CR character (i.e. blank line).</p>
<h2 id='2413-unique-value'>24.13 Unique value</h2>
<p>This function obtains a unique ID value unique within a <code>pg_ref</code>.</p>
<pre><code>(long) pgUniqueID(pg_ref pg);
</code></pre>
<p>This simply returns a number guaranteed to be unique (&quot;unique&quot; compared to the previous response from <code>pgUniqueID</code>).</p>
<p>This function simply increments an internal counter within <code>pg</code> and returns that number, hence each response from <code>pgUniqueID</code> is &quot;unique&quot; from the last response. The very first time this function gets called after <code>pgNew</code>, the result will be <code>1</code>.</p>
<p>The intended purpose of this function is to place something in a <code>style_info</code> or <code>par_info</code> record to make it &quot;unique&quot; so it will be distinguished from all other style runs in <code>pg</code>. Other than that, this function is rarely used by an application.</p>
<p>For example, if an application applied a customised style to a group of characters, as far as HERMES Paige is concerned that style might look exactly like the style(s) surrounding those characters; since HERMES Paige will automatically delete redundant style runs, customised styles generally need to place something in one of the <code>style_info</code> fields to make it &quot;unique.&quot;</p>
<h2 id='2413-filling-a-structure'>24.13 Filling a Structure</h2>
<pre><code>#include &quot;MemMgr.h&quot;
(void) pgFillBlock (void PG_FAR *block, long block_size, pg_char value);
</code></pre>
<p><code>pgFillBlock</code> fills a memory block of <code>block_size</code> byte size with byte value in <code>pg_char</code> parameter.</p>
<h2 id='2415-splitting-a-long-byte'>24.15 Splitting a long byte</h2>
<pre><code>#include &quot;pgUtils.h&quot;
(short) pgLoWord(long value);
(short) pgHiWord(long value);
</code></pre>
<p>It is often necessary to split a <code>long</code> into two <code>short</code>s. This is a cross-platform way of doing just that. The low word returns the least significant <code>short</code>, the high word returns the most significant.</p>
<p><img src="figs/fig25.jpg" referrerpolicy="no-referrer"></p>
<h2 id='2416-maths'>24.16 Maths</h2>
<pre><code>#include &quot;pgUtils.h&quot;
(long) pgAbsoluteValue(long value);
(pg_fixed) pgRoundFixed(pg_fixed fix);
(pg_fixed) pgMultiplyFixed(pg_fixed fix1, pg_fixed fix2);
(pg_fixed) pgDivideFixed(pg_fixed fix1, pg_fixed fix2);
(pg_fixed) pgFixedRatio(short n, short d);
</code></pre>
<p><code>pgAbsoluteValue</code> — returns an absolute value.</p>
<p><code>pgRoundFixed</code> — rounds the fixed number to the nearest whole (but is still a <code>pg_fixed</code>). For example, <code>0x00018000</code> will return as <code>0x00020000</code>.</p>
<p><code>pgMultiplyFixed</code> - multiplies two fixed decimal numbers (a fixed decimal is a <code>long</code> whose high-order word is the integer and low-order word the fraction. Hence, <code>0x00018000</code> = <code>1.5</code>.</p>
<p><code>pgDivideFixed</code> — divides fixed number <code>fix1</code> into <code>fix2</code> (a fixed decimal is a long whose high-order word is the integer and low-order word the fraction. Hence, <code>0x00018000</code> = <code>1.5</code>).</p>
<p><code>pgFixedRatio</code> - returns a fixed number which is the ratio of <code>n : d</code> (a fixed decimal is a <code>long</code> whose high-order word is the integer and low-order word the fraction). Hence, 0x00018000 = 1.5.</p>
<h1 id='25-the-allocation-manager'>25 THE ALLOCATION MANAGER</h1>
<p>This section deals exclusively with the Allocation Manager within HERMES Paige (the portion of software that creates, manages and disposes memory allocations).</p>
<h2 id='251-up-and-running'>25.1 Up and Running</h2>
<p>The Allocation Manager used by HERMES Paige is full of features that have been requested by developers and used by HERMES Paige itself. All these features are available to you as a developer.</p>
<p>Like most of HERMES Paige, there are just some basics to know about the Allocation Manager to initially use it effectively.</p>
<p>These are:</p>
<ol start='' >
<li>To allocate a block of memory, you call a function that returns an &quot;ID&quot; code (not a pointer or an address).</li>
<li>Then to access that memory, you pass the &quot;ID&quot; code to a function which returns an address to that memory.</li>
<li>Once you are through accessing that memory, you report its &quot;non-use&quot; by calling another function.</li>
<li>&quot;Reporting&quot; to the allocation manager when you are accessing a memory block and when you are through makes virtual memory possible (blocks can be purged that are not in use).</li>
<li>Memory allocations do not have to be byte-oriented, rather they can be groups of logical records. For example, a memory allocation can be defined as a group of 100-byte records. </li>

</ol>
<h3 id='simple-example-to-allocate-some-memory-and-use-it'>Simple example to allocate some memory and use it:</h3>
<pre><code>	/* Allocation: */
	memory_ref allocation; 
	allocation = MemoryAlloc(&amp;mem_globals, sizeof(char), 100, 0);
	
	/* Note: &quot;mem_globals&quot; is the pgm_globals field in the HERMES Paige globals, same struct given to pglnit and pgNew. The &quot;allocation&quot; result is not an address, but an &quot;ID&quot; code. To get the address, call: */

	char *memory_address;
	memory_address = UseMemory(allocation);

	/* In the above, not only is the memory addressed returned but the memory is now locked and unpurgable. Thus it is important to &quot;report&quot; when you are through accessing it: */

	UnuseMemory(allocation);
	
	/* Tell Allocation Manager we are done. */
	
	// Once you are completely through, dispose the allocation:
	
	DisposeMemory(allocation);
</code></pre>
<h2 id='252-theory'>25.2 Theory</h2>
<p>Since HERMES Paige is intended to operate on multiple platforms, it became necessary to remove the majority of its code as far away from a specific operating system as possible.</p>
<p>An integral part of any computer OS is its memory management system. However, no two memory management designs are alike, and for this reason HERMES Paige&#39;s Allocation Manager works as follows:</p>
<ol start='' >
<li><p>HERMES Paige only creates memory allocations through high-level functions, far removed from the operating system. Among these functions are <code>MemoryAllocate</code>, <code>MemoryDuplicate</code> and <code>MemoryCopy</code>.</p>
</li>
<li><p>Regardless of platform, functions to allocate memory remain constant (the same function names and parameters are the same regardless of the OS).</p>
</li>
<li><p>To allow for virtual memory and debugging features, HERMES Paige must inform the Allocations Manager, as a rule, when it is about to access a block of memory and when it is through accessing that block. The purpose of this is threefold:</p>
<ol start='' >
<li>If no part of HERMES Paige is accessing a memory block, the Allocation Manager can &quot;unlock&quot; the block and allow it to relocate for maximum memory efficiency,</li>
<li>Blocks of memory can be temporarily purged if they are not being accessed.</li>
<li>Debugging features can be implemented: since the main software must &quot;ask&quot; for access to a block of memory, the Allocation Manager can check the validity of the block at that time (when running in &quot;debug mode&quot;).</li>

</ol>
</li>
<li><p>Since memory is never allocated directly, the Allocation Manager can provide additional features to a block of memory. Among the features that exist in HERMES Paige&#39;s Allocation Manager are logical record sizes (a block of memory can be an array of records, as opposed to bytes), nested &quot;lock memory&quot; capability (more than one function can &quot;lock&quot; a block from relocating or purging, in which case the block can not be free for relocation or purging until each &quot;lock&quot; has been &quot;unlocked&quot;).</p>
</li>

</ol>
<h2 id='253-memory-block-references'>25.3 Memory Block References</h2>
<p>As far as HERMES Paige (and your application) is concerned, when memory is allocated. the Allocation Manager does not return a memory address; rather, it returns an ID number called a <code>memory_ref</code>. You can consider a <code>memory_ref</code> as simply a long word whose value, when given later to the Allocation Manager, will identify a block of memory.</p>
<h2 id='254-access-counter'>25.4 Access Counter</h2>
<p>Frequent reference is made in this chapter to a memory reference&#39;s access counter.</p>
<p>Every block of memory created through the Allocation Manager has an associated access counter. This counter increments every time your program requests the block to become locked (non-relocatable and non-purgeable), and decrements for every request to unlock the block (making it re-locatable and purgeable). The purpose of this is to allow nested &quot;lock/unlock&quot; logic as opposed to a simple locked or unlocked state: using the access counter method, Allocation Manager will make a block relocatable or purgeable only when its access counter is zero. This provides protection against memory blocks moving &quot;out from under&quot; nested situations.</p>
<h2 id='255-logical-v-physical-sizes'>25.5 Logical v. Physical Sizes</h2>
<p>Every allocation made through the Allocation Manager is considered to have two sizes: a logical size and a physical size. (For how this is implemented, see <a href='#the-`extend_size`-parameter'>The <code>extend_size</code> parameter</a> under section 28.8).</p>
<p>The physical size of a block is the actual amount of reserved memory that has been allocated, in bytes; the logical size, however, may or may not be the same amount and in fact is often smaller.</p>
<p>The physical size of an allocation might be, for example, $10 \mathrm{~K}$ but its logical size might be as small as zero. The purpose of the two-size distinction is speed and performance. Depending on the OS, physically resizing a block of memory can consume large amounts of time, particularly in tight situations where thousands of blocks require relocation or purging just to append additional memory to one block. For this reason, the Allocation Manager may elect to allocate a block larger (physical size) than what you have asked for but &quot;tell&quot; you it is a smaller size (logical size); then if you asked for that block to be extended to a large size, the extra space might already exist, in which case the</p>
<p>Allocation Manager merely changes its logical size without any need to expand the block physically.</p>
<p>Generally, it is a block&#39;s logical—<em>not</em> physical—size that your program should always work with.</p>
<h2 id='256-purged-blocks'>25.6 Purged Blocks</h2>
<p><strong>All references in this chapter to <em>purging</em> and <em>purged blocks</em> imply virtual memory, in which a block&#39;s contents are saved to a scratch file so that the allocation can be temporarily disposed.</strong> Such allocations are not lost, rather they recover on demand by reloading from the scratch file. At no time does the Allocation Manager permanently dispose an allocation unless you explicitly tell it to do so.</p>
<h2 id='257-starting-up'>25.7 Starting Up</h2>
<p>The Allocation Manager must have already been started before <code>Y</code> was called. You need to make any function calls to initialise this portion of the software. To start HERMES Paige with the Allocation Manager and for details on <code>pgMemStartup</code>, see section 2.4, <a href='#24-software-startup'>Software Startup</a>.</p>
<p><strong>CAUTION:</strong> You must not, however, use any functions listed below unless you have called <code>pgMemStartup</code>.</p>
<p><strong>NOTE:</strong> You can theoretically use the Allocation Manager, by itself, without ever initialising HERMES Paige.</p>
<h2 id='258-allocating-and-deällocating-memory'>25.8 Allocating and Deällocating Memory</h2>
<p>To allocate memory through the Allocation Manager, call one of the following:</p>
<pre><code>(memory_ref) MemoryAlloc (pgm_globals_ptr globals, pg_short_t rec_size, long num_recs, short extend_size);
(memory_ref) MemoryAllocClear (pgm_globals_ptr globals, pg_short_t rec_size, long num_recs, short extend_size);
</code></pre>
<p><code>MemoryAlloc</code> allocates a block of memory and returns a <code>memory_ref</code> that identifies that block; <code>MemoryAllocClear</code> is identical except in that it clears the block (sets all bytes to zero).</p>
<p>By allocation is meant a block of memory of some specified byte size that becomes reserved exclusively for your use, guaranteed to remain available until you deällocate that block (using <code>DisposeMemory</code>, below).</p>
<p>Both functions return a <code>memory_ref</code>, which is a reference ID to the allocation. You should neither consider a <code>memory_ref</code> to be an address nor a pointer. Rather, give this reference to the various functions listed below to get a pointer to the memory block, change its allocation size, make it purgeable or nonpurgeable, etc.</p>
<p>The <code>memory_ref</code> returned is always non-zero if it succeeds or <code>MEM_NULL</code> (zero) if it fails. The easiest way to check for failures is by using HERMES Paige&#39;s try/catch exception handling. See section 26.1, <a href='#261-the-trycatch-mechanism'>The TRY/CATCH Mechanism</a>, and <a href='#creating-a-`memory_ref`'>Creating a <code>memory_ref</code></a> under section 26.5.</p>
<p>The <code>globals</code> parameter must point to the <code>mem_globals</code> you gave to <code>pgMemStartup</code>. Or, if you have initialised HERMES Paige with <code>pgInit()</code> you can also access <code>mem_globals</code> through the HERMES Paige globals:</p>
<pre><code>paige_globals.mem_globals;
</code></pre>
<p>The size of the allocation is determined by the formula <code>rec_size * num_recs</code>, where <code>rec_size</code> is a record size, in bytes, and <code>num_recs</code> is the number of such records in the block. Hence, you can create allocations that are considered arrays of records, if necessary.</p>
<p>For example, allocating a block of <code>rec_size = 16</code> and <code>num_recs = 100</code>, the total byte size of the allocation would be 1600. The intended purpose of allowing a record size, as opposed to always creating blocks consisting of single bytes, is to provide high-level features of accessing record elements.</p>
<p>If you only want a block of bytes, without regard to any &quot;record&quot; size, simply create an allocation with a &quot;record&quot; size of 1.</p>
<p>A <code>rec_size</code> of zero is not allowed; a <code>num_recs</code> value of zero, however, is allowed.</p>
<h3 id='the-extendsize-parameter'>The extend_size parameter</h3>
<p>The purpose of the <code>extend_size</code> parameter is to provide the Allocation Manager with some insight, for performance purposes, as to how large the allocation might grow from subsequent SetMemorySize calls.</p>
<p>To understand this fully, a distinction between a <code>memory_ref</code>&#39;s &quot;logical size&quot; versus &quot;physical size&quot; must be clarified: when a <code>memory_ref</code> is initially created, its logical size is simply the size that was asked for (which is <code>rec_size * num_recs</code>). However, the actual size allocation can be greater than the logical size, which essentially provides an extra &quot;buffer&quot; that can be utilized to change the logical size later without the necessity to physically resize the allocation through OS calls.</p>
<p>A good example of this would be the allocation of a large string whose initial byte size begins at zero, yet it is expected to grow larger in size as time goes by, perhaps as large as 500 bytes in length. If such a memory allocation started at a physical byte size of zero, then it would become necessary (and very slow) to ask the OS to physically resize the allocation each and every time new byte(s) were appended.</p>
<p>However, if such an allocation were initially created with a 500-byte <code>extend_size</code> (but a logical size of zero), it would never need to physically resize unless or until the string grew larger than 500 bytes.</p>
<p>Hence, <code>MemoryAlloc</code> could create such an allocation whereby the physical size and logical size are different:</p>
<pre><code>MemoryAlloc(&amp;mem_globals, sizeof(byte), 0, 500);
</code></pre>
<p>The <code>extend_size</code> is therefore an enhancement tool, and should be set to a reasonable amount according to what the resizing forecast holds for that allocation. If the allocation will never be resized, <code>extend_size</code> should be zero.</p>
<p><strong>NOTE:</strong> The value of <code>extend_size</code> does not necessarily imply future memory resizing will occur or will not occur, rather it is a performance variable only: the Allocation Manager will still resize a memory allocation even if <code>extend_size</code> is zero (although possibly slower than if <code>extend_size</code> were larger).</p>
<p>See also section 25.5, <a href='#255-logical-v-physical-sizes'>Logical v. Physical Sizes</a>.</p>
<p><strong>NOTE:</strong> The <code>extend_size</code> indicates a number of <em>records</em> (each of size <code>rec_size</code> bytes), not bytes.</p>
<p><img src="figs/fig26.jpg" referrerpolicy="no-referrer"></p>
<h3 id='deällocation'>Deällocation</h3>
<p>Once you no longer need a memory allocation, pass its <code>memory_ref</code> to the following:</p>
<pre><code>void DisposeMemory (memory_ref ref);
</code></pre>
<p><code>DisposeMemory</code> physically disposes the block assigned to <code>ref</code>, and <code>ref</code> is no longer a valid reference thereafter.</p>
<pre><code>(memory_ref) MemoryDuplicate (memory_ref src_ref);
(void) MemoryCopy (memory_ref src_ref, memory_ref target_ref);
</code></pre>
<p><code>MemoryDuplicate</code> returns a new <code>memory_ref</code> whose data content and record size is exactly the same as <code>src_ref</code>. In effect, this function returns a &quot;clone&quot; of <code>src_ref</code>, but it is a new, independent <code>memory_ref</code>.</p>
<p><code>MemoryCopy</code> copies the contents of <code>src_ref</code> into <code>target_ref</code>.</p>
<p><code>MemoryCopy</code> differs from <code>MemoryDuplicate</code> in that for <code>MemoryCopy</code> both <code>src_ref</code> and <code>target_ref</code> are allocations that already exist. <code>MemoryDuplicate</code> actually creates a new <code>memory_ref</code> for you, so it cannot already exist.</p>
<p>The logical size of <code>target_ref</code> can be any size, even zero, as <code>MemoryDuplicate</code> will change its size as necessary. Record sizes of each <code>memory_ref</code>, however, must match.</p>
<p>The access counters are not set, since the memory is allocated but not in use.</p>
<h3 id='tech-note-practical-difference-between-memorycopy-and-memoryduplicate'>TECH NOTE: Practical difference between <code>MemoryCopy</code> and <code>MemoryDuplicate</code> </h3>
<blockquote><p>What is the difference really between <code>MemoryCopy</code> and <code>MemoryDuplicate</code>? Please do comment on the appropriate situation for using either.</p>
</blockquote>
<p>I can clarify the difference in usage between <code>MemoryCopy</code> and <code>MemoryDuplicate</code>. It is very simple:</p>
<ul>
<li><code>MemoryDuplicate</code> is for obtaining a &quot;clone&quot; of a <code>memory_ref</code>.</li>
<li><code>MemoryCopy</code> is to <em>fill in</em> a <em>preëxisting</em> <code>memory_ref</code> with the contents of another.</li>

</ul>
<p>In my own code, I am constantly wanting to copy contents of a <code>memory_ref</code> into one that I created earlier. One example of this is some routine that wants to keep copying a bunch of different <code>memory_ref</code>s—to copy an array of &quot;tabs&quot; for instance. It would be a lot slower to create a <code>memory_ref</code> with <code>MemoryDuplicate</code>, then dispose it, then create it again, then
then keep copying different <code>memory_ref</code>s into it.</p>
<h2 id='2510-accessing-memory'>25.10 Accessing Memory</h2>
<h3 id='using-memory'>Using memory</h3>
<p>To obtain a pointer to a block of memory allocated from MemoryAlloc or <code>MemoryAllocClear</code>, call one of the following:</p>
<pre><code>(void PG_FAR*) UseMemory (memory_ref ref); 
(void PG_FAR*) UseForLongTime (memory_ref ref);
</code></pre>
<p><code>UseMemory</code> and <code>UseForLongTime</code> takes a <code>memory_ref</code> in <code>ref</code> and returns a pointer to the memory block assigned to that reference. The <code>ref</code>&#39;s access counter is incremented, which means that the memory block is now guaranteed neither to relocate nor purge (see section 25.4, <a href='#254-access-counter'>Access Counter</a>).</p>
<p>The primary purpose of <code>UseMemory</code> is to tell the Allocation Manager that a particular block of memory is now &quot;in use&quot;, in which case it is marked as unpurgeable and nonrelocatable.</p>
<p><code>UseForLongTime</code> does exactly the same thing as <code>UseMemory</code> except in that the memory block is relocated in the optimum way, before locking, to avoid memory fragmentation. The purpose of using this function, as opposed to <code>UseMemory</code>, is for situations where you know the block will stay locked for quite a while and you don&#39;t want to cause unreasonable fragments.</p>
<p><strong>NOTE:</strong> Don&#39;t use <code>UseForLongTime</code> <em>too</em> liberally because it is substantially slower than <code>UseMemory</code> (since the machine often needs to relocate the memory).</p>
<p><code>UseMemory</code> and <code>UseForLongTime</code> calls can be nested, but each must be eventually balanced with <code>UnuseMemory</code> or else the block will remain in a locked state, which in turn can cause memory difficulties such as fragmentation and the inability to change the allocation size.</p>
<p><img src="figs/fig27.jpg" referrerpolicy="no-referrer"></p>
<h3 id='unuse-memory'>Unuse memory</h3>
<p>Once you are finished using the pointer returned from <code>UseMemory</code> or <code>UseForLongTime</code>, call the following:</p>
<pre><code>(void) UnuseMemory (memory_ref ref);
</code></pre>
<p>Essentially, <code>UnuseMemory</code> decrements <code>ref</code>&#39;s access counter. If its access counter goes to zero, the allocation is then free to relocate or purge.</p>
<p>It is therefore important that all <code>UseMemory</code> and <code>UseForLongTime</code> calls get eventually <em>balanced</em> with UnuseMemory, otherwise unwanted locked memory fragments will result.</p>
<p><img src="figs/fig28.jpg" referrerpolicy="no-referrer"></p>
<h2 id='2511-random-access-pointers'>25.11 &quot;Random-Access&quot; Pointers</h2>
<p>You can obtain a pointer to a specific &quot;record&quot; within a block of memory by calling the following:</p>
<pre><code>(void PG_FAR*) UseMemoryRecord (memory_ref ref, long wanted_rec, long seq_recs_used, short first_use);
</code></pre>
<p>This function is similar to <code>UseMemory</code> except a pointer to a specified record of an allocation is returned.</p>
<p>The <code>wanted_rec</code> is the (zero-indexed) record number you need a pointer to. The record size (originally defined in <code>rec_size</code> for <code>MemoryAlloc</code>) determines which physical byte the resulting pointer will reference. For instance, if the record size were, 128 bytes, a <code>UseMemoryRecord</code> for <code>wanted_rec</code> of <code>10</code> would return a pointer to the 1280th byte.</p>
<p>The <code>seq_recs_used</code> parameter should indicate how many additional sequential records beyond <code>wanted_rec</code> record you want access to. The purpose of this parameter is for future Allocation Manager enhancements in which partial block(s) can be loaded into memory from a purged state. In such a case, <code>UseMemoryRecord</code> needs to know how many additional sequential records, besides <code>wanted_rec</code>, you would like to have loaded into memory if the allocation has been purged.</p>
<!-- TO DO: The purpose of this parameter is for future Allocation Manager enhancements in which partial block(s) can be loaded into memory from a purged state. -->
<p>For example, suppose a block of memory consisting of 1000 records is temporarily purged (which really means its contents have been saved to a &quot;scratch&quot; file and the block currently does not physically exist in memory). Full access to all records would require the Allocation Manager to load the entire allocation (all 1000 records). <code>UseMemoryRecord</code>, however, could get away with loading only a few records within that allocation, but it needs to know how many sequential records you intend to access beyond <code>wanted_rec</code>.</p>
<p>If you want to use all records following <code>wanted_rec</code>, whatever that quantity might be, you can also pass <code>USE_ALL_RECS</code> (value of <code>-1</code>) for <code>seq_recs_used</code>.</p>
<p>If <code>first_use</code> is <code>TRUE</code>, the block&#39;s access counter is incremented (same thing as results from a <code>UseMemory</code> call); if <code>first_use</code> is <code>FALSE</code>, the access counter remains unchanged. The purpose of this parameter is for situations where you intend to randomly access many records from the same <code>memory_ref</code> within the same routine, but you essentially need only one UseMemory to lock the allocation; otherwise, you would need to balance every random access with <code>UnuseMemory</code>.</p>
<p>Thus, setting <code>first_use</code> to <code>TRUE</code> is essentially sending the Allocation Manager the message, &quot;Please lock the allocation,&quot; then subsequent <code>UseMemoryRecord</code> calls with <code>first_use</code> as <code>FALSE</code> is like saying, &quot;I know the allocation is already locked, so just give me another pointer.&quot;</p>
<p>An <code>UnuseMemory</code> call must eventually balance each <code>UseMemoryRecord</code> call that gave TRUE for <code>first_use</code>.</p>
<p><strong>NOTE:</strong> HERMES Paige loads the whole allocation specified in <code>UseMemoryRecord</code> (does not do partial loads). However, to guarantee future compatibility, you should assume that all records in the allocation lower than <code>wanted_rec</code> and all records greater than <code>wanted_rec + seq_recs_used</code> are purged, not loaded, and therefore not valid should you attempt to access them with the same pointer.</p>
<h2 id='2512-quick-record'>25.12 &quot;Quick Record&quot;</h2>
<p>If you simply want a copy of a single record from an allocation, call the following:</p>
<pre><code>void GetMemoryRecord (memory_ref ref, long wanted_rec, void PG_FAR *record);
</code></pre>
<p>Record number <code>wanted_rec</code> (zero-indexed) in <code>ref</code> is copied to the structure pointed to by record. The access counter in <code>ref</code> is unchanged. Hence, <code>GetMemoryRecord</code> provides a way to get a single record without the need to balance <code>UseMemory</code> and <code>UnuseMemory</code>.</p>
<p>It is your responsibility to make sure <code>record</code> is sufficient size to hold a record from <code>ref</code>.</p>
<p><strong>NOTE:</strong> <code>GetMemoryRecord</code> will work correctly regardless of the <code>memory_ref</code>&#39;s access counter state and regardless of whether or not the allocation has been purged.</p>
<h2 id='2513-changing-allocation-sizes'>25.13 Changing Allocation Sizes</h2>
<h3 id='memory-sizes'>Memory sizes</h3>
<pre><code>(void) SetMemorySize (memory_ref ref, long wanted_size);
(long) GetMemorySize (memory_ref ref);
</code></pre>
<p><code>SetMemorySize</code> changes the logical size of <code>ref</code> to <code>wanted_size</code>. <code>GetMemorySize</code> returns the logical size of <code>ref</code>.</p>
<p>For both functions, the &quot;size&quot; is not a byte size, but rather a record quantity. A <code>SetMemorySize(ref, 10)</code> for an allocation whose record size is 500 bytes, the allocation is set to 5000 bytes, i.e. <code>10 * 50</code>; <code>SetMemorySize(ref, 10)</code> for a 1-byte record size allocation would result in a logical byte size of <code>10</code>, and so on.</p>
<p>If <code>SetMemorySize</code> fails for any reason, an HERMES Paige exception is raised (see chapter 26, <a href='#26-exception-handling'>Exception Handling</a>).</p>
<p><code>GetMemorySize</code> returns the current size of (i.e., number of records within) <code>ref</code>.</p>
<p><strong>Changing the size of an allocation whose access counter is non-zero might fail!</strong> (A non-zero access counter means sufficient <code>UnuseMemory</code> calls have not been made to balance <code>UseMemory</code> calls, resulting in a locked allocation).</p>
<p><strong>NOTE:</strong> <code>GetMemorySize</code> will work correctly regardless of the <code>memory_ref</code>&#39;s access counter state and regardless of whether or not the allocation has been purged.</p>
<h3 id='record-size-byte-size'>Record size, byte size</h3>
<pre><code>(short) GetMemoryRecSize (memory_ref ref);
(long) GetByteSize (memory_ref ref);
</code></pre>
<p><code>GetMemoryRecSize</code> returns the record size in <code>ref</code> (which will be whatever size you gave <code>MemoryAlloc</code> or <code>MemoryAllocClear</code> when the allocation was made). This function is useful for generic functions that need to know a <code>memory_ref</code>&#39;s record size.</p>
<p><code>GetByteSize</code> returns the byte size of <code>ref</code> (as opposed to the number of records as in <code>GetMemorySize</code>). Essentially a <code>memory_ref</code>&#39;s byte size is its record size times number of logical records.</p>
<p><strong>NOTE:</strong> Both functions above will work correctly regardless of the <code>memory_ref</code>&#39;s access counter state and regardless of whether or not the allocation has been purged.</p>
<h3 id='tech-note-a-bigger-or-smaller-record-size'>TECH NOTE: A bigger or smaller record size</h3>
<blockquote><p>Can I make my record size bigger after it is allocated?</p>
</blockquote>
<p>No. You can only change the number of records. You can create a new <code>memory_ref</code> and copy the old data into the new one using <code>pgBlockMove</code>.</p>
<h2 id='2514-insert--delete'>25.14 Insert &amp; Delete</h2>
<pre><code>(void PG_FAR*) InsertMemory (memory_ref ref, long offset, long insert_size);
(void PG_FAR*) AppendMemory (memory_ref ref, long append_size, pg_boolean zero_fill);
</code></pre>
<ul>
<li><code>InsertMemory</code> — inserts <code>insert_size</code> records into <code>ref</code>&#39;s allocation at record position <code>offset</code>, then returns a pointer to the first record inserted. The new record(s) are not initialised to anything—the allocation size is simply increased by <code>insert_size</code> and one or more record(s) is moved to make room for the insertion.</li>
<li><code>AppendMemory</code> — does the same thing except the &quot;insertion&quot; is added to the end of the memory block: the allocation is increased by <code>append_size</code> and a pointer to the first record of the appendage is returned. If <code>zero_fill</code> is <code>TRUE</code>, the appended memory is cleared to zeros.</li>

</ul>
<p>Both <code>InsertMemory</code> and <code>AppendMemory</code> assume record quantities, not byte sizes (i.e., <code>InsertMemory</code> for a ref whose record size is 100 will insert 200 bytes if <code>insert_size = 2</code>).</p>
<p>For both functions, the access counter in <code>ref</code> is incremented (or not) according to the following rules:</p>
<ul>
<li>if <code>ref</code>&#39;s access counter is zero upon entry, the requested memory is inserted, the access counter is incremented by 1, and the allocation is set to its &quot;used&quot; state (locked, unpurgeable);</li>
<li>if the access counter is 1 upon entry, it is decremented to zero and unlocked, the requested memory is inserted, then the access counter is incremented and the allocation is set to its &quot;used&quot; state;</li>
<li>if the access counter is greater than 1, nothing occurs and the situation is considered illegal, generating an error if debugging has been enabled (see section 25.18, <a href='#2518-debug-mode'>Debug Mode</a>).</li>

</ul>
<p>The reasoning behind these rules for the access counter when inserting memory is the common situation wherein multiple insertions need to occur within a loop. Since <code>InsertMemory</code> and <code>AppendMemory</code> allow an access counter of 1, each repetitive insertion can avoid the requirement of calling <code>UnuseMemory</code>.</p>
<p><strong>CAUTION:</strong> For insertions with an access counter of 1, the pointer you had prior to <code>InsertMemory</code> or <code>AppendMemory</code> might be invalid after memory has been inserted (the block might relocate). Therefore, always update your pointer with whatever is obtained from the function result.</p>
<h3 id='tech-note-unusememory-after-insertmemory-or-appendmemory'>TECH NOTE: <code>UnuseMemory</code> after <code>InsertMemory</code> or <code>AppendMemory</code></h3>
<blockquote><p>So do I need to do a <code>UnuseMemory</code> after these?</p>
</blockquote>
<p><code>InsertMemory</code> and <code>AppendMemory</code> really are the same as <code>SetMemorySize</code> to a larger number of records, then a (single) <code>UseMemory</code>. So you need to do a single <code>UnuseMemory()</code> after a series of repetitive inserts. In other words, if you called <code>InsertMemory()</code> or <code>AppendMemory()</code> 100 times, you only need to do <em>one</em> <code>UnuseMemory()</code>.</p>
<pre><code>struct my_special_struct
{
	short index_number;
}
for (i = 0, i &lt; 100, i++)
{
	my_new_record = InsertMemory(the_ref, i, sizeof(my_special_struct));
	my_new_record.index_number = i;
}
UnuseMemory(the_ref);
</code></pre>
<h3 id='delete'>Delete</h3>
<pre><code>(void) DeleteMemory (memory_ref ref, long offset, long delete_size);
</code></pre>
<p><code>DeleteMemory</code> deletes <code>delete_size</code> records in <code>ref</code> beginning at <code>offset</code>. Both <code>delete_size</code> and <code>offset</code> are record quantities, not bytes.</p>
<p>The access counter is not changed by this function. However, the access counter must be zero when this function is called.</p>
<h2 id='2515-purging-utilities'>25.15 Purging Utilities</h2>
<p><strong>NOTE:</strong> All references in the Chapter to &quot;purging&quot; and &quot;purged blocks&quot; imply virtual memory, in which a block&#39;s contents are saved to a scratch file so that the allocation can be temporarily disposed. If the scratch file was not set up when the Allocation Manager was initialised, there will be no purging.</p>
<p><strong>NOTE:</strong> The topic covered herein is not to be confused with &quot;purging&quot; resources on the Mac. Allocation Manager knows nothing about the Mac other than basic things about the file system. It handles its own &quot;purging&quot; without the Resource Manager.</p>
<p>An allocation is said to be &quot;purged&quot; when additional memory space needs to be freed, thus an allocation is saved to a &quot;scratch&quot; file and it is temporarily disposed.</p>
<h3 id='purge-priorities'>Purge priorities</h3>
<p>The priority for purging, i.e., what <code>memory_ref</code>s should get purged first, can be controlled by calling the following:</p>
<pre><code>(void) SetMemoryPurge (memory_ref ref, short purge_priority, pg_boolean no_data_save);
</code></pre>
<p>The <code>ref</code> allocation&#39;s purging priority is set to <code>purge_priority</code>. The <code>purge_priority</code> can be any number between 0 and 255, with 0 as the lowest priority (will get purged first above all others). The <code>purge_priority</code> parameter can also be <code>NO_PURGING_STATUS</code> (<code>OXFF</code>), in which case it will never be purged.</p>
<p>If <code>no_data_save</code> is <code>TRUE</code>, the contents of <code>ref</code> do not need to be saved to a scratch file when purged. Another way to state this is a <code>ref</code> with TRUE for <code>no_data_save</code> is known to have nothing in its contents of any value or consequence; thus, Allocation Manager can simply purge it without saving any of its contents.</p>
<p>An example of a <code>memory_ref</code> that could be set for <code>no_data_save</code> would be an &quot;offscreen bitmap&quot; buffer. After it is used to transfer an image, an application might not care if all its contents get temporarily disposed, because on the next usage whole new contents (new bits) will be created all over again anyway.</p>
<h5 id='notes-27'>Notes</h5>
<ol start='' >
<li>This function will still work regardless of <code>ref</code>&#39;s access counter state and regardless of whether or not it is purged.</li>
<li>A <code>memory_ref</code> whose access counter is nonzero will not be purged, even if its purge priority is zero.</li>
<li>Setting <code>NO_PURGING_STATUS</code> on a <code>memory_ref</code> that has already been purged will not take effect until it is unpurged. In other words, changing purge status does not automatically reload purged allocations—you still need to access its pointer (such as <code>UseMemory</code>) if you want its contents loaded into memory.</li>

</ol>
<h3 id='purging-memory'>Purging memory</h3>
<pre><code>(pg_error) MemoryPurge (pgm_globals_ptr globals, long minimum_amount, memory_ref mask_ref);
</code></pre>
<p><code>MemoryPurge</code> will purge <code>memory_ref</code>(s) until at least <code>minimum_amount</code> of memory (in bytes) has become available.</p>
<p>The <code>globals</code> parameter must be a pointer to the same structure given to <code>MemoryAlloc</code> (which is also the <code>mem_globals</code> field within the structure given to <code>pgInit</code>).</p>
<p>If <code>mask_ref</code> is non-null, that <code>memory_ref</code> is considered &quot;masked&quot; (protected) and will not be purged during this process.</p>
<p>All purgeable, unlocked allocations will be purged, one at a time and in the purge priority they are set for (lowest purge priorities are taken first) until <code>minimum_amount</code> of available space has been achieved.</p>
<p>If <code>minimum_amount</code> fails to become available, even after purging every eligible allocation, <code>MemoryPurge</code> will return an error (see chapter 39, <a href='#39-error-codes'>Error Codes</a>); if successful, the function result will be <code>NO_ERROR</code> (<code>0</code>).</p>
<p>The <code>minimum_amount</code> specified is for the total memory available, which means if there is already enough or nearly as much available as <code>minimum_amount</code>, very little will get purged.</p>
<h5 id='notes-28'>Notes</h5>
<ol start='' >
<li>The amount of &quot;available memory&quot; is based on what was given to <code>pgInit</code> for <code>max_memory</code> minus the total physical sizes of all existing <code>memory_ref</code>s—see <code>pgInit</code>.</li>
<li>You normally do not need to call this function since <code>MemoryPurge</code> gets called for you as required for allocations and resizing blocks. The function has been provided mainly for freeing memory for objects that you are not allocating with the HERMES Paige Allocation Manager.</li>
<li>Even though this function might return no error (success), that still does not necessarily guarantee a block of <code>minimum_amount</code> can be allocated, because the available memory might not be contiguous.</li>

</ol>
<h2 id='2516-allocation-manager-shutdown'>25.16 Allocation Manager Shutdown</h2>
<pre><code>(void) pgMemShutdown (pgm_globals_ptr mem_globals);
</code></pre>
<p>Call this function once you are through using the Allocation Manager. Be sure it is called after <code>pgShutdown</code>.</p>
<p><strong>NOTE:</strong> This function is not necessary if you will be doing <code>ExitToShell()</code> on <em>Macintosh</em>.</p>
<p>See section 2.5, <a href='#25-hermes-paige-shutdown'>HERMES Paige Shutdown</a>.</p>
<h2 id='2517-miscellaneous-memory-functions'>25.17 Miscellaneous Memory Functions</h2>
<h3 id='unuse--dispose'>Unuse &amp; dispose</h3>
<pre><code>(void) UnuseAndDispose (memory_ref ref);
</code></pre>
<p><code>UnuseAndDispose</code> decrements the access counter in <code>ref</code>, then disposes the allocation. This function does exactly the same thing as:</p>
<pre><code>UnuseMemory(ref);
DisposeMemory(ref);
</code></pre>
<h3 id='memory-globals'>Memory globals</h3>
<pre><code>(pgm_globals_ptr) GetGlobalsFromRef (memory_ref ref);
</code></pre>
<p><code>GetGlobalsFromRef</code> returns a pointer to <code>pgm_globals</code> located from an existing <code>memory_ref</code>. This function is useful for situations where you do not have access to the <code>globals</code> structure. Any valid, non-disposed <code>memory_ref</code>, locked or unlocked, purged or not, can be used for <code>ref</code>. For more information on getting <code>pgm_globals_ptr</code> see technical note, <a href='#Tech-note:-Get-globals-from-`pg_ref`,-`paige_rec_ptr`,-etc.'>Get globals from <code>pg_ref</code>, <code>paige_rec_ptr</code>, etc.</a>.</p>
<pre><code>#include &quot;pgTraps.h&quot;
(memory_ref) HandleToMemory (pgm_globals *mem_globals, Handle h, pg_short_t rec_size);
(Handle) MemoryToHandle (memory_ref ref);
</code></pre>
<p><code>HandleToMemory</code> accepts <code>Handle</code> <code>h</code> and returns a <code>memory_ref</code> for that <code>Handle</code>.</p>
<p><strong>FUNCTION RESULT:</strong> After this function is called, the <code>Handle</code> is now &quot;owned&quot; by the Allocation Manager, which is to say you should no longer access nor dispose that <code>Handle</code>. Access to the <code>Handle</code>&#39;s contents must thenceforth be made using the functions given above (<code>UseMemory</code>, <code>UseMemoryRecord</code>, etc.).</p>
<p>The <code>mem_globals</code> parameter must point to the same structure as given to <code>MemoryAlloc</code>.</p>
<p>The <code>rec_size</code> must contain the record size for the new <code>memory_ref</code>, which must be an even multiple of the original <code>Handle</code>. If unknown, then make <code>rec_size = 1</code>.</p>
<p>It does not matter if <code>Handle</code> <code>h</code> is locked or unlocked, but it should at least temporarily be unpurgeable.</p>
<p><code>MemoryToHandle</code> performs the reverse: it returns a <code>Handle</code> built from <code>memory_ref</code> <code>ref</code>. Again, once this call is made, <code>ref</code> is no longer valid and must not be given to any Allocation Manager functions.</p>
<p><strong>NOTE</strong>: The term <code>Handle</code> is <code>typedef</code>ed from the Windows <code>HANDLE</code>, so the two terms are synonymous.</p>
<p><strong>NOTE:</strong> These functions do not perform huge copies. Rather, they convert <code>Handles</code> to <code>memory_ref</code>s and <em>vice versa</em> by appending some special information before and after the data contents, or removing this appendage. So it is generally safe to do <code>HandleToMemory</code>, <code>MemoryToHandle</code> under fairly tight situations that could not withstand the doubling of a <code>Handle</code>&#39;s size.</p>
<h2 id='2518-debug-mode'>25.18 Debug Mode</h2>
<p>There are two compiled versions of HERMES Paige software, one for &quot;debug mode&quot; and one or &quot;non-debug&quot; or runtime mode.</p>
<p>In debug mode, <code>memory_ref</code>s are checked for validity, including the verification of appropriate access counters, each time they are given to one of the functions listed above. While this significantly reduces the speed of execution, it does aid substantially in locating bugs that would otherwise crash your system.</p>
<p>For example, calling <code>SetMemorySize</code> for an allocation that is currently &quot;in use&quot; (access counter nonzero) could fail and/or crash your program. Under debug mode, however, you would be warned immediately if an attempt to change the size of an allocation was made on a locked block.</p>
<h3 id='object-code-users-macintosh'>Object Code Users (Macintosh)</h3>
<p>There are two sets of Macintosh (or Power Mac) object code libraries: one for &quot;debug&quot; and the other for &quot;non-debug.&quot; As a general rule, you should use the debug versions to develop your application, then switch to non-debug before release (non-debug runs much faster).</p>
<p><strong>NOTE:</strong> Object code for &quot;debug&quot; mode is not supported on <em>Windows</em>. This is because Windows General Protection Mode can be used instead and is generally superior.</p>
<h3 id='source-code-users'>Source Code Users</h3>
<p>Debug/non-debug is controlled by the following <code>#ifdef</code> in <code>CPUDefs.h</code>:</p>
<pre><code>#define PG_DEBUG
</code></pre>
<p>If that <code>#define</code> exists, the source files are compiled in &quot;debug&quot; mode.</p>
<p>To run HERMES Paige debug libraries, you must include <code>pgDebug.c</code> in your project. When doing so, you can place a source-level debugger break at the location shown below; when the Allocation Manager detects a problem, the code will break at this spot.</p>
<pre><code>char pgSourceDebugBreak(memory_ref offending_ref, char *debug_str)
{
	mem_rec PG_FAR *bad_mem_rec;	// This gets coerced to examine it
	char *examine;
}

/* ****** DEBUG BREAK - MEMORY ERROR! ****** */

examine = debug_str;				// &lt;~~ Place debugger break here!
bad_mem_rec = (mem_rec PG_FAR*) pgMemoryPtr(offending_ref);
pgFreePtr(offending_ref);

/* ****** DEBUG BREAK - MEMORY ERROR! ****** */
</code></pre>
<p><strong>NOTE:</strong> The error message string is a pascal string.</p>
<h3 id='debug-assert-messages'>Debug Assert Messages</h3>
<p>The debugger <code>assert</code> is simply a debugger break with one of the following messages:</p>
<ul>
<li><p><code>Out of memory</code> — Block of requested size cannot be allocated (or block cannot be resized). If virtual memory has been enabled, this will only happen if the block is so huge there is insufficient, contiguous memory available.</p>
</li>
<li><p><code>Purge file not open</code> — Memory needs to be purged but &quot;scratch&quot; file doesn&#39;t exist or is closed.</p>
</li>
<li><p><code>Attempt to resize locked memory</code> — Allocation is locked, yet a <code>SetMemorySize</code> has been attempted.</p>
</li>
<li><p><code>NIL memory_ref</code> — <code>memory_ref</code> is a null pointer and/or an address inside of it is null.</p>
</li>
<li><p><code>Bogus memory_ref address</code> — An address in a <code>memory_ref</code> is bad (would result in a bus error for Mac).</p>
</li>
<li><p><code>Internal damage in memory_ref</code> — <code>memory_ref</code>&#39;s address OK but certain characteristics are missing (so it is assumed “damaged&quot; or overwritten).</p>
</li>
<li><p><code>Overwrite error</code> — last 1 of 4 bytes beyond the logical size of a <code>memory_ref</code> has been overwritten.</p>
</li>
<li><p><code>Access counter invalid for operation</code> — access counter is illegal for given function. Examples: </p>
<ul>
<li><code>SetMemorySize</code> and <code>access != 0</code> (illegal); </li>
<li><code>UnuseMemory</code> and access counter <code>== 0</code> (illegal); </li>
<li><code>DisposeMemory</code> and access counter <code>!= 0</code> (illegal).</li>

</ul>
</li>
<li><p><code>Bogus memory_ref</code> — <code>memory_ref</code> given is not a <code>memory_ref</code> but some other address.</p>
</li>
<li><p><code>Operation on disposed memory_ref</code> — <code>memory_ref</code> given has been disposed.</p>
</li>
<li><p><code>Error in purging</code> — An allocation was writing to a scratch file and I/O error resulted (such as out of space).</p>
</li>
<li><p><code>Error in un-purging</code> — Read error occurred while recovering a purged allocation from scratch file.</p>
</li>
<li><p><code>Attempt to access record out of range</code> — <code>UseMemoryRecord</code> asking for a record beyond the size of the allocation.</p>
</li>
<li><p><code>Structure integrity failed</code> — Structural damage has occurred to the <code>style_info</code> or <code>par_info</code> run. For example, a style run might (incorrectly) reference a style_info that does not exist.</p>
</li>

</ul>
<h2 id='2519-writing-your-own-purge-function'>25.19 Writing Your Own Purge Function</h2>
<p>The standard purge function is a built-in part of the Allocation Manager that purges (disposes) memory that is not being used to make room for new allocations. The blocks to be purged are saved to a &quot;temp&quot; file so they can be resurrected later when asked to be used by HERMES Paige or by the application.</p>
<p>If necessary, you can replace the standard purge function with one of your own. To do so, first declare a function as follows:</p>
<pre><code>PG_FN_PASCAL pg_error my_purge_proc (memory_ref ref_to_purge, pgm_globals_ptr mem_globals, short verb);
</code></pre>
<p>In the <code>pgm_globals</code> structure (same one passed to <code>MemoryAlloc</code>), the <code>purge</code> field contains a pointer to the purge function. What you need to do is place a pointer to your purge function, as defined above, into that field:</p>
<pre><code>paige_rsrv.mem_globals.purge = my_purge_proc;
</code></pre>
<p>The <code>paige_rsrv</code> variable is the same structure given to <code>pgInit</code>, and <code>mem_globals</code> is the Allocation Manager subset (same one given to <code>MemoryAlloc</code>).</p>
<p>When the Allocation Manager purges memory, it locates memory <code>ref</code>s that are purgeable and passes each of them, one at a time, to the purge function; additionally, when a <code>memory_ref</code> needs to be reloaded (unpurged), the purge function is called again to unpurge the data. The standard purge function handles this by saving the contents of the <code>memory_ref</code> to a temporary file, then setting the <code>ref</code>&#39;s byte size to <code>sizeof(mem_rec)</code>; then when unpurging, the allocation is resized to the original size and data is read from the temp file.</p>
<p>The temporary file reference used by the standard purge function is stored in the <code>purge_ref_con</code> field in <code>pgm_globals</code> (see <a href='#memory-globals'>Memory globals</a> under section 25.17).</p>
<p>In addition to purging and unpurging, the purge function is also called to initialise &quot;virtual memory&quot; and to completely dispose an allocation that is currently purged.</p>
<p>Whether the purge function is getting called to purge, unpurge, initialise or dispose an allocation depends on the verb parameter, which will be one of the following:</p>
<pre><code>typedef enum
{
	purge_init,		// Initialise VM
	purge_memory,		// Purge the reference
	unpurge_memory,	// Unpurge the reference
	dispose_purge		// Purged ref will be disposed
};
</code></pre>
<p>For each <code>verb</code>, the purge function must perform the following:</p>
<ul>
<li><code>purge_init</code> — &quot;Virtual Memory&quot; must be set up. When <code>purge_init</code> is the reason for the function call, <code>ref_to_purge</code> will be <code>NULL</code>. The standard function initialises the temporary file (whose file reference will already be contained in <code>mem_globals &gt; purge_ref_con</code>).</li>
<li><code>purge_memory</code> — The <code>ref_to_purge</code> memory must be purged. The Allocation Manager will only call with <code>purge_memory</code> if the reference is not yet purged; <em>i.e.</em>, it won&#39;t try to purge the same reference twice. The standard purge function saves <code>ref_to_purge</code>&#39;s data to the temporary file and sets the physical allocation size to <code>sizeof(mem_rec)</code>.</li>
<li><code>unpurge_memory</code> — The <code>ref_to_purge</code> memory must be unpurged. The Allocation Manager will only call with <code>unpurge_memory</code> if the reference has been purged; <em>i.e.</em>, it won&#39;t try to unpurge the same reference twice. The standard purge function resets the physical size of <code>ref_to_purge</code> and loads the data from the temporary file.</li>
<li><code>dispose_purge</code> — The <code>ref_to_purge</code> is already purged but is about to be disposed. <em>The purge function does not dispose the memory</em>; rather, it does whatever is necessary knowing that the purged allocation will be disposed forever. The standard purge function &quot;deletes&quot; the saved data on the temp file, and does nothing else.</li>

</ul>
<p><strong>FUNCTION RESULT:</strong> The purge function should return <code>NO_ERROR</code> (zero) if all was successful; otherwise it should return the appropriate error code per <code>pgErrors.h</code>.</p>
<h3 id='memory-globals-2'>Memory Globals</h3>
<p>The following structure is used by the Allocation Manager (and is also a subset of <code>pg_globals</code>):</p>
<pre><code>struct pgm_globals 
{
short				signature;		/* Used for checking/debugging */
pg_short_t			debug_flags;	/* Debug mode, if any */
pg_handle			master_handle;	/* HANDLE for master list (Windows only) */
pg_handle			spare_tire;		/* Used to free up some memory in tight situations */
master_list_ptr		master_list;	/* Contains list of all active memory_refs */
size_t				next_master;	/* Next available space in master_list */
size_t				total_unpurged;	/* Total # of bytes allocated not purged */
size_t				max_memory;		/* Maximum memory (set by app) */
size_t				purge_threshold; /* Amount extra to purge */
void PG_FAR			*machine_var;	/* Machine-specific generic ptr */
mem_debug_proc		debug_proc;		/* Called when a bug is detected */
purge_proc			purge;			/* Called to purge/unpurge memory */
free_memory_proc	free_memory;	/* Called to free up miscellaneous memory */
long				purge_ref_con;	/* Reference for purge proc */
memory_ref			purge_info;		/* Machine-based purge information */
memory_ref			freemem_info;	/* List of pg_ref(s) for cache feature (2.0) */
long				next_mem_id;	/* Used for unique ID&#39;s assigned to refs */
long				current_id;		/* ID to use for MemoryAlloc&#39;s */
long				active_id;		/* Which ID to suppress, if any, for purging */
long				last_message;	/* Last message in exception handling */
pg_fail_info_ptr	top_fail_info;	/* Current exception in linked list */
void PG_FAR *		last_ref;		/* Last reference - used by external failure 
									   processing TRS/OITC */
pg_error_handler	last_handler;	/* Last app handler before Paige */
pg_error			last_error;		/* Last reported error */
					#ifdef PG_DEBUG
memory_ref			debug_check;	/* Used for special-case debugging */
memory_ref			dispose_check;	/* Used for special-case debugging on DisposeMemory */
short				debug_access;	/* Used with above field */
					#endif
void PG_FAR			*app_globals;	/* Ptr to globals for PAIGE, etc. */
long				creator;		/* For Mac file I/O */
long				fileType;		/* For Mac file I/O */
};
</code></pre>
<p>For more information on <code>pg_globals</code>, see section 3.8, <a href='#38-changing-globals'>Changing Globals</a>. For more information on error codes, see chapter 39, <a href='#39-error-codes'>Error Codes</a>.</p>
<h1 id='26-exception-handling'>26 EXCEPTION HANDLING</h1>
<h2 id='261-the-trycatch-mechanism'>26.1 The TRY/CATCH Mechanism</h2>
<p>HERMES Paige provides a fairly straightforward method of detecting runtime errors (such as disk I/O errors, memory errors, etc.) without the requirement of checking every function result or excessive code.</p>
<p>This is accomplished by using a set of predefined macros: <code>PG_TRY</code>, <code>PG_CATCH</code>, and <code>PG_ENDTRY</code>.</p>
<p>Although this mechanism is patterned after exception handling in C++, you do not need to be using C++ to utilise HERMES Paige error detection features (nor are any C++ &quot;header&quot; files or libraries required).</p>
<p>Anywhere in your application that calls an HERMES Paige function that can fail for &quot;legitimate&quot; reasons, such as allocating memory or reading/writing files, you simply bracket your code as follows:</p>
<pre><code>PG_TRY (&amp;mem_rsrv)
{
	/* ... make calls to HERMES Paige functions here such as allocating memory, or pgNew, or pgCopy, etc -- anything that can abort from an error. */
}

PG_CATCH
{
	/* ... if any error causes HERMES Paige to abort a function, this part of your code is executed; otherwise this part is not executed. Hence you would do whatever is appropriate here such as an error alert to user. */
}

PG_ENDTRY;
{
	/* ... code is executed here if no error; also it is executed here if the code under PG_CATCH does nothing to abort the program any further. */
}
</code></pre>
<p>The above example shows the simplest form of error detection: none of the code under <code>PG_TRY</code> is necessarily required to check for errors at all since anything fatal within HERMES Paige (such as out of memory or a disk error) will throw CPU execution into the first line of code under <code>PG_CATCH</code>. This is done automatically.</p>
<p>The parameter <code>mem_rsrv</code> after <code>PG_TRY</code> must be a pointer to the global structure given to <code>pgMemStartup</code> earlier (see &quot;Software Startup&quot;<!-- on page 2-10--> for information about <code>pgMemStartup</code>).</p>
<p><strong>NOTE:</strong> <code>PG_TRY</code>, <code>PG_CATCH</code>, and <code>PG_ENDTRY</code> macros are automatically available by including <code>Paige.h</code> (the actual definitions for these exist in <code>pgExceps.h</code> which is <code>#include</code>d in <code>Paige.h</code>).</p>
<h2 id='262-last-error'>26.2 Last Error</h2>
<p>If your code executes under <code>PG_CATCH</code> that means HERMES Paige aborted something due to a fatal error. You can learn what the error code was by examining the memory globals (same structure given to <code>PG_TRY</code>) as follows:</p>
<pre><code>mem_rsrv.last_error;
</code></pre>
<h2 id='263-nested-trycatch'>26.3 Nested TRY/CATCH</h2>
<p><code>PG_TRY</code>, <code>PG_CATCH</code>, and <code>PG_ENDTRY</code> can be &quot;nested&quot; throughout your application, in as many places as required. What literally occurs is that the CPU gets forced to the <code>PG_CATCH</code> that corresponds to the most recent <code>PG_TRY</code>; then if the code under <code>PG_CATCH</code> decides to abort that section of code, it can force an additional exception using <code>pgFailure</code> (given below), in which case the next most recent <code>PG_CATCH</code> (from some other place in your program, if any) gets executed. In short, <code>TRY</code> and <code>CATCH</code> can be effectively &quot;daisy chained&quot; in this fashion so any fatal error can cycle up through any level of nested subroutines - pall without the need to even check for errors!</p>
<h2 id='264-refinements'>26.4 Refinements</h2>
<p>There are many situations where your code might need to &quot;force&quot; an exception after detecting additional errors while executing code between <code>PG_TRY</code> and <code>PG_CATCH</code>. There are also many situations where your <code>PG_CATCH</code> code needs to abort the entire
subroutine, returning control to some other part of the program. The following functions are available for this purpose:</p>
<pre><code>(void) pgFailure (pgm_globals_ptr globals, pg_error error, long message);
</code></pre>
<p>This function forces unconditional execution to the code under <code>PG_CATCH</code> that belongs to the most recent <code>PG_TRY</code>. For example, if you use <code>pgFailure</code> while executing the code under <code>PG_TRY</code>, then the first line under <code>PG_CATCH</code> in that section will get executed; if you use <code>pgFailure</code> under <code>PG_CATCH</code>, then the first line under <code>PG_CATCH</code> belonging to the previous <code>PG_TRY</code> (somewhere higher up in your program) gets executed. You would most often use pgFailure when executing <code>PG_CATCH</code> to completely abort an operation.</p>
<p>The <code>globals</code> parameter must be a pointer to <code>pgm_globals</code> (same structure given in <code>pgMemStartup</code>). The error and message parameters are stored in <code>globals -&gt; last_error</code> and <code>globals -&gt; last_message</code>, respectively, and can be any value(s) appropriate.</p>
<pre><code>(void) pgFailNIL (pgm_globals_ptr globals, void PG_FAR *allocation);
</code></pre>
<p>This function can be used to force an exception if allocation parameter is a null pointer. The globals parameter must be a pointer to pgm_globals (same structure given in pgMemStartup).</p>
<p>What actually occurs when <code>pgFailNIL</code> is called is the following:
	</p>
<pre><code>if (!allocation)
	pgFailure(globals, NO_MEMORY_ERR, 0);
	
#include &quot;pgSetJmp.h&quot;	// which is included in Paige.h

(void) pgFailError(pgm_globals_ptr globals, pg_error error);
</code></pre>
<p>This function can be used to force an exception if <code>error</code> parameter is non-zero. The <code>globals</code> parameter must be a pointer to <code>pgm_globals</code> (same structure given in <code>pgMemStartup</code>).</p>
<p>What actually occurs when <code>pgFailError</code> is called is the following:</p>
<pre><code>if (error)
	pgFailure(globals, error, 0);
		
#include &quot;pgSetJmp.h&quot;	// which is included in Paige.h

(void) pgFailError(pgm_globals_ptr globals, pg_error acceptable_error, pg_error actual_error);
</code></pre>
<p>This function can be used to force an exception if <code>actual_error</code> parameter is non-zero and it does not equal <code>acceptable_error</code>. The <code>globals</code> parameter must be a pointer to <code>pgm_globals</code> (same structure given in <code>pgMemStartup</code>).</p>
<p>A typical use of this function is to force an exception for file I/O errors unless the error is nonfatal. For example, there might be some code that keeps reading a data file until <code>end-of-file</code> error occurs. In such a case, you would want to abort if an error was detected other than <code>end-of-file</code> error.</p>
<p>What actually occurs when <code>pgFailNotError</code> is called is the following:</p>
<pre><code>if (error)
	if (actual_error != acceptable_error)
		pgFailure(globals, actual_error, 0);
		
#include &quot;pgSetJmp.h&quot;	// which is included in Paige.h

(void) pgFailBoolean(pgm_globals_ptr pgm_globals_p, pg_boolean b);
</code></pre>
<p>This function can be used to force an exception if <code>b</code> is <code>TRUE</code>. The <code>globals</code> parameter must be a pointer to <code>pgm_globals</code> (same structure given in <code>pgMemStartup</code>).</p>
<p>What actually occurs when <code>pgFailBoolean</code> is called is the following:</p>
<pre><code>if (b)
	pgFailure(globals, BOOLEAN_EXCEPTION, 0);
</code></pre>
<h2 id='265-bridging-to-c++-exceptions'>26.5 Bridging to C++ Exceptions</h2>
<p>If you are using C++ and its <code>TRY/CATCH</code> mechanism, you can &quot;bridge&quot; an HERMES Paige failure to the standard C++ exception handling by calling &quot;Failure&quot; (defined in C++ headers). Here&#39;s an example:</p>
<h3 id='code-that-follows-pgcatch'>Code that follows <code>PG_CATCH</code></h3>
<pre><code>Failure(mem_globals.last_error, mem_globals.last_message);
</code></pre>
<h3 id='creating-a-memoryref'>Creating a <code>memory_ref</code></h3>
<p>Let&#39;s take a simple but common example of using this method to detect insufficient memory when attempting to create a <code>memory_ref</code>. Here&#39;s how it would look (the
<code>mem_globals</code> variable is the same structure that you gave to <code>pgMemStartup</code> when you initialise HERMES Paige):</p>
<pre><code>{
	memory_ref SomeAllocation;
	PG_TRY(&amp;mem_globals)
	{
		SomeAllocation = MemoryAlloc(&amp;mem_globals, 1, 100000, 0};
		
		/* More code follows, but only gets executed if above allocation was successful. */		}
	
	/* If above code succeeded, PG_CATCH does *NOT* get executed. */
	PG_CATCH
	{
		/* If it gets here, your allocation failed! */
		DisposeFailedMemory(&amp;mem_globals);
		CautionAlert( ... ) 	/* Alert user that attempt failed or whatevs */
	}
	PG_ENDTRY;
	/* ^^ Must be given to balance PG_TRY statement */
</code></pre>
<p>When you execute the above code, by virtue of making the <code>PG_TRY</code> statement, HERMES Paige now knows that any failure to create memory should invoke the exception handler and jump to your <code>PG_CATCH</code> statement. Hence, if <code>MemoryAlloc</code> fails, the CPU is immediately forced to the line that contains <code>PG_CATCH</code>. At that place in your code you can do whatever to recover or alert the user or raise your own exception, etc.</p>
<p>The above example is the simplest of all cases since it only creates one <code>memory_ref</code>, hence, there really is nothing to &quot;recover.&quot; It gets slightly more involved when you create, say, multiple <code>memory_ref</code>s and you need to dispose the allocations that succeeded. One way to handle this is by setting them all to <code>NULL</code> so you know which ones succeeded in <code>PG_CATCH</code>:</p>
<pre><code>{
	memory_ref allocation1, allocation2, allocation3;
	allocation1 = allocation2 = allocation3 = MEM_NULL;
	/* ^^^ set all to zero ^^^ */
	
	PG_TRY(&amp;mem_globals)
	{
		allocation1 = MemoryAlloc(&amp;mem_globals, 1, 100000, 0);			
		allocation2 = MemoryAlloc(&amp;mem_globals, 1, 100000, 0);			
		allocation3 = MemoryAlloc(&amp;mem_globals, 1, 100000, 0);			
	}
	/* if ALL above code succeeded, PG_CATCH does not get executed */
	
	PG_CATCH
	{
	/* if it gets here, ONE of the allocations failed! */
		if (allocation1)
			DisposeFailedMemory(allocation1);
		if (allocation2)
			DisposeFailedMemory(allocation2);
		if (allocation3)
			DisposeFailedMemory(allocation3);
	}
	{		
	PG_ENDTRY;
	}
}
</code></pre>
<p>In the above example, <code>PG_CATCH</code> gets automatically executed upon the first failure of the three <code>MemoryAlloc</code>s. At that time, we dispose only the <code>memory_ref</code>s that are non-<code>NULL</code> (which means they were successfully created).</p>
<p><strong>NOTE:</strong> We call <code>DisposeFailedMemory</code> instead of <code>DisposeMemory</code>. This is a special &quot;dispose&quot; that HERMES Paige provides for this case. It disposes the <code>memory_ref</code> regardless of its locked or &quot;used&quot; state so it doesn&#39;t jump into the low-level debugger.</p>
<h3 id='own-error-checking'>Own error checking</h3>
<p>The previous examples illustrate where HERMES Paige itself, by virtue of <code>MemoryAlloc</code>, automatically invokes the exception handler. There will be other cases, however, when you want to cause a similar exception for your own error checking (but you haven&#39;t called an HERMES Paige function). One example of this would be calling <code>NewHandle</code> and having it return NULL (this indicating it failed). Here&#39;s how to do that:</p>
<pre><code>{
	Handle h;
	PG_TRY(&amp;mem_globals)
	{
		h = NewHandle(100000);
		pgFailNIL(&amp;mem_globals, h);
		/* Jump to PG_CATCH if h == nil */
	}
	
	// more code if above succeeds
	
	PG_CATCH
	{
		/* if it gets here, NewHandle() failed */
	}
	
	PG_ENDTRY;
}
</code></pre>
<p>In the above, we use <code>pgFailNIL</code>, which checks for <code>h</code> being a null pointer and if so, throws an exception (causing <code>PG_CATCH</code> immediately to execute).</p>
<p>There are other <code>pgFailxxx</code> functions to raise an exception in other ways. Using <code>pgFailure</code>, for example forces an exception unconditionally (see <code>pgSetJmp.h</code> to see the various functions and/or the docs on this).</p>
<p>There is the possibility you might need to recover from a failed <code>pgNew</code> (also <code>pgCopy</code> would be same thing). You do this the same way as in my second example of creating allocations—except that, for a <code>pg_ref</code>, you call a special error-recovery <code>dispose</code>:</p>
<pre><code>{
	pg_ref MyNewPG;
	pg_ref = MEM_NULL;
	PG_TRY(&amp;mem_globals)
	{
		MyNewPG = pgNew(.., ..);
	}
	
	/* If ALL above code succeeded, &quot;PG_CATCH&quot; does NOT get executed. */

	PG_CATCH
	{
		/* If it gets here, then HERMES Paige did not succeed and raised an exception */
		pgFailureDispose(MyNewPG);
	}
	
	PG_ENDTRY;
}
</code></pre>
<p>The function <code>pgFailureDispose</code> is called for situations like the above when none or only part of the <code>pg_ref</code> may have been created.</p>
<p><strong>NOTE:</strong> <code>pgFailureDispose</code> can accept a &quot;null&quot; <code>pg_ref</code>, so if you initially set the <code>pg_ref</code> to <code>MEM_NULL</code> you can pass it to <code>pgFailureDispose</code> safely.</p>
<h3 id='tech-note-get-globals-from-pgref-paigerecptr-etc'>TECH NOTE: Get globals from <code>pg_ref</code>, <code>paige_rec_ptr</code>, etc.</h3>
<blockquote><p>So I am buried deep within a bunch of functions and I need to do a <code>PG_TRY</code>/<code>PG_CATCH</code>.</p>
<p>All I have is a <code>pg_ref</code>.</p>
<p>How do I get the globals I need for <code>PG_TRY</code>?</p>
</blockquote>
<p>The availability of &quot;memory globals&quot; will generally depend on the kind of program you are developing.</p>
<p>In a regular application, you generally keep memory globals around as a static record that is accessible by any module of the program. Hence, the &quot;availability&quot; of globals is merely a matter of design, usually by including the necessary application header file. Example:</p>
<pre><code>//Inside one of your application headers:
extern pg_globals pgm_globals mem_globals;
</code></pre>
<p>Hence, <code>mem_globals</code> is available anywhere you include the above header.</p>
<p>For certain circumstances where only a <code>memory_ref</code> (or a <code>pg_ref</code>) is available, however, you can also get the memory globals by calling <code>GetGlobalsFromRef</code>.</p>
<p>Suppose, for instance, all you had available is <code>ref</code>, where <code>ref</code> is a memory ref (or a pg_ref). You can get a copy of memory globals as follows:</p>
<pre><code>pgm_globals_ptr mem_globals;
mem_globals = GetGlobalsFromRef(ref);
</code></pre>
<p>Getting a <code>pgm_globals_ptr</code> from a <code>paige_rec_ptr</code>:</p>
<pre><code>pgm_globals_ptr my_pgm_globals = pgp -&gt; globals -&gt; mem_globals;
PG_TRY (my_pgm_globals) 
{
	/* ... */	
}
PG_CATCH
{
	/* ... */
}
PG_ENDTRY
{
	/* ... */
}
</code></pre>
<h1 id='27-intentionally-missing'>27 INTENTIONALLY MISSING</h1>
<p>Because of the workload involved, chapter 27 (&quot;Customising HERMES Paige&quot;) is intentionally missing. The issue will be rectified but for now, users are referred to <code>chap27.pdf</code> in this directory.</p>
<h1 id='28-embedding-non-text-characters'>28 Embedding Non-Text Characters</h1>
<h2 id='281-inserting-graphics--user-items'>28.1 Inserting graphics &amp; user items</h2>
<p><strong>DEFINITION:</strong> A non-text character is a graphic display embedded into the text stream of an OpenPaige document, such as a picture, box or special string (such as a page number, footnote, etc.). It is not an ASCII byte as such, but otherwise looks and behaves like an ordinary character. It can be clicked, deleted, cut, copied, and pasted.</p>
<p>The purpose of this chapter is to explain the built-in, high-level support for these special characters.</p>
<h5 id='disclaimer'>DISCLAIMER</h5>
<p>There are several undocumented references in <code>pgEmbed.h</code>. If anything in that header file is not explained in this chapter, it is <em>not supported</em>. The purpose of these definitions is for possible future enhancement and/or custom development by DataPak Software, Inc.</p>
<h3 id='description'>Description</h3>
<p>OpenPaige provides a certain degree of built-in support for graphic characters. For the Macintosh version, <code>PicHandle</code>s (pictures) can be inserted into the text stream with practically no support required from your application. For the Windows version, meta files can be inserted in the same way.</p>
<p>For other graphic types and/or &quot;user items&quot; (custom characters), OpenPaige supports a variety of user-defined non-text character insertions; your application can then handle the display and other rendering through a single callback function.</p>
<p>All the functions documented in this chapter are prototyped in pgEmbed.h. You therefore need to include this header file to use the structures, functions and callbacks.</p>
<h2 id='282-the-embedref'>28.2 The embed_ref</h2>
<p>The first step to embedding a non-text character is to create an <code>embed_ref</code>:</p>
<pre><code>embed_ref pgNewEmbedRef (pgm_globals_ptr mem_globals, long item_type, void PG_FAR *item_data, long modifier, long flags, pg_fixed, vert_pos, long user_refcon, pg_boolean keep_around)
</code></pre>
<p>This function returns a special <code>memory_ref</code> that can be subsequently inserted into a <code>pg_ref</code> as a &quot;character&quot;. Once you have created an <code>embed_ref</code>, call <code>pgInsertEmbedRef()</code> below.</p>
<ul>
<li><p><code>mem_globals</code> — must be a pointer to your memory globals (same structure that was also given to <code>pgMemStartup</code> and <code>pgInit</code>).</p>
</li>
<li><p><code>item_type</code> — indicates the kind of object you want to create. This value can be any value shown in &quot;Embed_Ref Types”<!-- on page 28-583-->.</p>
</li>
<li><p><code>item_data</code>, <code>modifiers</code> — What you provide in <code>item_data</code> and <code>modifiers</code> depends on the item_type; these are also described in &quot;Embed Reference Types.&quot;</p>
</li>
<li><p><code>flags</code> — should be set to zero (with some unusual exceptions - &quot;Special Cases&quot;<!-- on page 28-599-->).</p>
</li>
<li><p><code>vert_pos</code> — Its purpose is to indicate a descent value for the object you will be inserting. By <em>descent</em> is meant the amount the item should be offset vertically below the baseline.
If <code>vert_pos</code> is positive, it is considered to be a percent of the item&#39;s total height. If <code>vert_pos</code> is negative, it is considered to be a pixel value. Carefully note that in both cases, <code>vert_pos</code> is a <code>Fixed</code> value — the high-order word is the whole part and the low-order word is the fraction.</p>
<p>For example, if <code>vert_pos</code> is <code>0x000A0000</code>, the <code>embed_ref</code> will be offset 10% of its total height from the text baseline. If <code>vert_pos</code> is <code>0xFFFEFFFF</code> (negative <code>0x00020000</code>), the item will be offset 2 pixels below the text baseline, etc.</p>
<p>The following illustrations show a typical <code>embed_ref</code>&#39;s descent values for different <code>vert_pos</code> values:</p>
<p><img src="https://cdn.mathpix.com/cropped/2024_04_30_f87dba95664e91f9803eg-581.jpg?height=210&amp;width=1280&amp;top_left_y=1108&amp;top_left_x=440" referrerpolicy="no-referrer"></p>
<p>The above shows the result of an <code>embed_ref</code> with <code>vert_pos</code> = 0 (no descent from baseline).</p>
<p><img src="https://cdn.mathpix.com/cropped/2024_04_30_f87dba95664e91f9803eg-581.jpg?height=200&amp;width=1290&amp;top_left_y=1490&amp;top_left_x=430" referrerpolicy="no-referrer"></p>
<p>The above shows the result of an <code>embed_ref</code> with <code>vert_pos</code> = 50.00 (descent is 50% of height).</p>
<p><img src="https://cdn.mathpix.com/cropped/2024_04_30_f87dba95664e91f9803eg-582.jpg?height=205&amp;width=1280&amp;top_left_y=180&amp;top_left_x=440" referrerpolicy="no-referrer"></p>
<p>The above shows the result of an <code>embed_ref</code> with <code>vert_pos = -3</code> (descent is 3 pixels)</p>
</li>
<li><p><code>user_refcon</code> — is saved inside the <code>embed_ref</code> itself, and can be anything.</p>
</li>
<li><p><code>keep_around</code> — indicates whether or not the <code>embed_ref</code> can be automatically disposed once it is no longer being used within any existing <code>pg_ref</code>. If this value is <code>FALSE</code> then OpenPaige is authorized to dispose of it once it is no longer being used by any <code>pg_ref</code>; a <code>TRUE</code> value tells OpenPaige it must never dispose it even if no <code>pg_ref</code> contains the embed_ref.</p>
<p>To understand the full meaning of <code>keep_around</code>, the deceloper should realise that an <code>embed_ref</code> can be &quot;shared&quot; by multiple positions in a document, and even between different documents. For example, if the user performs multiple copy/paste operations on a single <code>embed_ref</code>, OpenPaige won&#39;t actually duplicate the <code>embed_ref</code>; rather, it simply creates multiple pointers to its data.</p>
</li>

</ul>
<p>However, once the last remaining shared copy of the reference is deleted, OpenPaige will dispose the <code>memory_ref</code> (if <code>keep_around = TRUE</code>). Normally, this is what you would want.	</p>
<p><strong>NOTE:</strong> If <code>keep_around</code> is <code>FALSE</code> you should never dispose the <code>embed_ref</code> (OpenPaige will dispose of it at the appropriate time). If <code>keep_around</code> is TRUE then you need to eventually dispose the reference with <code>pgDisposeEmbedRef()</code>.</p>
<h2 id='283-inserting-the-embedref'>28.3 Inserting the <code>embed_ref</code></h2>
<pre><code>pg_boolean pgInsertEmbedRef (pg_ref pg, embed_ref ref, long position, short stylesheet_option, embed_callback callback, long callback_refcon, short draw_mode);
</code></pre>
<p>This function inserts an <code>embed_ref</code> as a &quot;character&quot; into <code>pg</code> at the specified text location. The position parameter indicates the text offset (relative to zero) to insert the <code>embed_ref</code>; the position parameter can also be <code>CURRENT_POSITION</code> which causes the insertion to occur at the current insertion point.</p>
<ul>
<li><p><code>stylesheet_option</code> — is an optional stylesheet ID that gets automatically applied to the <code>embed_ref</code> &quot;character&quot;. If you merely want to use whatever style applies to the text position, pass zero for <code>stylesheet_option</code>, otherwise you need to create a new stylesheet and provide that stylesheet ID.</p>
</li>
<li><p><code>callback</code> — is a pointer to a function (in your application) that will be called for various occurrences; the purpose of this callback is to handle custom characters and/or to modify the default behavior of standard <code>embed_ref</code>s. However, if you want OpenPaige to handle the <code>embed_ref</code> in the default way, pass <code>NULL</code> for <code>callback</code>.</p>
<p><strong>NOTE:</strong> Only certain <code>embed_ref</code> types are supported with a &quot;default behaviour&quot;, and therefore only those types will work correctly if you pass NULL for callback; see section 28.4, <em>Embed Ref Types</em>.<!-- on page 28-583--> below.</p>
</li>
<li><p><code>callback_refcon</code> — value can be anything you want; this same value will be given to your callback function. If you have not supplied a callback function (<code>callback = NULL</code>), this parameter does not matter.</p>
</li>
<li><p><code>draw_mode</code> — indicates whether or not to redraw the text after the <code>embed_ref</code> is inserted; the value you pass for this parameter is identical to all other OpenPaige functions that accept a <code>draw_mode</code>.</p>
</li>

</ul>
<h4 id='notes-and-cautions'>Notes and Cautions</h4>
<ul>
<li><p>Value <code>callback_refcon</code> given to <code>pgInsertEmbedRef</code> is <em>not</em> to be confused with <code>user_refcon</code> given to <code>pgNewEmbedRef</code>; they are entirely <em>separate</em>. The <code>user_refcon</code> given to <code>pgNewEmbedRef</code> is stored within the <code>embed_ref</code> itself, and the same <code>embed_ref</code> can exist as multiple copies throughout a document; the <code>callback_refcon</code> is specific to the insertion itself and can be different
for all occurrences of the <code>embed_ref</code>. The <code>callback_refcon</code> is stored in the <code>style_info</code> that is applied to the insertion, and is also passed to your callback function (if one exists).</p>
<p>The <code>user_refcon</code> will always be whatever value you passed to <code>pgInsertEmbedRef()</code> in the <code>callback_refcon</code> parameter except for <code>EMBED_READ_DATA</code> and <code>EMBED_WRITE_DATA</code>, in which case the <code>user_refcon</code> will be the original <code>user_refcon</code> value given to <code>pgNewEmbedRef()</code>.</p>
</li>
<li><p>Do not insert the same <code>embed_ref</code> more than once unless you have created it with <code>keep_around = TRUE</code>. Otherwise, OpenPaige can dispose it prematurely and your program will crash. Once it has been inserted, however, it is OK to copy and paste that character to as many documents as memory permits.</p>
</li>
<li><p>Once the <code>embed_ref</code> has been inserted, OpenPaige &quot;owns&quot; its memory, i.e. you <em>must not</em> dispose of it as long as it exists in any <code>pg_ref</code> (and, if you passed <code>FALSE</code> for <code>keep_around</code> in <code>pgNewEmbedRef()</code>, you <em>must not</em> dispose of it at all, at any time).</p>
</li>

</ul>
<h3 id='the-style-sheet-option'>The Style Sheet Option</h3>
<p>Any <code>embed_ref</code> has the option to alter the style and/or font of the text it applies to.</p>
<p>For example, a string-type <code>embed_ref</code> (<code>embed_alternate_char</code>) will normally assume the style and font of the text where it was embedded; however, by passing a non-zero <code>stylesheet_id</code> number in <code>stylesheet_option</code> in <code>pgInsertEmbedRef</code> or <code>pgSetEmbedRef</code>, the style or font can be overridden.</p>
<p>A <code>stylesheet_id</code> is obtained by first creating a new <code>style_info</code> record and adding it to the <code>pg_ref</code> as a new style sheet (see chapter 31, &quot;Style Sheets&quot;<!-- on page 31-1-->). The <code>stylesheet_id</code> is then given to the <code>stylesheet_option</code> parameter, in which case the text for which the embed_ref applies will assume that style.</p>
<p>However, a style sheet applied to an <code>embed_ref</code> works slightly differently than normal styles: only the non-zero items in the <code>style_info</code> record of the stylesheet are applied.</p>
<p>For example, let us suppose that a new style sheet is created with every field in its <code>style_info</code> record set to zero except for the italic attribute. If this style sheet is applied to an <code>embed_ref</code>, the text is forced to italic but retains all other attributes (same point size as before, same font, etc.).</p>
<p>The following is an example of applying italic to an <code>embed_ref</code>; note that the <code>embed_ref</code> text retains all style and font characteristics except that it is italicised:</p>
<pre><code>style_info new_sheet;
short stylesheet_id;

pgFillBlock(&amp;new_sheet, sizeof(style_info), 0); // Fill with all zeros
style_info.styles[italic_var] = -1;				// Set for italic
stylesheet_id = pgNewStyle(pg, &amp;new_sheet, NULL);

// Now include in &quot;stylesheet_option&quot;:

pgSetEmbedRef(pg, ref, NULL, stylesheet_id, 0, best_way);
</code></pre>
<p>If you want to change only the font in the <code>embed_ref</code> text, use the same example as above except omit changing the italic attribute and pass a <code>font_info</code> record instead of <code>NULL</code> for <code>pgNewStyle</code>.</p>
<h2 id='284-embedref-types'>28.4 <code>embed_ref</code> Types</h2>
<p>The following table describes each possible <code>embed_ref</code> data type and what you should pass in the <code>item_data</code> and modifier parameters for <code>pgNewEmbedRef()</code>. The <em>Support</em> column indicates which OpenPaige platform supports the data type. All the items listed are supported to some extent; <em>i.e.</em>, none of them require a callback function to render a default behavior.</p>
<p><strong>NOTE:</strong> <em>If the data type is not listed, there is no current OpenPaige support for the type.</em> (You can, of course, support your own using the callback function.)</p>
<h4 id='table-5-embedref-data-types'>Table 5. <code>embed_ref</code> data types</h4>
<figure class='table-figure'><table>
<thead>
<tr><th style='text-align:left;' >Data Type</th><th style='text-align:center;' >Support</th><th style='text-align:center;' ><code>*item_data</code> parameter</th><th style='text-align:left;' >modifier</th><th style='text-align:center;' >Note(s)</th></tr></thead>
<tbody><tr><td style='text-align:left;' ><code>embed_rectangle</code></td><td style='text-align:center;' >all platforms</td><td style='text-align:center;' ><code>rectangle_ptr</code></td><td style='text-align:left;' >pen size (pixels)</td><td style='text-align:center;' >&nbsp;</td></tr><tr><td style='text-align:left;' ><code>embed_oval</code></td><td style='text-align:center;' >all platforms</td><td style='text-align:center;' ><code>rectangle_ptr</code></td><td style='text-align:left;' >pen size (pixels)</td><td style='text-align:center;' >&nbsp;</td></tr><tr><td style='text-align:left;' ><code>embed_roundrectangle</code></td><td style='text-align:center;' >all platforms</td><td style='text-align:center;' ><code>rectangle_ptr</code></td><td style='text-align:left;' >round corner + pen size</td><td style='text-align:center;' >1</td></tr><tr><td style='text-align:left;' ><code>embed_control</code></td><td style='text-align:center;' ><strong>Macintosh</strong> only</td><td style='text-align:center;' ><code>ControlHandle</code></td><td style='text-align:left;' >not used</td><td style='text-align:center;' >2</td></tr><tr><td style='text-align:left;' ><code>embed_polygon</code></td><td style='text-align:center;' >all platforms</td><td style='text-align:center;' ><code>memory_ref</code> of polygon</td><td style='text-align:left;' >pen size (pixels)</td><td style='text-align:center;' >3</td></tr><tr><td style='text-align:left;' ><code>embed_mac_pict</code></td><td style='text-align:center;' ><strong>Macintosh</strong> only</td><td style='text-align:center;' ><code>PicHandle</code></td><td style='text-align:left;' >not used</td><td style='text-align:center;' >&nbsp;</td></tr><tr><td style='text-align:left;' ><code>embed_mac_vm_pict</code></td><td style='text-align:center;' ><strong>Macintosh</strong> only</td><td style='text-align:center;' ><code>memory_ref</code> of <code>Pict</code> data</td><td style='text-align:left;' >not used</td><td style='text-align:center;' >7</td></tr><tr><td style='text-align:left;' ><code>embed_meta_file</code></td><td style='text-align:center;' ><strong>Windows</strong> only</td><td style='text-align:center;' ><code>metafile_ptr</code></td><td style='text-align:left;' >not used</td><td style='text-align:center;' >4</td></tr><tr><td style='text-align:left;' ><code>embed_alternate_char</code></td><td style='text-align:center;' >all platforms</td><td style='text-align:center;' ><code>cstring</code> (any size)</td><td style='text-align:left;' >not used</td><td style='text-align:center;' >5</td></tr><tr><td style='text-align:left;' ><code>embed_user_data</code></td><td style='text-align:center;' >all platforms (limited)</td><td style='text-align:center;' >pointer to data</td><td style='text-align:left;' >data size (bytes)</td><td style='text-align:center;' >6</td></tr><tr><td style='text-align:left;' ><code>embed_dynamic_string</code></td><td style='text-align:center;' >all platforms</td><td style='text-align:center;' ><code>cstring</code> (any size)</td><td style='text-align:left;' >max size (bytes)</td><td style='text-align:center;' >&nbsp;</td></tr><tr><td style='text-align:left;' ><code>embed_user_box</code></td><td style='text-align:center;' >all platforms (limited)</td><td style='text-align:center;' ><code>rectangle_ptr</code></td><td style='text-align:left;' >pen size (pixels)</td><td style='text-align:center;' >1</td></tr></tbody>
</table></figure>
<!-- Note: The source material has no notes 1-7 here, no idea what this could POSSIBLY refer to -->
<p>-</p>
<ul>
<li><p><code>embed_roundrectangle</code> — the low-order word of <code>modifier</code> is the pen size; the high-order word is the &quot;rounded corner&quot; value, e.g. <code>FrameRoundRect(rect, value, value)</code>.</p>
</li>
<li><p><code>embed_user_box</code> — The default behavior for <code>embed_user_box</code> is identical to <code>embed_rectangle</code>. To modify the default behaviour, use the <code>callback</code> function.</p>
</li>
<li><p><code>ControlHandle</code> — is detached from any <code>Window</code> before it gets inserted.</p>
</li>
<li><p><code>data</code> — is a <code>memory_ref</code> that <em>must</em> contain the following structure:</p>
<pre><code>typedef struct
{
	short width;			// Width of polygon in pixels
	short height;			// Height of polygon in pixels
	short rsrv;				// (Here for future enhancement)
	short num_points;		// Number of points that follow
	co_ordinate points[1];	// One or more points for the drawing
}
pg_poly_rec, PG_FAR *pg_poly_ptr;
</code></pre>
</li>
<li><p><code>width</code> and <code>height</code> — members should contain the width and height of the bounding area of the polygon. The <code>num_points</code> member should contain the number of connecting points in the <code>points[]</code> member array.</p>
</li>
<li><p><code>points</code> — are represented by a series of <code>co_ordinate</code> pairs; the first pair is a line, the second pair is another line, etc.</p>
<ol start='' >
<li>The points array must therefore be in PAIRS.</li>
<li>A Windows meta file must be represented by the following structure (pointed to by the item_data parameter);</li>

</ol>
</li>

</ul>
<p>-</p>
<pre><code>struct metafile_struct
{
	long metafile;		// Metafile data (HANDLE if Windows)
	long mapping_mode;	// Mapping mode (Windows only)
	short x_ext;		// Original X-extent
	short y_ext;		// Original Y-extent
	rectangle bounds;	// Source bounding rect
};
</code></pre>
<p>-</p>
<ul>
<li><p><code>metafile</code> — The meta file <code>HANDLE</code> should be in the <code>metafile</code> member; the mapping mode for the meta file should be in <code>mapping_mode</code>. For most meta files the mapping mode is <code>MM_ANISOTROPIC</code>.</p>
</li>
<li><p><code>x_ext</code> and <code>y_ext</code> — Members should contain the mapping mode-specific <em>X</em> and <em>Y</em> extents, respectively. You can also set these to zero (in which case the default width and height of the meta file will be used, taken from the bounds member). Most often, the <code>mapping_mode</code> and the <em>x</em> and <em>y</em> extents are taken from clipboard information.</p>
</li>
<li><p><code>bounds</code> — Member defines the meta file&#39;s dimensions in screen coördinates.</p>
<p>The <code>metafile</code> <code>HANDLE</code> should be in the <code>metafile</code> member; the <code>bounds</code> member must define the bounding area of the <code>metafile</code> (the enclosing rectangle as the <code>metafile</code> was recorded).</p>
</li>
<li><p><code>embed_alternate_char</code> and <code>embed_dynamic_string</code> — draw a whole string to represent a single &quot;character&quot;.</p>
<p>The <code>embed_dynamic_string</code>, however, can be dynamically altered (changed or &quot;swapped&quot; with a different string) in the callback function for display and character measuring purposes.</p>
</li>
<li><p><code>embed_alternate_char</code> and <code>embed_dynamic_string</code> — are treated as a single character and will therefore not wrap or word break in the middle.</p>
</li>
<li><p><code>embed_user_data</code> — the item is considered custom (generally handled by your callback function), but OpenPaige will save and retrieve your data automatically when saving to files. The data is assumed to be a contiguous byte stream in <code>*item_data</code>.</p>
</li>
<li><p><code>item_data</code> for <code>embed_mac_vm_pict</code> — must be a <code>memory_ref</code> containing the data from a <code>PicHandle</code>. This type behaves exactly the same as <code>embed_mac_pict</code> except that the <code>memory_ref</code> provides virtual memory to the picture.</p>
</li>

</ul>
<h2 id='285-the-callback-function'>28.5 The Callback Function</h2>
<p>Any custom user type <code>embed_ref</code>, <code>embed_ref</code>s that are not supported, or items that require modification(s) to the default behaviour will require a callback function. The callback function is a pointer to some code (that you write) that gets called for a number of occurrences:</p>
<pre><code>PG_PASCAL (long) EmbedCallback (paige_rec_ptr pg, pg_embed_ptr embed_ptr, long embed_type, short command, long user_refcon, long param1, long param2);
</code></pre>
<p>Each <code>embed_ref</code> you have inserted can have its own callback function (or they can all share the same callback if you so choose). The callback is set by passing the function pointer to the &quot;callback&quot; parameter in pgInsertEmbedRef().</p>
<p><strong>NOTE:</strong> For <em>Windows 3.1</em>, you need to set a callback function that has been created with <code>MakeProcInstance()</code>.</p>
<p>Upon entry, <code>pg</code> is the OpenPaige record structure that owns the <code>embed_ref</code>; the <code>embed_ptr</code> parameter is a pointer to the <code>embed_ref</code> record structure <em>infra</em>, and <code>embed_type</code> is the data type (same one you gave to <code>pgNewEmbedRef()</code> when it was initially created).</p>
<ul>
<li><code>command</code> — indicates why the function is being called, and <code>param1</code>/<code>param2</code> will contain different values depending on what value is in <code>command</code> (see &quot;Command Messages” <em>infra</em>).</li>
<li><code>user_refcon</code> — will be whatever value you passed to <code>pgInsertEmbedRef()</code> in the <code>callback_refcon</code> parameter except for <code>EMBED_READ_DATA</code> and <code>EMBED_WRITE_DATA</code>, in which case the <code>user_refcon</code> will be the original <code>user_refcon</code> value given to <code>pgNewEmbedRef()</code>.</li>

</ul>
<h3 id='command-messages'>Command Messages</h3>
<p>When the <code>callback</code> function is called, the value in <code>command</code> will be one of the values below. Depending on the command, <code>param1</code> and <code>param2</code> contain additional data. In each case, the <code>embed_ptr</code> will point to the <code>embed_ref</code> structure (see &quot;The Embed Record&quot;<!-- on page 28-596-->).</p>
<ul>
<li><p><code>EMBED_INIT</code> — occurs during a <code>pgReadDoc()</code> function (file read). The purpose of this command is to initialize an <code>embed_ref</code> that has been read from a file (typically, to set a callback function specific to the associated text style). See <code>pgInitEmbedProcs</code><!-- on page 604 this chapter--> regarding the first <code>pgReadDoc</code> callback function.</p>
<p>Upon entry, <code>param1</code> indicates the number of times <code>EMBED_INIT</code> has been sent to the <code>callback</code> function during <code>pgReadDoc</code> for this particular <code>embed_ref</code>. (Since the same <code>embed_ref</code> can be shared by many places in the text, your initialisation code might want to know this information so the <code>embed_ref</code> data is initialised only once). On the first callback for this <code>embed_ref</code>, <code>param1</code> is zero.</p>
<p>The <code>param2</code> will be a <code>style_info</code> pointer that is associated to the <code>embed_ref</code>.</p>
<p>The <code>callback</code> function result is ignored.</p>
</li>
<li><p><code>EMBED_DRAW</code> — occurs when the <code>embed_ref</code> should be drawn.</p>
</li>
<li><p><code>param1</code> — Upon entry, this is a <code>rectangle_ptr</code> (an OpenPaige rectangle) that defines the exact drawing bounds of the embedded item (which includes scrolled position and scaling).</p>
</li>
<li><p><code>param2</code> — is a <code>draw_points_ptr</code> containing additional information for drawing (see <code>draw_points_ptr</code> in OpenPaige manual and/or in <code>Paige.h</code>).</p>
<p>The <code>callback</code> function result is ignored.</p>
<p><strong>NOTE:</strong> On <em>Windows</em>, the device context that you should draw to can be obtained as follows:</p>
<pre><code>HDC hdc;
hdc = (HDC)pg -&gt; globals -&gt; current_port.machine_ref;
</code></pre>
<p>Do not assume that OpenPaige is drawing to the current window (it can be drawing to a bitmap DC or a printer DC, etc.). When the <code>callback</code> is called, the above code is <em>guaranteed</em> to return a valid device context to use for drawing.</p>
<p><strong>NOTE:</strong> On <em>Macintosh</em>, the <code>GrafPort</code> you should draw to is set as the current port before the <code>callback</code> is called. Do not assume that drawing will occur to the <code>pg_ref</code> window (it can occur to an offscreen bitmap port).</p>
</li>
<li><p><code>EMBED_MEASURE</code> — occurs when OpenPaige wants to know the character width(s) of the embedded item.</p>
<p>Upon entry, <code>param1</code> is a <code>pg_embed_measure_ptr</code> and <code>param2</code> is not used. (See “The Measure Record”<!-- on page 28-598-->).</p>
<p><strong>NOTE:</strong> This <code>callback</code> is only used to obtain the object&#39;s width. Its height must be initialized either before inserting the <code>embed_ref</code> or in response to <code>EMBED_VMEASURE</code>.</p>
<p>Before returning from this function, you should set the <code>embed_ptr -&gt; width</code> to the <code>embed_ref</code>&#39;s width, in pixels.</p>
<p><strong>NOTE:</strong> OpenPaige will determine the width automatically for embed types that are fully supported (requiring no callback).</p>
<p>The function result from the <code>callback</code> function is ignored.</p>
</li>
<li><p><code>EMBED_VMEASURE</code> — occurs when OpenPaige wants to know the height of the embedded item.</p>
<p>Upon entry, <code>param1</code> is the <code>style_info_ptr</code> that &quot;owns&quot; the <code>embed_ref</code> and <code>param2</code> is not used.</p>
<p>Before returning from this function you should set the <code>embed_ptr -&gt; height</code> to the <code>embed_ref</code>&#39;s height, in pixels.</p>
<p><strong>NOTE:</strong> OpenPaige will determine the height automatically for embed types that are fully supported (requiring no callback).</p>
<p>The function result from the <code>callback</code> function is ignored.</p>
</li>
<li><p><code>EMBED_SWAP</code> — occurs (only) when the item type is <code>embed_dynamic_str</code>. The <code>callback</code> function is used to &quot;swap out&quot; (substitute) a string of bytes with something else. For example, this type of <code>embed_ref</code> can be used to indicate a date or time, page number, or footnote, all of which might change dynamically.</p>
<p>Upon entry, <code>param1</code> is a pointer to the existing string (or empty buffer), and <code>param2</code> is a long value indicating the maximum number of bytes that can be put into the buffer. The job of the <code>callback</code> function, in this case, is to fill the buffer pointed to by <code>param1</code>.</p>
<p>The function result of this <code>callback</code> must be the number of bytes placed in <code>*param1</code> (i.e., the string length).</p>
</li>
<li><p><code>EMBED_CURSOR</code> - occurs when the mouse is on top of the <code>embed_ref</code>. The purpose of the callback is to let your application change the cursor, if desired.</p>
<p><strong>NOTE:</strong> This callback will never occur unless you call <code>pgPtInEmbed()</code>.</p>
<p>Upon entry, <code>param1</code> will be a <code>co_ordinate_ptr</code> for the mouse <code>point</code>, and <code>param2</code> is a <code>rectangle_ptr</code> to the enclosing bounds of the <code>embed_ref</code>.</p>
<p>The <code>callback</code> function result is ignored.</p>
</li>
<li><p><code>EMBED_MOUSEDOWN</code> — occurs during a <code>pgDragSelect()</code> with <code>mouse_down</code> verb, when an <code>embed_ref</code> has been clicked.</p>
<p>Upon entry, <code>param1</code> is a pointer to a <code>pg_embed_click</code> record with additional info (see &quot;Click Record&quot; <em>infra</em>).</p>
<p>The function result from the <code>callback</code> should be any non-zero value if you want to continue tracking the <code>embed_ref</code> like a control button, otherwise return zero. (By tracking like a control button is meant that OpenPaige will not try to drag-select surrounding characters, rather subsequent mouse movements will be passed to your callback function with <code>EMBED_MOUSEMOVE</code> and <code>EMBED_MOUSEUP</code> commands.</p>
<p><strong>CAUTION:</strong> To achieve a &quot;push-button control&quot; effect, mouse-click behaviour may not appear to work correctly unless you include <code>EMBED_CONTROL_FLAG</code> in the <code>flags</code> parameter for <code>pgNewEmbedRef()</code>. See &quot;Acting Like a Control&quot;<!-- on page 28-594--> in this chapter.</p>
</li>
<li><p><code>EMBED_MOUSEMOVE</code> — occurs during a <code>pgDragSelect()</code> with <code>mouse_move</code> given as the <code>verb</code>, <strong>if</strong> you returned non-zero from the previous <code>callback</code> for <code>EMBED_MOUSEDOWN</code>. The parameters are identical to <code>EMBED_MOUSEDOWN</code>.</p>
<p><strong>CAUTION:</strong> To achieve a &quot;push-button control&quot; effect, mouse-click behavior may not appear to work correctly unless you include <code>EMBED_CONTROL_FLAG</code> in the <code>flags</code> parameter for <code>pgNewEmbedRef()</code>. See &quot;Acting Like a Control&quot;<!-- on page ... in this chapter-->.</p>
</li>
<li><p><code>EMBED_MOUSEUP</code> — occurs during a <code>pgDragSelect()</code> with <code>mouse_up</code> given as the verb, <strong>if</strong> you returned non-zero from the previous <code>callback</code> for <code>EMBED_MOUSEMOVE</code>.</p>
<p>The parameters are identical to <code>EMBED_MOUSEDOWN</code>.</p>
</li>
<li><p><code>EMBED_DOUBLECLICK</code> — occurs during a <code>pgDragSelect()</code> with <code>mouse_down</code> and <code>modifier</code> containing <code>WORD_MOD_BIT</code> (“double click&quot;). The parameters are identical to the <code>callback</code> for <code>EMBED_MOUSEDOWN</code>.</p>
</li>
<li><p><code>EMBED_DESTROY</code> — occurs when the <code>embed_ref</code> is about to be disposed. Upon entry, <code>param1</code> and <code>param2</code> are not used. The function result is ignored. </p>
<p>NOTE: You will not receive this message if you dispose your own <code>embed_ref</code> (e.g., made a call to <code>pgEmbedDispose()</code>). The only time you will receive this <code>callback</code> command is when OpenPaige disposes the <code>embed_ref</code>; this happens when the last occurrence an <code>embed_ref</code> has been deleted (and you gave <code>FALSE</code> for <code>keep_around</code> when the <code>embed_ref</code> was created).</p>
<p><strong>CAUTIONS:</strong> </p>
<ol start='' >
<li>If you have created your own data and have placed it in <code>embed_ptr -&gt; data</code>, you must first dispose it (if appropriate) then set that member to <code>NULL</code>. However, do not dispose the data if you gave that data to <code>item_data</code> and the data type is <code>embed_user_data</code>.</li>
<li>If the <code>embed_ref</code> data is not supported (i.e. fully custom), <em>do not</em> call the default <code>callback</code> function when <code>command</code> is <code>EMBED_DESTROY</code>.</li>
<li>Do not dispose the <code>embed_ref</code> itself. You should only dispose memory structures that you created.</li>

</ol>
</li>
<li><p><code>EMBED_COPY</code> —  Occurs when a <code>style_info</code> containing an <code>embed_ref</code> is duplicated.</p>
<p>This <code>callback</code> only occurs for <code>embed_ref</code>s that contain <code>NOT_SHARED_FLAG</code> (see “Special Cases”).</p>
<p>Upon entry, <code>param1</code> and <code>param2</code> are not used. The intended purpose of <code>EMBED_COPY</code> is to duplicate any memory structures you might have stored in the <code>embed_ref</code>.</p>
</li>
<li><p><code>EMBED_WRITE_DATA</code> — Occurs when an embed_ref is saved during <code>pgSaveDoc()</code>.</p>
<p>When OpenPaige saves an <code>embed_ref</code> to a file, all the &quot;default&quot; information is saved before this command is given to your callback. The intended purpose of <code>EMBED_WRITE_DATA</code> is for you to prepare any additional data that needs to be written to the file; this same data will then be retrieved when the file is read and issued to your callback as <code>EMBED_READ_DATA</code>.</p>
<p>Essentially, when you get the <code>EMBED_WRITE_DATA</code> command, you don&#39;t need to do anything unless there is extra data you have stored in the <code>embed_ref</code> that OpenPaige won&#39;t know about; all the other <code>embed_ref</code> contents are saved otherwise.</p>
<p>Upon entry, <code>param1</code> is a <code>memory_ref</code> of zero byte size, and <code>param2</code> is not used. To save any additional data associated to the <code>embed_ref</code>, insert the bytes into this <code>memory_ref</code>. When the function returns, OpenPaige will write <code>GetMemorySize(param1)</code> bytes to the file; later when the file is opened, these same bytes will be read from the file and given to your callback with <code>EMBED_READ_DATA</code> as the command.</p>
<p>When the <code>callback</code> returns, if the memory size of <code>(memory_ref) param1</code> is zero, no extra data is saved.</p>
<p>The function result from the <code>callback</code> is ignored.</p>
<p><strong>NOTE:</strong> The <code>EMBED_WRITE_DATA</code> callback will only occur once for each <code>embed_ref</code>. In other words, if multiple &quot;shared&quot; copies of the <code>embed_ref</code> exist in the document, you will only be asked to save extra data once.</p>
</li>
<li><p><code>EMBED_READ_DATA</code> — Occurs when an <code>embed_ref</code> is read from a file during <code>pgReadDoc()</code>. This command will always get sent for every <code>embed_ref</code> that is read even if you saved no extra data (from <code>EMBED_WRITE_DATA</code>).</p>
<p>Upon entry, <code>param1</code> is a pointer to the same data bytes, if any, that you saved when the command was <code>EMBED_WRITE_DATA</code>, and <code>param2</code> is the byte count.</p>
<p>The function result from this <code>callback</code> is ignored.</p>
<p><strong>NOTE:</strong> The <code>EMBED_READ_DATA</code> callback will only occur once for each <code>embed_ref</code>. In other words, if multiple &quot;shared&quot; copies of the <code>embed_ref</code> exist in the document, you will only be asked to process the data once.</p>
</li>

</ul>
<h2 id='286-default-callback'>28.6 Default Callback</h2>
<p>You should always call the default function, <code>pgDefaultEmbedCallback</code>, from your callback code if you do not handle the command (some exceptions—see caution <em>infra</em>).</p>
<p>For example, you might create a callback function only for the purpose of changing the cursor when the mouse is over the <code>embed_ref</code>. In this case, you would not want to handle any other command; rather, you want the default handling. To do so, make a call to <code>pgDefaultEmbedCallback()</code>.</p>
<pre><code>pascal long MyCallback (paige_rec_ptr pg, pg_embed_ptr embed_ptr, long embed_type, short command, long callback_refcon, long param1, long param2);
{
	if (i_dont_want_to_handle)
		return pgDefaultEmbedCallback(pg, embed_ptr, embed_type, command, callback_refcon, param1, param2);
	// else handle the command
}
</code></pre>
<p>CAUTION: Never call <code>pgDefaultEmbedCallback()</code> for <code>EMBED_DESTROY</code> if you have placed your own data in <code>embed_ptr -&gt; data</code>. If you have not directly altered the <code>data</code> field in any way, it is OK to call the default.</p>
<h2 id='287-acting-like-a-control'>28.7 Acting Like a Control</h2>
<p>In many cases, user-defined <code>embed_ref</code>s need to act like a &quot;control&quot;. For example, once the user clicks in the <code>embed_ref</code>, the mouse needs to be &quot;tracked&quot; as if the <code>embed_ref</code> were a push-button control.</p>
<p>To make your embedded item behave this way, include the following value in the <code>flags</code> parameter for <code>pgNewEmbedRef()</code>:</p>
<pre><code>#define EMBED_CONTROL_FLAG	0x00100000		// Acts like a control
</code></pre>
<h3 id='creating-embedref-that-acts-like-a-control'>Creating <code>embed_ref</code> that acts like a &quot;control&quot;</h3>
<pre><code>/* This sample was taken from the Mac demo but can apply to ANY embed_ref inserted for any platform: */

static void insert_embedded_pict(doc_rec *doc, PicHandle picture)
{
	embed_ref ref;
	
	ref = pgNewEmbedRef(&amp;mem_globals, embed_mac_pict, (void*) picture, 0, EMBED_CONTROL_FLAG, 0, 0, FALSE);
	pgInsertEmbedRef(doc -&gt; pg, ref, CURRENT_POSITION, 0, NULL, 0, best_way);
}
</code></pre>
<h2 id='288-the-embed-record'>28.8 The Embed Record</h2>
<pre><code>struct pg_embed_rec {
	short				version;			// Version of embedded 
	short				reserved;			// reserved 
	long				type;				// Type of item embedded 
	long				width;				// Drawing width, in pixels 
	long				minimum_width;		// Minimum width 
	long				height;				// Drawing height, in pixels 
	long				descent;			// Distance bottom is below text line bottom 
	long				draw_flags;			// Drawing attributes (see table below) 
	long				modifier;			// Extra data for certain objects 
	long				empty_width;		// Width of item when empty (applies to dynamic types). 
	long				alignment_flags;	// Alignment (subrefs only) 
	short				top_extra;			// Extra &quot;whitespace&quot; at the top 
	short				bot_extra;			// Extra &quot;whitespace&quot; at the bottom 
	short				left_extra;			// Extra &quot;whitespace&quot; at the left edge 
	short				right_extra;		// Extra &quot;whitespace&quot; at the right edge 
	void PG_FAR			*data;				// The item&#39;s data, if appropriate 
	memory_ref			embed_represent;	// Optional embed that represents unsupported type 
	memory_ref			rtf_text_data;		// Original preamble text from unsupported RTF import 
	union 
	{
		pg_pic_embed	pict_data;			// Special picture data 
		pg_horiz_line	line_info;			// Special line data 
		pg_date			date_info;			// Date info 
		pg_time			time_info;			// Time info 
		pg_char			alt_data[ALT_SIZE + BOM_HEADER];	// Alternate data (for ALT_SIZE or less chars) 
		pg_char			book_data[BOOKMARK_SIZE];// Bookmark data 
	} uu;
	long				border_info;		// Border control (revised for 3.01) 
	long				border_color;		// The border color 
	long				shading;			// Background color shading 
	style_info_ptr		style;				// The style associated to this item 
	long				user_refcon;		// What app put with this embed 
	long				user_data;			// App can also use this field 
	long				style_refcon;		// Refcon saved in styles 
	long				lowlevel_index;		// Used by low level functions 
	long				used_ctr;			// Count of shared access (maintained internally) 
};
</code></pre>
<p>The above structure is what all <code>embed_ref</code>s look like internally. Most of the fields are maintained by OpenPaige and you must neither alter them nor assume they are valid at any time, except as further elucidated.</p>
<p>The following fields can be altered (and in some cases need to be initialised) by your application:</p>
<ul>
<li><p><code>width</code>, <code>height</code> — Define the width and height of the object. The <code>width</code> member gets set in the <code>callback</code> function when the command is <code>EMBED_MEASURE</code>; if the item type is unsupported or custom, the <code>height</code> member must be initialised before inserting the <code>embed_ref</code>.</p>
</li>
<li><p><code>minimum_width</code> — Define the minimum width (smallest size) allowed for the <code>embed_ref</code>. Your application needs to set this; otherwise, it is zero.</p>
</li>
<li><p><code>descent</code> — Defines the distance the object should draw below the text baseline. You may alter this value for a descent other than the default.</p>
</li>
<li><p><code>top_extra</code> through <code>right_extra</code> — Define optional extra white space on the top, left, bottom and right sides of the object. The default for each of these members is zero; if you want something else, you should modify them before inserting the <code>embed_ref</code>.</p>
</li>
<li><p><code>data</code> - You may place whatever data your application requires into this member. However, please observe the following cautions:</p>
<ol start='' >
<li>Do NOT alter the data field directly for <code>embed_user_data</code> type or any of the supported types listed above.</li>
<li>If you place anything directly in the <code>data</code> member, do not call the default callback function when the command is <code>EMBED_DESTROY</code>.</li>
<li>You must dispose your own data, if appropriate. Letting OpenPaige handle it as a default can result in a crash.</li>

</ol>
</li>

</ul>
<h2 id='289-the-measure-record'>28.9 The Measure Record</h2>
<pre><code>typedef struct
{
	style_walk_ptr	walker;				// Style information
	pg_char_ptr			text;					// &quot;Text&quot; pointer
	long						text_size;		// &quot;Text&quot; size, in bytes
	pg_short_t			slop;					// Extra amount for full-justify
	long PG_FAR			*positions;		// Width locations of &quot;text&quot; bytes
	short PG_FAR 		*types;				// Character types
	short						scale_verb;		// Whether or not to scale results
	short 					measure_verb;	// Measurement verb
	long						current_offset;	// Current offset to measure
	short						call_order;		// The call order
};

pg_embed_measure, PG_FAR *pg_embed_measure_ptr;
</code></pre>
<p>The measure record is passed as a pointer in <code>param1</code> for <code>EMBED_MEASURE</code> commands. Usually, you won&#39;t need to use any of these values, but they are listed here for the sake of clarity.</p>
<h2 id='2810-the-click-record'>28.10 The Click Record</h2>
<pre><code>typedef struct
{
	t_select_ptr first_select;	// Start of selection
	t_select_ptr last_select;	// End of selection
	co_ordinate point;			// Mouse point
	rectangle bounds;			// Frame around the item
	short modifiers;			// Modifiers from pgDragSelect
}
pg_embed_click, PG_FAR *pg_embed_click_ptr;
</code></pre>
<p>A pointer to the above structure is provided in <code>param1</code> for <code>EMBED_MOUSEDOWN</code>, <code>EMBED_MOUSEMOVE</code>, <code>EMBED_MOUSEUP</code>, and <code>EMBED_DOUBLECLICK</code> commands.</p>
<p>The <code>first_select</code> and <code>last_select</code> members represent the current beginning and ending selection point(s) of the drag-select. (For <code>EMBED_MOUSEDOWN</code> these are typically the same). The <code>point</code> and <code>modifiers</code> members will contain the <code>co_ordinate</code> value and modifiers given to <code>pgDragSelect()</code>, respectively. The <code>bounds</code> member will contain the WYSIWYG bounding rectangle of the <code>embed_ref</code> that is being clicked.</p>
<h2 id='2811-special-cases'>28.11 Special Cases</h2>
<p>The <code>flags</code> parameter for <code>pgNewEmbedRef</code> has been briefly mentioned earlier. Normally, the value for <code>flags</code> should be zero. There are two possible bit settings you can provide for this parameter for specific situations, as follows:</p>
<ul>
<li><p><code>NOT_SHARED_FLAG</code> — If this bit is set, the <code>embed_ref</code>&#39;s data is always duplicated for any copy/paste operation. Normally, when an <code>embed_ref</code> is copied in the text stream, its contents are not actually copied; rather, only a pointer to its reference is copied. In essence, only one &quot;real&quot; <code>embed_ref</code> exists in the document even though there could be many occurrences of the reference throughout the text stream.</p>
<p>However, this may be undesirable in situations where copied <code>embed_ref</code>(s) must be unique (as opposed to pointer &quot;clones&quot; of the original). If this is the case, set <code>NOT_SHARED_FLAG</code>.</p>
</li>
<li><p><code>EMBED_CONTROL_FLAG</code> — If this bit is set, the <code>embed_ref</code> responds like a control (such as a button). Otherwise, the <code>embed_ref</code> acts like a character. Note that the only significant difference between a <em>control</em> and a <em>character</em> is the way OpenPaige highlights the <code>embed_ref</code> when it is clicked. As a &quot;control&quot;, the entire <code>embed_ref</code> is selected from a single click.</p>
</li>
<li><p><code>NO_FORCED_IDENTITY</code> — If this bit is set, when the <code>embed_ref</code> is inserted, OpenPaige scans the document for any <code>embed_ref</code> that matches its type, its width and height, and its <code>user_refcon</code> value. If such a match is found, the (new) <code>embed_ref</code> is discarded and the matching (older) <code>embed_ref</code> is used in its place.</p>
<p>The purpose of <code>NO_FORCED_IDENTITY</code> is to minimise the amount of memory used by repeated insertions of the same <code>embed_ref</code> type.</p>
<p>For example, suppose your application is designed to insert a mathematical symbol (that can&#39;t otherwise be represented by a text character). To achieve this, an <code>embed_ref</code> is created to draw the symbol and it is inserted in many different places. Normally (without <code>NO_FORCED_IDENTITY</code> set), OpenPaige will create a unique <code>style_info</code> record and <code>embed_ref</code> for every insertion. If <code>NO_FORCED_IDENTITY</code> is set, however, only one record of this symbol would exist even though it may be inserted and display in many different text positions.</p>
</li>

</ul>
<h2 id='2812-tips-and-tricks'>28.12 Tips and Tricks</h2>
<p> For all user items and custom or non-supported <code>embed_ref</code>s, you must initialise at least the height of the <code>embed_ref</code> before you insert it. Otherwise, OpenPaige has no idea how tall the object is (but it will get the object&#39;s width from the <code>callback</code> function). To initialise the height, do the following:</p>
<pre><code>pg_embed_ptr embedPtr;
embedPtr = UseMemory(ref); // where &quot;ref&quot; is the newly created embed_ref
embedPtr -&gt; height = HeightOfMyItem;
UnuseMemory(ref);
</code></pre>
<p><strong>NOTE:</strong> For supported types that require no special callback function, you do not need to initialise the height - OpenPaige initialises it for you. You would only need to change the height if you wanted something other than the default.</p>
<p>If you need to create a custom <code>embed_ref</code> that requires a block of data larger than a long word, the recommended choice is to use <code>embed_user_data</code> because OpenPaige will at least store the data, present a pointer to it for your <code>callback</code>, and save/read the data for files. This minimal support assumes that nothing in your data stream needs to be de-referenced, <em>i.e.</em>, if you have pointers inside of pointers, OpenPaige has no way of knowing how to save them.</p>
<p>To create an <code>embed_ref</code> of type <code>embed_user_data</code>, pass a pointer to the data in <code>item_data</code> and the byte count in <code>modifier</code>; OpenPaige will then make a copy of the data (so you can then dispose the pointer, etc.).</p>
<p><strong>CAUTION:</strong> If you let OpenPaige store the data, you should neither alter nor dispose it. Let the default <code>callback</code> function handle the dispose (see &quot;The Callback Function”<!-- on page 28-587-->).</p>
<p>For all <code>embed_ref</code>s (both supported items and custom/user items), OpenPaige normally keeps only one <code>embed_ref</code> around and creates pointers to the original when the text is copied/pasted. If this default behavior is unworkable for any particular feature, pass <code>NOT_SHARED_FLAG</code> for the flags field in <code>pgNewEmbedRef()</code> (see “Special Cases”<!-- on page 28-599-->).</p>
<h2 id='2813-applying-to-existing-text'>28.13 Applying to Existing Text</h2>
<p>In certain cases, you might want to apply an <code>embed_ref</code> to existing characters (as a &quot;style&quot;) as opposed to inserting a new &quot;character&quot; by itself. One example of this would be to support hypertext links that apply to existing key words in the document; for such a feature, you will probably want to connect an <code>embed_ref</code> to an existing group of characters instead of inserting a new one. If this is the case, you should use the following function instead of <code>pgInsertEmbedRef</code>:</p>
<pre><code>void pgSetEmbedRef (pg_ref pg, embed_ref ref, select_pair_ptr selection, short stylesheet_option, embed_callback callback, long callback_refcon, short draw_mode);
</code></pre>
<p>This function&#39;s parameters are identical to <code>pgInsertEmbedRef()</code>, except the <code>embed_ref</code> is applied to existing text as a style. Hence, the <code>selection</code> parameter can be a pointer to a range of characters, or <code>NULL</code> if you want to apply the reference to the current text selection.</p>
<p><strong>NOTE:</strong> Relying on the default behaviour of the <code>embed_ref</code> in this case can render the text &quot;invisible&quot;. This is because the text within the specified selection becomes literally a custom style and the standard text drawing function within OpenPaige will no longer get called for those characters.</p>
<p>You can handle this by setting a callback function that responds to <code>EMBED_DRAW</code>, at which time you can call the standard text drawing function (see &quot;The Callback Function&quot;<!-- on page 28-587-->).</p>
<h2 id='2814-non-sharing-embeds'>28.14 Non-sharing Embeds</h2>
<p>By default, multiple occurrences of the same <code>embed_ref</code> are shared. For example, if you created a single <code>embed_ref</code> and inserted it as a character, subsequent copy/paste operations might duplicate the reference several times; yet, only one <code>embed_ref</code> is maintained by OpenPaige. Each copy is merely a pointer to the same (shared) memory.</p>
<p>In special cases, however, an application might need to force unique occurrences for each copy. For example, suppose the user is allowed to edit an embedded picture (such as changing its size or content). If multiple copies exist in the text, changing one of them would change the appearance of all—which may not be a desirable feature.</p>
<p>The work-around is to pass the following value in the <code>flags</code> parameter when <code>pgNewEmbedRef()</code> is called:</p>
<pre><code>#define NOT_SHARED_FLAG0x00080000 // Embed_ref not shared
</code></pre>
<p>Setting flags to this value tells OpenPaige that for each copy/paste operation, the <code>embed_ref</code> needs to be newly created. Hence, each copy will be a unique reference and not shared.</p>
<h2 id='2815-file-saving'>28.15 File Saving</h2>
<p>Unless you call the function below immediately after calling <code>pgSaveDoc</code>, <code>embed_ref</code>s contained in a document <em>do not</em> automatically get saved to an OpenPaige file:</p>
<pre><code>pg_error pgSaveAllEmbedRefs ( $\mathrm{pg}$ _ref pg, file_io_proc io_proc, file_io_proc data_io_proc, long PG_FAR *file_position, file_ref filemap);
</code></pre>
<p>This function writes all <code>embed_ref</code>s in <code>pg</code> to the file specified. The <code>pg</code>, <code>io_proc</code>, <code>file_position</code> and <code>filemap</code> are the same parameters you just gave to <code>pgSaveDoc()</code> for <code>pg</code>, <code>write_proc</code>, <code>file_position</code>, and <code>filemap</code>, respectively. The <code>data_io_proc</code> should be <code>NULL</code> (it is only used in very specialised cases).</p>
<p>This function is safe to call even if there are no <code>embed_ref</code>s contained in <code>pg</code> (if that is the case, nothing gets written to the file).</p>
<p>The reason this function is separate, as opposed to OpenPaige saving <code>embed_ref</code>s automatically, is that some OpenPaige developers will not be using the <code>embed_ref</code> extension, so the required library to handle this feature might not exist in every application.</p>
<p>For each <code>embed_ref</code> that is saved, the <code>callback</code> function will be called with <code>EMBED_WRITE_DATA</code> as the command.</p>
<p>The <code>pgSaveAllEmbedRefs</code> is to be used to save <code>embed_ref</code>s already existing in <code>pg</code>; if you have <code>embed_ref</code>s around that are not inserted anywhere, you need to save them discretely using the following function:</p>
<pre><code>pg_error pgSaveEmbedRef (pg_ref pg, embed_ref ref, long element_info, file_io_proc io_proc, file_io_proc data_io_proc, long PG_FAR *file_position, file_ref filemap);
</code></pre>
<p>The above function is similar to <code>pgSaveAllEmbedRefs</code> except a single <code>embed_ref</code> is saved to the file. The <code>element_info</code> value can be anything, and that value is returned to a read handler when the data is read later. If this function is successful, zero (<code>NO_ERROR</code>) is returned.</p>
<p><strong>NOTE:</strong> You do not need to call this function unless you need to save an <code>embed_ref</code> that you have kept around that isn&#39;t inserted into a document.</p>
<h2 id='2816-file-reading'>28.16 File Reading</h2>
<p>Since OpenPaige can not make the assumption that the <code>embed_ref</code> extension library is available in all applications, you must tell the file I/O mechanism that an OpenPaige file being read might contain <code>embed_ref</code>s. You do so by calling the following function at least once before calling <code>pgReadDoc</code>:</p>
<pre><code>void pgInitEmbedProcs (pg_globals_ptr globals, embed_callback callback, app_init_read init_proc);
</code></pre>
<p>This initialises the <code>embed_ref</code> read handler so it can process any <code>embed_ref</code> within the text stream during <code>pgReadDoc</code>. You only need to call this function once, some time after <code>pgInit</code> and before the first <code>pgReadDoc</code>.</p>
<p>The <code>callback</code> parameter should be a pointer to a callback function that you want to set, as the default callback, for all <code>embed_ref</code>s that are read. This function should either be <code>NULL</code> (for no callback) or a pointer to the same kind of function used for <code>callback</code> when inserting an <code>embed_ref</code>. The reason you need to provide this parameter when reading a file is the newly created <code>embed_ref</code>s won&#39;t have callback functions (hence there would be no way to examine the incoming data). Additionally, OpenPaige sets the <code>callback</code> given in <code>pgInitEmbedProcs</code> to become the callback for all the <code>embed_ref</code>s read from the file.</p>
<p>An <code>embed_ref</code> is read from the file and processed as follows:</p>
<ol start='' >
<li>The <code>embed_ref</code> is created and the default contents are read;</li>
<li>The callback function is called with <code>EMBED_READ_DATA</code>, giving your application a chance to append additional data that might have been saved;</li>
<li>OpenPaige walks through all the <code>style_info</code> records and attaches the <code>embed_ref</code> to all appropriate elements; for each <code>style_info</code> that contains the <code>embed_ref</code>, the callback is called once more with <code>EMBED_INIT</code>.</li>

</ol>
<p>The <code>init_proc</code> is an optional function pointer that will be called after an <code>embed_ref</code> is retrieved during file reading; the primary purpose for this function is to initialise an <code>embed_ref</code> that is not attached to the document. Normally you won&#39;t need to use this callback function so just pass <code>NULL</code>; but if for some reason you have saved an <code>embed_ref</code> discretely (using <code>pgSaveEmbedRef()</code>) and it is not applied to any character(s), the <code>init_proc</code> might be the only way you can get called back to initialise the <code>embed_ref</code> data.</p>
<p>The <code>init_proc</code> gets called immediately after an <code>embed_ref</code> has been read from a file:</p>
<pre><code>PG_PASCAL (void) init_read(paige_rec_ptr pg, memory_ref ref);
</code></pre>
<p>When <code>init_read</code> is called, the newly read <code>embed_ref</code> will be given in <code>ref</code>.</p>
<h2 id='2817-additional-support'>28.17 Additional Support</h2>
<h3 id='checking-the-cursor'>Checking the Cursor</h3>
<pre><code>embed_ref pgPtInEmbed (pg_ref pg, co_ordinate_ptr point, long PG_FAR *ext_offset, style_info_ptr associated_style, pg_boolean do_callback);
</code></pre>
<p>This function returns an <code>embed_ref</code>, if any, that contains <code>point</code>. If no <code>embed_ref</code> contains <code>point</code>, <code>MEM_NULL</code> (zero) is returned.</p>
<p>If <code>text_offset</code> is non-<code>NULL</code> and an <code>embed_ref</code> containing <code>point</code> is found, <code>*text_offset</code> is set to the text position for that <code>ref</code>. Likewise, if <code>associated_style</code> is non-<code>NULL</code>, then <code>*associated_style</code> is initialised to the <code>style_info</code> for that <code>ref</code>.</p>
<p>If <code>do_callback</code> is <code>TRUE</code>, the <code>callback</code> function for the <code>embed_ref</code> is called with <code>EMBED_CURSOR</code> command when and if the <code>point</code> is contained in an <code>embed_ref</code>. (See &quot;The Callback Function&quot;<!-- on page 28-587--> and <code>EMBED_CURSOR</code> command in &quot;Command Messages&quot;<!-- on page 28-588-->).</p>
<pre><code>embed_ref pgGetEmbedJustClicked (pg_ref pg, long drag_select_result);
</code></pre>
<p>Returns the <code>embed_ref</code> that was clicked during the last call to <code>pgDragSelect</code>. If no <code>embed_ref</code> was clicked from the last <code>pgDragSelect</code>, the function returns <code>MEM_NULL</code> (zero).</p>
<p>The <code>drag_select_result</code> should be whatever value was returned from the last call to <code>pgDragSelect</code> (which is actually how <code>pgGetEmbedJustClicked</code> knows which <code>embed_ref</code> was clicked).</p>
<h3 id='findingsearching'>Finding/Searching</h3>
<pre><code>embed_ref pgFindNextEmbed (pg_ref pg, long PG_FAR *text_position, long match_refcon, long AND_refcon);
</code></pre>
<p>This function does a search through all the <code>embed_ref</code>s in <code>pg</code> and returns the first one that matches the criteria specified. The search begins at <code>*text_position</code>. If an <code>embed_ref</code> is found, it is returned and <code>*text_position</code> is set to the text offset for that <code>ref</code>. Otherwise, <code>MEM_NULL</code> is returned and <code>*text_position</code> is set to the end of the document.</p>
<p>For example, to search for an <code>embed_ref</code> starting at the document&#39;s beginning, set a <code>long</code> to 0 and pass a pointer to it as <code>text_position</code>.</p>
<p>Essentially, the function searches for the first occurrence of an <code>embed_ref</code> whose <code>callback_refcon</code> (the value given to <code>pgInsertEmbedRef</code>) matches <code>match_refcon</code>; the callback <code>refcon</code> value in the <code>embed_ref</code> is first <code>AND</code>ed with <code>AND_refcon</code>, then compared to <code>match_refcon</code>. If the comparison is equal, that <code>embed_ref</code> is considered a true match and it is returned.</p>
<p>For example, if you wanted to find the next <code>embed_ref</code> that had a 1 set for the low-order bit of the callback refcon, you would pass 1 for both <code>match_refcon</code> and <code>AND_refcon</code>.</p>
<p>If you simply want to find the first occurrence of any <code>embed_ref</code>, pass 0 for both <code>match_refcon</code> and <code>AND_refcon</code>.</p>
<p>To find an exact, specific <code>embed_ref</code> (per value in <code>callback refcon</code>), pass that exact <code>refcon</code> value in <code>match_refcon</code> and -1 for <code>AND_refcon</code>.</p>
<pre><code>embed_ref pgGetExistingEmbed (pg_ref pg, long user_refcon);
</code></pre>
<p>Returns the <code>embed_ref</code> currently in <code>pg</code>, if any, that contains <code>user_refcon</code>. The <code>user_refcon</code> being searched for is the same value given to <code>pgNewEmbedRef</code> originally.</p>
<p><strong>NOTE:</strong> The <code>user_refcon</code> is the value that was given to <code>pgNewEmbedRef()</code>, which can be different to the <code>callback refcon</code>.</p>
<p>If one is not found that matches <code>user_refcon</code>, this function returns <code>MEM_NULL</code>.</p>
<pre><code>long pgNumEmbeds (pg_ref pg, select_pair_ptr selection);
</code></pre>
<p>Returns the total number of <code>embed_ref</code>s contained in the specified <code>selection</code> of <code>pg</code>. If <code>selection</code> is a null pointer, the current selection is used.</p>
<p>Once you know how many <code>embed_ref</code>s are present in the specified range of text, you can access individual occurrences using <code>pgGetIndEmbed</code> (<em>infra</em>).</p>
<pre><code>embed_ref pgGetIndEmbed (pg_ref pg, select_pair_ptr selection, long index, long PG_FAR *text_position, style_info_ptr associated_style);
</code></pre>
<p>Returns the <em>n</em>th <code>embed_ref</code> within the specified <code>selection</code>. If <code>selection</code> is a null pointer, the current selection is used.</p>
<p>If <code>text_position</code> <em>is not</em> a null pointer, then <code>*text_position</code> gets set to the (zero-indexed) text position of the <code>embed_ref</code>.</p>
<p>If <code>associated_style</code> is non-<code>NULL</code>, the <code>style_info</code> is initialised to the style the <code>embed_ref</code> is attached.</p>
<p>If the <code>index</code> <code>embed_ref</code> does not exist, the function returns <code>MEM_NULL</code> (and neither <code>*text_position</code> nor <code>*associated_style</code> is set to anything).</p>
<p><strong>NOTE:</strong> The <code>index</code> value is <em>one-based</em>, i.e. the first <code>embed_ref</code> is 1 (not zero).</p>
<h2 id='2818-miscellaneous-support'>28.18 Miscellaneous Support</h2>
<pre><code>long pgGetEmbedBounds (pg_ref pg, long index, select_pair_ptr index_range, rectangle_ptr bounds, short PG_FAR *vertical_pos, co_ordinate_ptr screen_extra);
</code></pre>
<p>This function returns the bounding dimensions of the <code>embed_ref</code> represented by <code>index</code> within the <code>index_range</code>; if <code>index_range</code> is NULL, the whole document is used.</p>
<p>The <code>index</code> is zero-based (first <code>embed_ref</code> in the document is zero). You can determine how many <code>embed_ref</code> exist by calling <code>pgNumEmbeds()</code>.</p>
<p>This function returns the text position of the <code>embed_ref</code> (what character it applies to relative to the 0th char); the bounding rectangle of the <code>ref</code> is returned in <code>*bounds</code> and the <code>*vertical_pos</code> parameter returns the item&#39;s <code>descent</code> value (distance from baseline to bottom).</p>
<p><strong>NOTE:</strong> Any or all of these parameters can be NULL if you don&#39;t need the information.</p>
<p>The rectangle returned in <code>*bounds</code> will be the enclosing box of the <code>embed_ref</code> <em>not</em> scrolled, i.e. where it would be on the screen, were <code>pg</code>&#39;s scroll position <code>(0, 0)</code>. If <code>screen_extra</code> is non-<code>NULL</code> then it will be set to the amount of pixels you would need to offset the bounding rectangle in order to obtain the physical location of its bounds. Hence, if you offset <code>*bounds</code> by <code>screen_extra -&gt; h</code> and <code>screen_extra -&gt; v</code> you obtain the WYSIWYG rectangle.</p>
<pre><code>long pgEmbedStyleToIndex(pg_ref pg, style_info_ptr embed_style);
</code></pre>
<p>Returns the <code>index</code> value of the <code>embed_ref</code> attached to <code>embed_style</code>, if any. This function is useful for obtaining an &quot;index number&quot; for an <code>embed_ref</code> where only the <code>style_info</code> is known. If no <code>embed_ref</code> exists for <code>embed_style</code>, zero is returned; otherwise assume the function result is the related index.</p>
<p>This <code>index</code> value can then be used for functions that require it such as <code>pgGetEmbedBounds</code>, <code>pgGetIndEmbed</code>, etc.</p>
<pre><code>void pgSetEmbedBounds(pg_ref pg, long index, select_pair_ptr index_range, rectangle_ptr bounds, short PG_FAR *vertical_pos, short draw_mode);
</code></pre>
<p>This function changes the bounding dimensions and/or the baseline position (descent) of an <code>embed_ref</code> within a document.</p>
<p>The <code>index</code> parameter specifies which <code>embed_ref</code> to change (one-indexed), and <code>index_range</code> indicates the range of text to consider. If <code>index_range</code> is <code>NULL</code> the current selection is used.</p>
<p>For example, if the current selection contained two <code>embed_ref</code>s, an index of 1 would indicate the first <code>embed_ref</code> within that selection and a 2 would indicate the second <code>embed_ref</code>. The physical order of <code>embed_ref</code>s is the order in which they appear in the text (not necessarily the order they were inserted).</p>
<p>The <code>bounds</code> rectangle indicates the <code>embed_ref</code>&#39;s new width and height. Note that width and height are taken from the rectangle dimensions—the physical top-left location of the embedded object is not altered. If <code>bounds</code> is <code>NULL</code> the <code>embed_ref</code> dimensions remain unaltered.</p>
<p>The <code>vert_pos</code> parameter should point to a value that indicates the amount of descent, in pixels, that the <code>embed_ref</code> should be drawn relative to the text baseline. This is a positive value, i.e. a value of 3 will cause the <code>embed_ref</code> to draw three pixels below the text baseline.</p>
<p>The <code>vert_pos</code> parameter can also be <code>NULL</code>, in which case the object&#39;s descent remains unchanged.</p>
<p>If <code>draw_mode</code> is non-zero, the text in <code>pg</code> (including the changes to the <code>embed_ref</code>) is redrawn.</p>
<h2 id='2819-undo-support'>28.19 Undo Support</h2>
<p>You can prepare for undoing an <code>embed_ref</code> insertion by calling <code>pgPrepareUndo()</code>, passing <code>undo_embed_insert</code> as the undo <code>verb</code>. You should do this just before inserting an <code>embed_ref</code>.</p>
<p>Otherwise, there is no specific undo support required for <code>embed_ref</code> (because after they are inserted, all the normal undo operations will work—undo for Cut, Paste, format changes, etc.).</p>
<h2 id='2820-relationship-to-style-info'>28.20 Relationship to Style Info</h2>
<p>OpenPaige stores <code>embed_ref</code>s directly in the <code>style_info</code> record. The following <code>style_info</code> fields contain <code>embed_ref</code> information (from <code>style_info</code> <code>struct</code>):</p>
<pre><code>long embed_entry; 			/* App callback rfunction for embed_refs */
long embed_style_refcon;	/* Used by embed object extension */
long embed_refcon;			/* Used by embedded object extension */
long embed_id;				/* Used by embedded object extension */
memory_ref embed_object;	/* Used by embedded object extension */
</code></pre>
<p>The callback function is stored in <code>embed_entry</code>; <code>embed_style_refcon</code> is the <code>callback</code> <code>refcon</code> and embed_refcon is the user <code>refcon</code> (see <code>refcon</code> values for <code>pgNewEmbedRef</code><!-- on page 578--> and for  <code>pgInsertEmbedRef</code><!-- on page 581-->).</p>
<p>The <code>embed_id</code> will contain a unique ID number generated by OpenPaige; this value has no direct meaning except that it is created to keep <code>style_info</code>s and <code>embed_ref</code>s from running together.</p>
<p>The <code>embed_ref</code> itself is in <code>embed_object</code>.</p>
<h2 id='2821-examples'>28.21 Examples</h2>
<h3 id='windows-example'>Windows Example</h3>
<p>The following is an example of inserting a metafile as a &quot;character&quot; into a <code>pg_ref</code>. It also shows how to prepare for an <code>Undo</code>.</p>
<pre><code>/* This function embeds a meta file into the text. The x and y extents are given in x_ext and y_ext. Note, the x and y extents should be given in device units. The user_refcon param is whatever you want it to be for application reference. The callback param will become the embed callback, or NULL if you want to use the default. */

void InsertMetafile (pg_ref pgRef, HMETAFILE meta, int x_ext, int y_ext, long user_refcon, embed_callback callback)
{
	metafile_struct metafile;
	embed_ref ref;
	void PG_FAR *the_data;
	
	/* It is a good idea to fill struct with zeros for future compatibility. */
	
	memset(&amp;objData, &#39;\O&#39;, sizeof(PAIGEOBJECTSTRUCT));
	metafile. metafile = (long)meta;
	metafile.bounds.top_left.h = metafile.bounds.top_left.v;
	metafile.bounds.bot_right.h = x_ext;
	metafile.bounds.bot_right.v = y_ext;
	metafile.mapping_mode = MM_ANISOTROPIC;
	metafile.x_ext = x_ext;
	metafile.y_ext = y_ext;
	the_data = (void PG_FAR *) &amp;metafile;
	ref = pgNewEmbedRef(&amp;mem_globals, embed_meta_file, the_data, 0, 0, 0, user_refcon, FALSE);
	pgInsertEmbedRef(pgRef, ref, CURRENT_POSITION, 0, callback, 0, best_way);
};
</code></pre>
<h3 id='macintosh-example'>Macintosh Example</h3>
<pre><code>/* The following example shows inserting a PicHandle as a &quot;character&quot;. The picture&#39;s descent (distance below baseline) is 20% of its height. We also prepare for an Undo. */

void InsertPicture (pg_ref pg, PicHandle picture)
{
	embed_ref ref;
	undo_ref undoStuff;
	
	ref = pgNewEmbedRef(&amp;mem_globals, embed_mac_pict, (void*) picture, 0, 0, (pg_fixed) 20&lt;&lt;16, 0, FALSE);
	
	undoStuff = pgPrepareUndo(pg, undo_embed_insert, NULL);
	pgInsertEmbedRef(pg, ref, CURRENT_POSITION, 0, NULL, 0, best_way);
}
</code></pre>
<h2 id='a-custom-embedref'>A Custom <code>embed_ref</code></h2>
<p>This example shows how to create and manipulate a custom <code>embed_ref</code>. In this case we are creating a simple box for which we draw a frame, and we respond in some way if the user double-clicks in this box.</p>
<p>For purposes of demonstration, we also attach a data struct to the custom <code>embed_ref</code>. While this example doesn&#39;t do anything with that data, it shows how you would save and read your data to an OpenPaige file.</p>
<pre><code>/* Insertion of a custom ref into a pg_ref &quot;pg&quot;. Upon entry, width and height define the dimensions of the box; data is a pointer to some arbitrary data structure that gets attached to the ref (and eventually saved to the OpenPaige file) and dataSize is the size of that data. The callbackProc param is a pointer to our callback function (almost mandatory for any custom embeds). The refCon value becomes the callback refcon. */

void makeCustomRef (pg_ref pg, short width, short height, char *data, long dataSize, embed_callback callbackProc, long refCon)
{
	embed_ref ref;
	pg_embed_ptr embed_ptr;
	
	/* Create a custom ref, but if we specify embed_user_data then OpenPaige will attach the data to the ref. */
	
	ref = pgNewEmbedRef(&amp;mem_globals, embed_user_data, (void*) data, dataSize, 0, 0, 0, FALSE);
	
	/* The following code is vital for a &quot;custom&quot; user type since OpenPaige has no idea how tall our embed item is, nor does it know how wide it is: */
	
	embed_ptr = UseMemory(ref); // Get the embed struct
	embed_ptr -&gt; height = height;
	embed_ptr -&gt; width = width;
	UnuseMemory(ref);

	// Insert the ref. (Also add pgPrepareUndo() here if desired). 
	pgInsertEmbedRef(pg, ref, CURRENT_POSITION, 0, callBackProc, refCon, best_way);
}

/* The following code is the callback function for the embed_ref. OpenPaige calls this with various &quot;messages&quot;. */

PG_PASCAL (long) callBackProc (paige_rec_ptr pg, pg_embed_ptr embed_ptr, long embed_type, short command, long user_refcon, long param1, long param2)
{
	memory_ref specialData;
	Rect theBox;
	char *extraBytes;
	long result = 0 ; // Default function result
	
	switch (command)
	{
		case EMBED_DRAW:
			// In this example we frame the box.
			// param1 is a rectangle_ptr of the box 
			RectangleToRect((rectangle_ptr)param1, NULL, &amp;theBox);
			FrameRect(&amp;theBox);
			break;
		case EMBED_MOUSEDOWN:
		case EMBED_MOUSEMOVE:
		case EMBED_MOUSEUP:
		case EMBED_DOUBLECLICK:
			result = pgDefaultEmbedCallback(paige_rec_ptr pg, pg_embed_ptr embed_ptr, long embed_type, short command, long user_refcon, long param1, long param2);
			if (command == EMBED_DOUBLECLICK) 
				HandleMyDoubleClick(pg, user_refcon);
				// The &quot;HandleMyDoubleClick() is whatever...
				break;
		case EMBED_DESTROY:
			/* Important note: Since our embed_ref type is embed_user_data, we can let OpenPaige dispose the data. However if we attached our own data directly we would NOT call the standard callback, or we would crash! */
			result = pgDefaultEmbedCallback(paige_rec_ptr pg, pg_embed_ptr embed_ptr, long embed_type, short command, long user_refcon, long param1, long param2);
			break;
		case EMBED_WRITE_DATA:
			/* NOTE, since our embed type is embed_user_data, OpenPaige will save that data automatically, so we don&#39;t need to do anything for this message. But purely for the sake of demonstration we will save two extra bytes to the file to show how it is done: */
			specialData = (memory_ref) param1;
			SetMemorySize(specialData, sizeof(char) * 2); 
			extraBytes = UseMemory(specialData);
			extraBytes[0] = myCustomChar1;
			extraBytes[1] = myCustomChar2;
			UnuseMemory(specialData);
			break;
			/* NOTE, since our embed type is embed_user_data, OpenPaige will read that data automatically, so we don&#39;t need to do anything for this message. But purely for the sake of demonstration we will read the two extra bytes from the file that we saved in EMBED_READ_DATA: */
			extraBytes = (char*) param1; // Pointer to data
			myCustomChar1 = extraBytes[0]; 
			myCustomChar2 = extraBytes[1]; 
			break;
		default:
			result = pgDefaultEmbedCallback(paige_rec_ptr pg, pg_embed_ptr embed_ptr, long embed_type, short command, long user_refcon, long param1, long param2);
			break;
		}
	return result;
}
</code></pre>
<h1 id='29-mail-merging'>29 MAIL MERGING</h1>
<p>&quot;Mail merging&quot; is a feature in which specific portions of text can be temporarily swapped with text from other sources. We are referring to it as &quot;mail merge&quot; because this feature is typically used to substitute special embedded symbols or fields within a document with data from a database for form letters, mailing labels, statements, etc.</p>
<h2 id='291-how-merging-works'>29.1 How merging works</h2>
<p>In OpenPaige, merging is essentially a custom style. For more about custom styles in general see &quot;Creating a simple custom style&quot;<!-- on page 30-37--> and &quot;Customizing OpenPaige&quot;<!-- on page 27-1-->. Specifically, the merge feature is accomplished as follows:</p>
<ol start='' >
<li>A merge &quot;symbol&quot; is simply a specific style (set by the application) which is applied to a portion of text. It differs from other styles simply by the existence of a merge_proc other than the default (see point 2 below). Otherwise, such &quot;symbols&quot; can be any kind of characters, words or phrases the application wishes to embed in the text stream to convey &quot;merge fields&quot;.</li>

</ol>
<p>For the sake of discussion, we shall refer to this style attribute as a merge style.</p>
<ol start='2' >
<li>A merge style must have the <code>merge_proc</code> function pointer set to an application-defined function (see &quot;<code>merge_proc</code>&quot;<!-- on page 27-13-->).</li>
<li>By itself, a merge style does nothing and text set to a merge style remains unchanged until the application calls <code>pgMergeText</code> (below). OpenPaige will then call the appropriate <code>merge_proc</code>s, at which time the application makes the decision for substituting text (or not).</li>
<li>When <code>pgMergeText</code> is called, the text for which all merge styles applied is temporarily <em>pushed</em> (saved) into an internal <code>memory_ref</code> within the OpenPaige object. Later, when the application wishes to revert from &quot;merge mode&quot;, the document can be completely restored to its original state, prior to any text substitutions.</li>

</ol>
<h2 id='sample-merge-text-proc'>Sample merge text proc</h2>
<p>This is called when the styles need to be initialized. Usually at the beginning of the program. This sets the merge style <code>proc</code>s and <code>user_id</code> and the mask makes it so only the two desired <code>proc</code>s, <code>merge_text_proc</code> and <code>setup_insert</code>, get set to our custom ones following:</p>
<pre><code>void InitMergeStyles(pg_ref pg)
{
	style_info style, mask;
	pg_style_hooks style_functions;
	pgInitStyleMask(&amp;mask, 0);
	
	style.user_id = STYLE_IS_MERGE;
	mask.user_id = -1;
	
	// The idea is to change only the styles that have pictures:
	
	InitStyleProcsToDefaults(&amp;style_functions); // Init standard procs first.
	style_functions.merge = (pg_proc) merge_text_proc;
	style_functions.insert_proc = (pg_proc) setup_insert;
	pgSetStyleProcs(pg, &amp;style_functions, &amp;style, &amp;mask, NULL, 0, STYLE_IS_MERGE, FALSE, draw_none);
}
</code></pre>
<h3 id='mail-merge-fields-are-inserted-into-text'>Mail merge fields are inserted into text</h3>
<pre><code>/* This function inserts my &quot;mail merge&quot; fields into the text. I shall use only a couple of style hooks to make this work. */

void insert_merge_fields (doc_rec *doc)
{
	style_info style, mask;
	short index, size_of_fld;
	Str255 name_of_fld;
	for (index = 0; index &lt; NUM_MERGE_FLDS; ++index)
	{
		GetIndString(name_of_fld, MERGE_STRINGS, index + 1);
		size_of_fld = name_of_fld[0];
		pgGetStyleInfo(doc -&gt; pg, NULL, FALSE, &amp;style, &amp;mask);
		pgInitStyleMask(&amp;mask, 0);
		
		// Set up everything I want in the style_info record:
		
		style.user_id = STYLE_IS_MERGE;
		style.class_bits |= (STYLE_IS_CUSTOM | GROUP_CHARS_BIT);
		style.char_bytes = 0;
		style.user_data = index;
		mask.user_id = -1;
		mask.user_data = -1;
		mask.class_bits = -1;
		mask.char_bytes = -1;

		// Set desired function pointers:

		style.procs.merge = (pg_proc) merge_text_proc;
		style.procs.insert_proc = (pg_proc) setup_insert;
		mask.procs.merge = (pg_proc) - 1;
		mask.procs.insert_proc = (pg_proc) - 1;
		pgSetStyleInfo(doc -&gt; pg, (pg_char_ptr) &amp;name_of_fld[1], size_of_fld, CURRENT_POSITION, data_insert_mode, 0, draw_none);
	}
		
	InvalRect(&amp;doc -&gt; w_ptr -&gt; portRect);
  DoAllUpdates();
}
</code></pre>
<h3 id='sample-setupinsert-hook-for-merging'>Sample <code>setup_insert</code> hook for merging</h3>
<pre><code>/* This is the hook that gets called when OpenPaige saves off the next style to apply from the next insert. The reason I need this for merge &quot;characters&quot; is because I don&#39;t want the user to &quot;type&quot; or extend text if the caret sits on one of my merge styles. Hence, this function must remove my own hooks from the style so it becomes just a regular style. */

static pascal short setup_insert (paige_rec_ptr pg, style_info_ptr style, long position)
{
	pgInitStyleProcs(&amp;style -&gt; procs);
	// This sets all the standard procs 
	style -&gt; class_bits = 0; 
	style -&gt; user_data = style -&gt; user_id = 0;
	
	return TRUE; 
	/* Won&#39;t call me again (because I just nuked my own function ptr */
}
</code></pre>
<h3 id='mergetexthook'><code>merge_text_hook</code></h3>
<pre><code>// This gets called by page to swap out text during pgMergeText.
static pascal short merge_text_proc (paige_rec_ptr pg, style_info_ptr style, pg_char_ptr text_data, pg_short_t length, text_ref merged_data, long ref_con)
{
	short field_size
	char *str_to_merge;
	field_size = *merge_text[style -&gt; user_data];
	if (!merged_data)
		return TRUE;
	SetMemorySize (merged_data, field_size);
	if (!field_size)
		return TRUE;
	str_to_merge = (char*) merge_text[style -&gt; user_data];
	++str_to_merge;
	BlockMove(str_to_merge, UseMemory(merged_data), field_size);
	UnuseMemory(merged_data);
	return TRUE;	
}
</code></pre>
<h2 id='292-merge-mode'>29.2 Merge mode</h2>
<p>Assuming all your merge styles have been set up (all the desired merge areas have a <code>merge_proc</code> set in their <code>style_info</code> record), placing the OpenPaige object in &quot;merge mode&quot; is accomplished by calling the following:</p>
<pre><code class='language-c' lang='c'>(pg_boolean) pgMergeText (pg_ref pg, style_info_ptr matching_style, style_info_ptr mask, style_info_ptr AND_mask, long ref_con, short draw_mode);
</code></pre>
<p>For every <code>style_info</code> that matches a specified criteria (based on the contents of <code>matching_style</code>, <code>mask</code> and <code>AND_mask</code> as described below), has its <code>merge_proc</code> called, at which time text can be substituted in place of the text that currently exists for each style involved.</p>
<p>Before any text is substituted, however, the &quot;old&quot; text is saved temporarily within the OpenPaige object. This is intended to allow the application to &quot;revert&quot; to the original document at some later time.</p>
<p>Styles that are affected by this call (in which the <code>merge_proc</code> gets called) are determined on the following bases:</p>
<ul>
<li>The fields in each <code>style_info</code> record in OpenPaige is compared to each field in <code>matching_style</code> if the corresponding field in <code>mask</code> is non–zero.</li>
<li>Before the comparison, the corresponding field in <code>AND_mask</code> is temporarily <code>AND</code>&#39;d with the target <code>style_info</code> field in OpenPaige before it is compared.</li>
<li>If all fields that are checked in this way match exactly, the style is &quot;accepted&quot; and the <code>merge_proc</code> gets called.</li>

</ul>
<p>Any of the three comparison styles — <code>matching_style</code>, <code>mask</code> and <code>AND_mask</code> can be null pointers to control the comparison procedure, in which case the following occurs:</p>
<ul>
<li>If <code>matching_style</code> is null, then all styles in <code>pg</code> are considered &quot;valid&quot; with no comparisons made, hence all <code>merge_proc</code>s are called.</li>
<li>If mask is null, all fields in each style are compared to <code>matching_style</code> (none are skipped).</li>
<li>If <code>AND_mask</code> is null, no <code>AND</code> occurs before the field comparisons (instead, the fields are compared as-is).</li>

</ul>
<p>Using the various combinations of <code>matching_style</code>, <code>mask</code> and <code>AND_mask</code>, you can selectively &quot;merge&quot; various styles based on a nearly infinite set of criteria.</p>
<p>The <code>ref_con</code> parameter can be anything; this value gets passed to the <code>merge_proc</code>.</p>
<p><strong>NOTE:</strong> The <code>MERGE_MODE_BIT</code> will be set in <code>pg</code>&#39;s attributes when the document has been &quot;merged&quot; in the above fashion.</p>
<p>You can check the attributes using <code>pgGetAttributes</code>.</p>
<p><strong>FUNCTION RESULT:</strong> This function returns <code>TRUE</code> if anything merged at all; <code>FALSE</code> is returned if no text has been substituted from any <code>merge_proc</code> (hence the document remains unchanged).</p>
<h5 id='notes-29'>NOTES</h5>
<ol start='' >
<li>If you intend to revert to the original document using <code>pgRestoreMerge</code> <em>infra</em>, you must not insert any new text or allow any kind of editing by the user until you revert. It is OK, however, to do multiple <code>pgMergeText</code> calls before reverting the document.</li>
<li>The original document is saved only once; subsequent <code>pgMergeText</code> calls will not save the merge styled text again. Hence, you can make multiple <code>pgMergeText</code> calls before reverting, then <code>pgRestoreMerge</code> will revert the document to its state before the first merge.</li>
<li>Even if you intend not to revert the text, you need to call <code>pgRestoreMerge</code> anyway, otherwise a memory leak can result.</li>

</ol>
<h3 id='restore-merge'>Restore merge</h3>
<pre><code>(void) pgRestoreMerge (pg_ref pg, pg_boolean revert_original, short draw_mode);
</code></pre>
<p>This function &quot;reverts&quot; <code>pg</code> to its original state, prior to the first <code>pgMergeText</code> call if <code>revert_original == TRUE</code>.</p>
<p>If <code>revert_original == FALSE</code>, the previous text that has been saved within <code>pg</code> is simply disposed and the document is not reverted. The purpose of this parameter is to allow a document to &quot;convert&quot; to a merged state, but to keep it that way.</p>
<p>If <code>draw_mode</code> is non–zero, <code>pg</code> is re–displayed. <code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none,		// Do not draw at all 
best_way,			// Use most efficient method(s) 
direct_copy,	// Directly to screen, overwrite 
direct_or,		// Directly to screen, &quot;OR&quot; 
direct_xor,		// Directly to screen, &quot;XOR&quot; 
bits_copy,		// Copy offscreen 
bits_or,			// Copy offscreen in &quot;OR&quot; mode 
bits_xor			// Copy offscreen in &quot;XOR&quot; mode
</code></pre>
<p>This function only needs to be called once, even after multiple <code>pgMergeText</code> calls. Once you have reverted, however, a subsequent call to <code>pgRestoreMerge</code> will do nothing (unless you have done another <code>pgMergeText</code>).</p>
<p>This function also clears the <code>MERGE_MODE_BIT</code> from <code>pg</code>&#39;s attributes.</p>
<p>NOTE: Even if you do not wish to revert the text, you should call <code>pgRestoreMerge</code> anyway (with <code>revert_original</code> as <code>FALSE</code>) if anything has merged to dispose the saved text.</p>
<h3 id='show-merged-items'>Show Merged Items</h3>
<pre><code class='language-c' lang='c'>{
	init_merge_strings();
	if (pgGetAttributes(doc -&gt; pg) &amp; MERGE_MODE_BIT)
	{
		pgSetHiliteStates(doc -&gt; pg, no_change_verb, activate_verb, FALSE);
		pgRestoreMerge(doc -&gt; pg, TRUE, draw_none);
	}
	else
	{
		pgMergeText(doc -&gt; pg, NULL, NULL, NULL, 0, draw_none);
		pgSetHiliteStates(doc -&gt; pg, no_change_verb, deactivate_verb, FALSE);
	}
	InvalRect(&amp;doc -&gt; w_ptr -&gt; portRect);
	DoAllUpdates();
}

</code></pre>
<h3 id='tech-note-styleiscustom-bit-set-incorrectly'>TECH NOTE: <code>STYLE_IS_CUSTOM</code> bit set incorrectly</h3>
<blockquote><blockquote><p>I looked into your code and found that you are correct that setting up the <code>style_info</code> record is the problem. You need to <em>remove</em> the <code>class_bits</code> setting, <code>STYLE_IS_CUSTOM</code>. That&#39;s what is forcing the merge field to not draw.</p>
</blockquote>
</blockquote>
<p><code>STYLE_IS_CUSTOM</code> tells OpenPaige that only your app knows how to draw the style and measure its characters. Hence, if you call the standard draw/measure functions (which you are), they will <em>do nothing</em>. I not only noticed the fields were invisible, on my machine, but the char widths would result in random garbage text sizes (which is <em>correct</em> since the standard measuring does nothing for <code>STYLE_IS_CUSTOM</code>).</p>
<p>Technically, the style is not &quot;custom&quot; at all—it has regular text chars and it draws like any other text. By strict definition, a <code>STYLE_IS_CUSTOM</code> means OpenPaige can&#39;t understand the &quot;text&quot; stream, such as an embedded <code>PicHandle</code> or <code>ControlHandle</code>, etc.</p>
<h3 id='tech-note-merge-fields-and-blank-lines'>TECH NOTE: Merge fields and blank lines</h3>
<p>Regarding merge fields and blank lines (and how to remove them) in items like addresses, I am not sure I have a perfect answer for that. I don&#39;t think you dare try deleting anything from within a hook, you will probably get a debugger break (because <code>memory_ref</code>s for the text and styles will be locked and &quot;in use&quot;).</p>
<p>The only thing I can think of is to detect this situation and, after all is merged, go back and delete the &quot;blank lines&quot;.</p>
<p><strong>CAUTION:</strong> If you do this, I am not sure <code>pgRestoreMerge</code> will work correctly, because it assumes you have not edited the document.</p>
<p>We had another customer doing extensive altering of a merged document for similar reasons, and he had to simply restore the original doc without using <code>pgRestoreMerge</code>. Rather, he would copy the document and then do <code>pgUndo</code>.</p>
<h3 id='tech-note-restore-all-not-yet-implemented-and-the-work-around'>TECH NOTE: Restore-all not yet implemented and the work-around</h3>
<p>If I understand you correctly, the reason you need to throw away each document and reread it—as opposed to relying on &quot;restore merge&quot; feature—is due to your extra editing of the document and the fact that &quot;restore merge&quot; just restores the merge styles.</p>
<p>The supreme work-around would be, of course, for us to add &quot;restore all&quot; to the merge features—which, incidentally, is not a bad idea. Sooner or later, someone else will encounter the same problem. <!-- TO DO: for the future --></p>
<p>In the meantime (since that feature is not currently available in <code>pgMerge</code>), I would suggest starting with a single <code>pg_ref</code>, as you are now, but use <code>pgCopy</code> to duplicate the doc, given that <code>pgCopy</code> can produce what you thought <code>pgDuplicate</code> did.</p>
<p>Here are some precautions/hints:</p>
<ul>
<li>To duplicate a whole document, simply use <code>pgCopy</code> with a selection parameter for whole text range. (Remember that <code>pgCopy</code> returns a new <code>pg_ref</code>—which is exactly what you want).</li>
<li>You might have a problem displaying the copied <code>pg_ref</code>; I do not believe the exact <code>vis</code> and <code>page</code> areas are copied. In that case you might need to set those shapes before drawing (or printing) the merged document. I would get the shape(s) from the master document then do <code>pgSetAreas</code> to the copy. Even faster would be to get the master shapes once at the beginning, with <code>pgGetAreas</code>, then set them for each merge.</li>
<li>I do know for sure that a copied <code>pg_ref</code>, from <code>pgCopy</code>, will have no <code>graf_device</code> associated with it. I do not know if this is a problem if you intend to print, since <code>pgPrintPage</code> accepts a <code>graf_device</code> (which would be a print port). But if you need to draw the merged doc to a window, you will need to set a window port using <code>pgSetDefaultDevice</code>, <strong>or</strong> you will need to specify a <code>graf_device_ptr</code> in <code>pgDisplay</code>. Otherwise, the drawing will be &quot;invisible&quot; and you will think you are going crazy. I believe our manual explains this (if not, I will be happy to provide more details).</li>
<li>In OpenPaige&#39;s current stage, I do not believe anyone has yet to display (or print) a copied <code>pg_ref</code> returned from <code>pgCopy</code>. Usually, they just paste with it. In that case, you may have unforeseen problems. However, all such cases (other than the precautions listed above) I would consider a bug, so be sure to let us know so the problem(s) can be corrected. We will make sure that a copied <code>pg_ref</code> displays correctly, one way or the other.</li>
<li>You may encounter some slowness with this work-around. However, that will probably improve during future updates.</li>

</ul>
<h1 id='30-advanced-styles'>30 ADVANCED STYLES</h1>
<p>This chapter unveils all of the style and font setting abilities within OpenPaige. For easier and quicker implementation of style setting, you will want to look at &quot;Style Basics&quot;<!-- on page 8-1-->.</p>
<p><strong>NOTE:</strong> As used in this chapter, the term <em>font</em> generally refers only to a typeface, or typeface name, unlike a Windows &quot;font&quot; that defines the whole composite format of text. OpenPaige considers a <em>font</em> to simply be a specific family such as Times, Courier, Helvetica, etc. while distinguishing other formatting properties such as bold, italic, underline, etc. as the text <em>style</em>.</p>
<h2 id='301-data-structures'>30.1 Data Structures</h2>
<p>For the sake of clarity and easier implementation of text formatting, the exact structure definitions and descriptions for style, font and paragraph formats are given at the end of this section. While you will need to set up these structures to effectively change text styles, they have been placed at the end for easier reference.</p>
<p>To understand the functions, however, let it suffice to declare the type for each of the four formats, as follows:</p>
<figure class='table-figure'><table>
<thead>
<tr><th style='text-align:left;' >Record Type</th><th style='text-align:left;' >Pointer (to the record)</th><th style='text-align:left;' >Description</th></tr></thead>
<tbody><tr><td style='text-align:left;' ><code>style_info</code></td><td style='text-align:left;' ><code>style_info_ptr</code></td><td style='text-align:left;' >Structure defining a style</td></tr><tr><td style='text-align:left;' ><code>font_info</code></td><td style='text-align:left;' ><code>font_info_ptr</code></td><td style='text-align:left;' >Structure defining a font</td></tr><tr><td style='text-align:left;' ><code>par_info</code></td><td style='text-align:left;' ><code>par_info_ptr</code></td><td style='text-align:left;' >Structure defining paragraph format</td></tr><tr><td style='text-align:left;' ><code>style_run</code></td><td style='text-align:left;' ><code>style_run_ptr</code></td><td style='text-align:left;' >Structure designating a style run.º</td></tr></tbody>
</table></figure>
<p>º A series of <code>style_run</code> records is maintained by OpenPaige to define all the style changes and associated text offsets. This record is much smaller than either <code>style_info</code> or <code>par_info</code>, thus requiring only one <code>style_info</code> record for every identical style change throughout the text and one <code>par_info</code> record for every identical paragraph format throughout the text. The <code>style_run</code> record is defined at the end of this section; most of the time you will not need to access <code>style_run</code>s.</p>
<h2 id='302-more-about-style-runs'>30.2 More About Style Runs</h2>
<p>For both <code>style_info</code> and <code>par_info</code> changes throughout the text, OpenPaige maintains a list of <code>style_run</code> records. There is one <code>style_run</code> array for <code>style_info</code> changes and one array for <code>par_info</code> changes.</p>
<p>The last element in a <code>style_run</code> array is a &quot;dummy&quot; entry whose offset field will be greater than the total text size of the <code>pg_ref</code>. For example, if the total text size of a <code>pg_ref</code> is 100 bytes, the final element in the array of <code>style_run</code> records will contain a value in <code>style_run.offset</code> of &gt; 100.</p>
<h2 id='303-style-basics'>30.3 Style Basics</h2>
<p>To simply set a style, font, size or paragraph format, see &quot;Style Basics&quot;<!-- on page 8-1-->. The following information is for those developers wanting more precise control of style, font and paragraph format setting.</p>
<h2 id='304-changing-fonts-and-styles-together'>30.4 Changing Fonts and Styles together</h2>
<p>This sets the font and style at the same time.</p>
<pre><code class='language-c' lang='c'>(void) pgSetStyleAndFont (pg_ref pg, select_pair_ptr selection, style_info_ptr the_style, style_info_ptr style_mask, font_info_ptr font, font_info_ptr font_mask, short draw_mode);
</code></pre>
<p><code>selection</code> — parameter defines the range of text that should be changed; alternatively, if you pass a null pointer, the current selection range (or insertion point) in <code>pg</code> is changed.</p>
<p>If you do give a pointer to <code>selection</code>, it must point to the following structure:</p>
<pre><code>typedef struct
{
	long begin; // Beginning offset of some text portion
	long end; // Ending offset of some text portion
}
select_pair, *select_pair_ptr;
</code></pre>
<ul>
<li><p><code>begin</code> field of a <code>select_pair</code> — defines the beginning text offset and the end field defines the ending offset. Both offsets are byte offsets, not character offsets. Text offsets in OpenPaige are zero-indexed (first offset is zero).</p>
</li>
<li><p><code>info</code> and <code>mask</code> — parameters must point to <code>style_info</code> records; <code>info</code> is the new style to apply to the text and <code>mask</code> defines which of the <code>info</code> fields to apply. For every non–zero field in <code>mask</code>, the corresponding field in <code>info</code> gets applied to the text.</p>
</li>
<li><p><code>mask</code> — parameter allows only partial style changes, which is almost always what you want to accomplish. For instance, if the user highlighted some text and changed it to <strong>bold</strong>, all you want to change in the text range is the <strong>bold</strong> attribute, not anything else such as colour, leading, or any other formatting. To do so, you would set <code>info</code>&#39;s <code>style</code> element for <strong>bold</strong> and the same field in <code>mask</code> to non–zero.</p>
</li>
<li><p><code>font</code> and <code>font_mask</code> — is almost identical to the similar <code>style</code> parameters, except in that a <code>font_info</code> record is used for <code>font</code> and <code>font_mask</code>.</p>
</li>
<li><p><code>info</code>, <code>mask</code>, <code>font</code> and <code>font_mask</code> — None of these can be a null pointer.</p>
</li>
<li><p><code>draw_mode</code> — parameter indicates whether or not to redraw the text once the style has changed: if <code>draw_mode</code> is non–zero, that drawing mode is used to redisplay the text. </p>
</li>
<li><p>If <code>draw_mode</code> is non–zero, <code>pg</code> is re–displayed. <code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none,		// Do not draw at all 
best_way,			// Use most efficient method(s) 
direct_copy,	// Directly to screen, overwrite 
direct_or,		// Directly to screen, &quot;OR&quot; 
direct_xor,		// Directly to screen, &quot;XOR&quot; 
bits_copy,		// Copy offscreen 
bits_or,			// Copy offscreen in &quot;OR&quot; mode 
bits_xor			// Copy offscreen in &quot;XOR&quot; mode
</code></pre>
<p>OpenPaige will only re–draw the text, however, if it is appropriate: if nothing changed (same styles applied as already exist), the text is not drawn, nor is it drawn if the new style applies only to an insertion point.</p>
<p><strong>NOTE:</strong> The <code>mask</code> fields that indicate what to change must be set to <code>-1</code> (all ones). The reason is that the internal comparison function—which checks the mask settings—does one word at a time, hence the fields longer than 16 bits will not change correctly.</p>
</li>

</ul>
<h3 id='preparing-openpaige-formats-from-a-logfont-windows'>Preparing OpenPaige formats from a <code>LOGFONT</code> (Windows)</h3>
<pre><code class='language-c' lang='c'>/* The following example function converts a LOGFONT into a font_info, style_info and &quot;mask&quot; record that can be given to pgSetStyleInfo(): */

static void convert_log_font (pg_ref pg, pg_globals_ptr paige_globals, LOGFONT PG_FAR *log_font, font_info_ptr font, style_info_ptr style, style_info_ptr stylemask)
{
	// Initialise the style to OpenPaige default:
	*style = paige_globals -&gt; def_style;
	// Initialise other structs to zeros or -1&#39;s, etc.:
	pgFillBlock(font, sizeof(font_info), 0);
	pgFillBlock(stylemask, sizeof(style_info), 0);
	pgFillBlock(stylemask -&gt; styles, MAX_STYLES * sizeof(short), -1);
	stylemask -&gt; point = (pg_fixed) - 1;
	CToPString(log_font -&gt; IfFaceName, font -&gt; name);
	// (OpenPaige wants a pascal string)
	font -&gt; family_id = log_font -&gt; IfPitchAndFamily;
	font -&gt; machine_var[PG_OUT_PRECISION] = log_font -&gt; IfOutPrecision;
	font -&gt; machine_var[PG_CLIP_PRECISION] = log_font -&gt; IfClipPrecision;
	font -&gt; machine_var[PG_QUALITY] = log_font -&gt; IfQuality;
	font -&gt; machine_var[PG_CHARSET] = log_font -&gt; IfCharSet;
	
	if ((style -&gt; point = (pg_fixed)log_font -&gt; IfHeight) &lt; 0) 
		style -&gt; point = -style -&gt; point;
	style-&gt;point &lt;&lt;= 16; // Make sure point size is 0x000n0000
	// Convert pointsize to fit the screen resolution 
	style-&gt;point = pgScreenToPointsize (pg, style-&gt;point);
  if (log_font -&gt; IfWeight == FW_BOLD)
    style -&gt; styles[bold_var] = -1;
  if (log_font -&gt; IfItalic)
    style -&gt; styles[italic_var] = -1;
  if (log_font -&gt; IfUnderline)
    style -&gt; styles[underline_var] = -1;
  if (log_font -&gt; IfStrikeOut)
    style -&gt; styles[strikeout_var] = -1;
}
</code></pre>
<h2 id='305-easier-mask-setups'>30.5 Easier &quot;Mask&quot; Setups</h2>
<h3 id='masks'>Masks</h3>
<p>The easiest way to initialise a <code>style_info</code>, <code>font_info</code>, or <code>par_info</code> record for a &quot;mask&quot; is to call one of the following:</p>
<pre><code class='language-c' lang='c'>(void) pgInitStyleMask (style_info_ptr mask, short filler);
(void) pgInitFontMask (font_info_ptr mask, short filler);
(void) pgInitParMask (par_info_ptr mask, short filler);
</code></pre>
<p>These function fill <code>mask</code> with <code>filler</code>.</p>
<p>To set a section of text to a style, call the following:</p>
<pre><code class='language-c' lang='c'>(void) pgSetStylelnfo (pg_ref pg, select_pair_ptr selection, style_info_ptr info, style_info_ptr mask, short draw_mode);
</code></pre>
<p><code>selection</code> defines the range of text that should be changed; alternatively, if you pass a null pointer, the current selection range (or insertion point) in <code>pg</code> is changed.</p>
<p>If you do give a pointer to <code>selection</code>, it must point to the following structure:</p>
<pre><code class='language-c' lang='c'>typedef struct
{
	long begin; // Beginning offset of some text portion
	long end; // Ending offset of some text portion
}
select_pair, *select_pair_ptr;
</code></pre>
<ul>
<li><p><code>begin</code> and <code>end</code> fields of a <code>select_pair</code> — define the beginning and ending text position. Both values are byte positions (not necessarily character positions, e.g. multilingual text can have double-byte characters, etc.). Text positions in OpenPaige are zero-indexed (first offset is zero).</p>
</li>
<li><p><code>info</code> and <code>mask</code> — must point to <code>style_info</code> records; <code>info</code> is the new style to apply to the text and <code>mask</code> defines which of the <code>info</code> fields to apply. For every non–zero field in <code>mask</code>, the corresponding field in <code>info</code> gets applied to the text.</p>
</li>
<li><p><code>mask</code> — allows only partial style changes, which is almost always what you want to accomplish. For instance, if the user highlighted some text and changed it to <strong>bold</strong>, all you want to change in the text range is the <strong>bold</strong> attribute, not anything else such as colour, leading, or any other formatting. To do so, you would set <code>info</code>&#39;s <code>style</code> element for bold and the same field in <code>mask</code> to non–zero. </p>
<p>Neither <code>info</code> nor <code>mask</code> can be a null pointer.</p>
</li>
<li><p><code>draw_mode</code> — indicates whether or not to redraw the text once the style has changed: if <code>draw_mode</code> is non–zero, that drawing mode is used to re–display the text. <code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none,		// Do not draw at all 
best_way,			// Use most efficient method(s) 
direct_copy,	// Directly to screen, overwrite 
direct_or,		// Directly to screen, &quot;OR&quot; 
direct_xor,		// Directly to screen, &quot;XOR&quot; 
bits_copy,		// Copy offscreen 
bits_or,			// Copy offscreen in &quot;OR&quot; mode 
bits_xor			// Copy offscreen in &quot;XOR&quot; mode
</code></pre>
<p>HERMES Paige will only redraw the text, however, if it is appropriate: if nothing changed (same styles applied as already exist), the text is not drawn, nor is it drawn if the new style applies only to an insertion point.</p>
</li>

</ul>
<p><strong>NOTE:</strong> The <code>mask</code> fields that indicate what to change must be set to <code>-1</code> (all ones). The reason is that the internal comparison function—which checks the mask settings—does one word at a time. Hence, the fields longer than 16 bits will not change correctly.</p>
<p><strong>NOTE:</strong> To convert a <code>LOGFONT</code> into a <code>style_info</code> and <code>mask</code> on <strong>Windows</strong>, see code example earlier in this chapter.</p>
<h3 id='set-some-text-to-bold-macintosh'>Set some text to &quot;bold&quot; (Macintosh)</h3>
<pre><code>/* This function sets the current selection to Bold (Macintosh) */
void set_to_bold (pg_ref pg)
{
	style_info mask, info;
	pgInitStyleMask(&amp;info, 0); // Sets all to zero
	pgInitStyleMask(&amp;mask, 0); // Sets all to zero
	info.styles[bold_var] = -1; // sets styles[bold_var] to force bold
	mask.styles[bold_var] = -1;
	pgSetStyleInfo(pg, NULL, \&amp;info, \&amp;mask, best_way);
}
</code></pre>
<!-- Talk about OpenType Variations here -->
<p>While the styles each contain <code>short</code>s to indicate bold, italic, etc., this is generally done for future expansion. When OpenPaige was designed, new fonts were being created which would use &quot;degrees of boldness&quot;, etc. Generally, this is not implemented in OpenPaige 1.0 for Mac and Windows except for the following style elements:</p>
<ul>
<li><p><code>style_info -&gt; styles[small_caps_var]</code> — The value in this style element indicates a percentage of the original point size to display lower case characters that get converted to ALL CAPS. Or, if this value is -1 , the default is used (which is 75% of the original style).</p>
<p>For example, if <code>style_info -&gt; styles[small_caps_var]</code> is 50 and <code>style_info</code> point size is 24, the lower case text is converted to uppercase 12 point; if <code>style_info -&gt; styles[small_caps_var]</code> is -1, the lower case text is converted to 18 (which is 75% of 24).</p>
</li>
<li><p><code>style_info-&gt;styles[relative_point_var]</code> — The value in this style element indicates a point size to display the text which is a ratio relative to 12 point times the original point size. The ratio is computed as: <code>style_info -&gt; styles[relative_point_var] / 12</code>. (The &quot;original point size&quot; is taken from the <code>point</code> field in <code>style_info</code>).</p>
<p>For example, if <code>style_info -&gt; styles[relative_point_var]</code> is 6 and the original point size is 12, the point size that displays is <code>12 * (6/12) = 6</code> point. If <code>style_info -&gt; styles[relative_point_var]</code> is 6 and the original point size is 24, the point size that displays is <code>24 * (6/12)= 12</code> point.</p>
<p><strong>NOTE:</strong> The relative_point_var element must not be &quot;-1&quot; as there is no default.</p>
</li>
<li><p><code>style_info -&gt; styles[super_impose_var]</code> — If non–zero, the value represents a stylesheet ID that gets &quot;superimposed&quot; over the existing style. What this means is all fields in the stylesheet <code>style_info -&gt; styles[super_impose_var]</code> that are non–zero are temporarily forced into <code>style_info</code> to form a composite style of both.</p>
<p>For example, if <code>style_info -&gt; styles[super_impose_var]</code> record had all fields set to zero <em>except for</em> the <code>bold_var</code> element, the resulting style would be whatever the original <code>style_info</code> contained but with <strong>boldface</strong> text.</p>
<p><code>style_info-&gt;styles[super_impose_var]</code> can only be zero or a positive number representing a stylesheet ID that actually exists in the <code>pg_ref</code>.</p>
</li>

</ul>
<p>See the chapter &quot;Style Sheets&quot;<!-- on page 31-1--> for more information.</p>
<h2 id='insertion-point-changes'>Insertion Point Changes</h2>
<p>If <code>pgSetStyleInfo</code> is called and the specified selection is a single insertion point, the style change occurs on the next <code>pgInsert</code>. Furthermore, a processed mouse-click for change of selection invalidates the style_info set to the previous insertion point (i.e., the new style setting is lost).</p>
<p><strong>Exception:</strong> Applying a style to a completely empty <code>pg_ref</code> forces that <code>style_info</code> to become the default style for that <code>pg_ref</code>.</p>
<p>The point field in <code>style_info</code> is a <code>Fixed</code> type value, i.e. the integral part of the point size is the high-order word and the fractional part is the low-order word. For example, 12 point is <code>(pg_fixed) (12&lt;&lt;16)</code> or <code>0x000C0000</code>.</p>
<h3 id='tech-note-changing-point-size'>TECH NOTE: Changing point size</h3>
<blockquote><p>I am having some difficulty in setting the point size of the font within OpenPaige.</p>
</blockquote>
<p>Your code doesn&#39;t work because the point size in <code>style_info</code> is a <code>Fixed</code> value, which means the whole-number point size needs to be in the high-order word—and you&#39;re just setting a long integer (which is putting it in the low-order word). You must have skipped quite a few OpenPaige versions because that change has been there for a while.</p>
<p>So, your code is fine <em>except</em> you need to put the point size in the high-order word, and it will work. Something like:</p>
<pre><code>theStyle. point = fontSize;
theStyle.point &lt;&lt;= 16;
</code></pre>
<p>In case you&#39;re curious, OpenPaige only looks at the high-word of the point size, so setting only the low word results in &quot;zero point&quot;, i.e., the default—12 point—which is why it never changed.</p>
<h2 id='307-changing-fonts'>30.7 Changing Fonts</h2>
<p>Changing the font applied to text range(s) requires a separate function call since fonts are maintained separate from text styles within a <code>pg_ref</code>.</p>
<p><strong>NOTE:</strong> As used in this chapter, the term <em>font</em> generally refers only to a typeface, or typeface name, unlike a Windows &quot;font&quot; that defines the whole composite format of text. OpenPaige considers a <em>font</em> simply to be a specific family such as Times, Courier, Helvetica, etc. while distinguishing other formatting properties such as bold, italic, underline, etc. as the text <em>style</em>.</p>
<p>To set a section of text to a new font, call the following:</p>
<pre><code class='language-c' lang='c'>(long) pgSetFontInfo (pg_ref pg, select_pair_ptr selection, font_info_ptr info, font_info_ptr mask, short draw_mode);
</code></pre>
<p>This function is almost identical to <code>pgSetStyleInfo</code> except in that a <code>font_info</code> record is used for <code>info</code> and <code>mask</code>.</p>
<ul>
<li><p><code>selection</code> and <code>draw_mode</code> — are functionally identical to the same parameters in <code>pgSetStyleInfo</code>. The same rules apply regarding insertion points versus selection range(s).</p>
</li>
<li><p><code>draw_mode</code> can be the values as described in <a href='#draw-modes'>Draw Modes</a> under section 2.11:</p>
<pre><code>draw_none,		// Do not draw at all 
best_way,			// Use most efficient method(s) 
direct_copy,	// Directly to screen, overwrite 
direct_or,		// Directly to screen, &quot;OR&quot; 
direct_xor,		// Directly to screen, &quot;XOR&quot; 
bits_copy,		// Copy offscreen 
bits_or,			// Copy offscreen in &quot;OR&quot; mode 
bits_xor			// Copy offscreen in &quot;XOR&quot; mode
</code></pre>
<p>&nbsp;</p>
</li>

</ul>
<p>Detailed information on <code>font_info</code> records—and what fields you should set up—is available at the end of this section. There is one important one you should be sure to set correctly, however: <code>environs</code>.</p>
<p>When you set a <code>font_info</code> record, only the <code>name</code> and <code>environs</code> fields should be changed; this is because OpenPaige initialises all the other fields when the font is applied to a <code>pg_ref</code>.</p>
<p>For <strong>Macintosh</strong> version, the <code>font_info.name</code> should be a <code>pascal</code> string terminated with the remaining bytes in <code>font_info.name</code> set to zero; the <code>font_info.environs</code> field should likewise be set to zero. For an example, read on.</p>
<p>For <strong>Windows</strong> version, the <code>font_info.name</code> can be initially set to either a <code>pascal</code> string or a <code>cstring</code>, with all remaining bytes in <code>font_info.name</code> set to zero. Usually, due to Windows programming conventions, you will set the name to a <code>cstring</code>. In this case, before passing the <code>font_info</code> record to <code>pgSetFontInfo</code>, you must set <code>font_info.environs</code> to <code>NAME_IS_CSTR</code> (see following example).</p>
<p><strong>CAUTION:</strong> On Windows, OpenPaige converts <code>font_info.name</code> to a <code>pascal</code> string and clears the <code>NAME_IS_CSTR</code> bit when the font is stored in the <code>pg_ref</code>. This is done purely for cross-platform portability. This is important to remember, because if you examine the font thereafter with <code>pgGetFontInfo</code>, the font name will now be a <code>pascal</code> string (the first byte indicating the string length), not a <code>cstring</code>.</p>
<h3 id='setting-fontinfo-windows'>Setting font_info (Windows)</h3>
<pre><code class='language-c' lang='c'>/* This example assumes we got a &quot;LOGFONT&quot; struct from a ChooseFont dialog or  similar. */

LOGFONT log;
font_info font, mask;
pgFillBlock(&amp;font, sizeof(font_info), 0); // clear all to zeros
pgFillBlock(&amp;mask, sizeof(font_info), -1); // Set to all 1&#39;s lstrcpy((LPSTR)font.name, log.IfFaceName);

/* IMPORTANT! The following line is an absolute MUST or your code will fail: */

font_info.environs |= NAME_IS_CSTR;

/* Apply to the text: */

pgSetFontInfo(pg, NULL, &amp;font, &amp;mask, best_way);

</code></pre>
<h3 id='responding-to-font-menu-macintosh'>Responding to font menu (Macintosh)</h3>
<pre><code class='language-c' lang='c'>/* In this example, we assume a &quot;Font&quot; menu whose MenuHandle is FontMenu, and &quot;item&quot; is the menu item selected by the user. */

font_info font, mask;
pgFillBlock(&amp;font, sizeof(font_info), 0); // clear all to zeros
pgFillBlock(&amp;mask, sizeof(font_info), -1); // Set to all 1&#39;s
GetItem(FontMenu, item, (StringPtr)font.name);
pgSetFontInfo(pg, NULL, &amp;font, &amp;mask, best_way);
</code></pre>
<h2 id='308-obtaining-current-text-formats'>30.8 Obtaining Current Text Format(s)</h2>
<pre><code class='language-c' lang='c'>(long) pgGetStyleInfo (pg_ref pg, select_pair_ptr selection, pg_boolean set_any_match, style_info_ptr info, style_info_ptr mask);
(long) pgGetParInfo (pg_ref pg, select_pair_ptr selection, pg_boolean set_any_match, par_info_ptr info, par_info_ptr mask);
(long) pgGetFontInfo (pg_ref pg, select_pair_ptr selection, pg_boolean set_any_match, font_info_ptr info, font_info_ptr mask);
</code></pre>
<p>The three functions above return information for a specific range of text about its style or paragraph format, or font, respectively.</p>
<p>For all functions, if selection is a null pointer, the information that is returned applies to the current selection range in <code>pg</code> (or the current insertion point); if selection is non–null, pointing to <code>select_pair</code> record, information is returned that applies to that selection range (see &quot;Copying and Deleting&quot;<!-- on page 5-1--> for information about <code>select_pair</code> pointer under <code>pgGetStyleInfo</code>).</p>
<p>Both <code>info</code> and <code>mask</code> must point to a <code>style_info</code>, <code>par_info</code>, or <code>font_info</code> record; neither of the former can be a null pointer. When the function returns, both <code>info</code> and <code>mask</code> will be filled with information you can examine to determine which style(s), paragraph format(s) or font(s) exist throughout the selected text, and/or which do not.</p>
<p>If <code>set_any_mask</code> was <code>FALSE</code>: All the fields in <code>mask</code> that are set to non–zero indicate that the corresponding field value in info is the same throughout the selected text; all the fields in mask that are set to zero indicate that the corresponding field value in info is not the same throughout the selected text.</p>
<p>For example, suppose after calling <code>pgGetStyleInfo</code>, <code>mask.styles[bold_var]</code> has a non–zero value. That means that whatever value has been set in <code>info.styles[bold_var]</code> is the same for every character in the selected text. Hence if <code>info.styles[bold_var]</code> is -1, then <em>every</em> character is <strong>bold</strong>; if <code>info.styles[bold_var]</code> is 0 , then <em>no</em> character is <strong>bold</strong>.</p>
<p>On the other hand, suppose after calling <code>pgGetStyleInfo</code>, <code>mask.styles[bold_var]</code> is set to zero. That means that some of the characters in the selected text are <strong>bold</strong> and some are <em>not</em>. In this case, whatever value happens to be in <code>info.styles[bold_var]</code> is, mathematically speaking, <em>undefined</em> (think zero divided by zero).</p>
<p>Essentially, a non–zero-valued <code>mask</code> is saying, &quot;Whatever is in info for this field is applied to every character in the text,&quot; and a zero-valued <code>mask</code> is saying, &quot;Whatever is in <code>info</code> for this field <em>does not matter</em> because it is not the same for every character in the text.&quot;</p>
<p>Pass <code>FALSE</code> for <code>set_any_mask</code> to find out which styles, paragraph formats or fonts do and do not apply to the entire selection.</p>
<p>If <code>set_any_mask</code> is <code>TRUE</code>, all fields in mask get set to nonzero if the corresponding field value in <code>info</code> appears <em>anywhere</em> within the selected text. In this case, you must first set all the <code>info</code> fields that you want to check before making the call.</p>
<p>The purpose for setting <code>set_any_mask</code> to <code>TRUE</code> is to find out what item(s) in <code>info</code> exist anywhere in the selected text (as opposed to finding out what items are the same <em>throughout</em> the text).</p>
<p><strong>NOTE:</strong> If you pass <code>FALSE</code> for <code>set_any_mask</code>, OpenPaige sets the <code>info_fields</code>; if you pass <code>TRUE</code> for <code>set_any_mask</code>, you set the <code>info_fields</code> before calling <code>pgGetStyleInfo</code>, <code>pgGetParInfo</code> or <code>pgGetFontInfo</code>. This is a <em>significant</em> difference.</p>
<p>For example, suppose you want to find out if <strong>bold</strong> exists anywhere in the selected text. To do so, you would set <code>info.styles[bold_var]</code> to a non–zero value, then call <code>pgGetStyleInfo()</code> passing <code>TRUE</code> for <code>set_any_mask</code>. Upon return, if <code>mask.styles[bold_var]</code> is <code>TRUE</code> (non–zero), that means <strong>bold</strong> exists <em>somewhere</em> in the selected text. On the other hand, had the function returned and <code>mask.styles[bold_var]</code> was <code>FALSE</code>, that would have meant that <strong>bold</strong> exists <em>nowhere</em> in the text.</p>
<p>Usually, the reason you would want to pass <code>TRUE</code> for <code>set_any_mask</code> is to make some kind of notation on a UI element (e.g. a menu or dialogue box) as to which style(s) appear anywhere in a selection but do not necessarily apply to the <em>entire</em> selection.</p>
<p><strong>FUNCTION RESULT:</strong> Each function returns the text offset (which is a byte offset) of the first text that is examined. For example, if the current selection range in <code>pg</code> was offsets 100–500, <code>pgGetStyleInfo</code> would return 100; for the same selection range <code>pgGetParInfo</code> would return the text offset of the beginning of the first paragraph (which would often be less than 100).</p>
<p><strong>NOTE:</strong> If you want to get information about tabs, it is more efficient (and less code) to use the functions in the section below, See also, &quot;Tab Support&quot;<!-- on page 9-1-->.</p>
<h2 id='309-getting-info-recs'>30.9 Getting Info Recs</h2>
<p>An additional way to obtain the current font that applies to a text range is to first obtain the style information that applies using <code>pgGetStyleInfo</code>, then get the font record by calling the following function:</p>
<pre><code class='language-c' lang='c'>(void) pgGetFontInfoRec (pg_ref pg, short font_index, font_info_ptr info);
</code></pre>
<ul>
<li><code>font_index</code> — should be whatever is in the <code>font_index</code> field in the <code>style_info</code> record (which you received from <code>pgGetStyleInfo</code>). The font record is put into <code>info</code> (which must not be a null pointer).</li>

</ul>
<p>This function is used to fill in the whole font record if you already know its font index number, which you do after doing a <code>pgGetStyleInfo</code>.</p>
<p>Styles and fonts have the same functions that will fill in the appropriate record.</p>
<pre><code class='language-c' lang='c'>(void) pgGetStyleInfoRec (pg_ref pg, short style_item, style_info_ptr format);
(void) pgGetParInfoRec (pg_ref pg, short style_item, par_info_ptr format);
</code></pre>
<p>These functions take the <code>style_item</code> value from a <code>style_run</code> record and return a <code>par_info</code> or <code>style_info</code> record.</p>
<p>NOTE: This is a low-level function that you will rarely need but has been provided for documentation purposes. See <code>style_run</code> information at &quot;More About Style Runs&quot;<!-- on page 30-632-->.</p>
<h3 id='obtaining-a-font-record'>Obtaining a font record</h3>
<pre><code class='language-c' lang='c'>/* This function is to obtain a font record that is &quot;attached&quot; to a style_info record. For example, you could get the whole font record after doing pgGetStyleInfo as follows: */

style_info info, mask;
font_info font;
pgGetStyleInfo(pg, NULL, FALSE, &amp;info, &amp;mask);
pgGetFontInfoRec(pg, info.font_index, &amp;font);
</code></pre>
<h2 id='3010-other-style-font-and-paragraph-utilities'>30.10 Other Style, Font and Paragraph Utilities</h2>
<h3 id='set-insertion-styles'>Set Insertion Styles</h3>
<p>This function provides a convenient way to set both a style record and font for a single insertion point.</p>
<pre><code class='language-c' lang='c'>(void) pgSetInsertionStyles (pg_ref pg, style_info_ptr style, font_info_ptr font);
</code></pre>
<p>The <code>style</code> parameter will be the style that will apply to the next <code>pgInsert</code>; the <code>font</code> parameter will be the font that will apply to the next <code>pgInsert</code>. Neither parameter can be null.</p>
<p><strong>NOTE:</strong> This function is intended for single insertion points and will fail to work correctly if there is a selection range in <code>pg</code>.</p>
<h3 id='tech-note-pgsetinsertionstyles-is-a-convenience'>TECH NOTE: pgSetInsertionStyles is a convenience</h3>
<blockquote><p>Is <code>pgSetInsertionStyles</code> just a convenience function? Or should I be using this to set font/style info when there is only an insertion point (no selection), i.e., can I simply always use <code>pgSetStyleInfo</code> and <code>pgSetFontInfo</code>, and never use <code>pgSetInsertionstyles</code>?</p>
</blockquote>
<p>This is only a convenience function; you will probably never use it. <code>pgSetStyleInfo</code> handles this for you. It checks the selection and, if only a &quot;caret&quot;, it calls <code>pgSetInsertionStyles</code> for you.</p>
<h3 id='style-info-of-a-mouse-point'>Style info of a Mouse Point</h3>
<pre><code class='language-c' lang='c'>long pgPtToStyleInfo (pg_ref pg, const co_ordinate_ptr point, short conversion_info, style_info_ptr style, select_pair_ptr range);
</code></pre>
<p>This function is useful for determining which <code>style_info</code> is applied to the character containing a specific <code>mouse</code> coördinate. For instance, <code>pgPtToStyleInfo()</code> can be used to detect what kind of text the cursor is moving through.</p>
<p>When this function returns, if is non-null it gets set to the range of text for which this style applies (see &quot;Selection range&quot;<!-- on page 8-2--> for information about <code>select_pair</code> record).</p>
<p><code>conversion_info</code> is used to indicate one or two special-case alignment instructions, which can be represented by the following bits:</p>
<pre><code>#define NO_HALFCHARS	0x0001 	// Whole char only
#define NO_BYTE_ALIGN 0x0002	// No multibyte alignment
</code></pre>
<p><code>NO_HALFCHARS</code> instructs the function to select the right side of a character if the point is anywhere to the right of its left side (not having <code>NO_HALFCHARS</code> set results in the left side of the character if the point is within its first half-width, or the right side of the character if the point is within its second half-width).</p>
<p><code>NO_BYTE_ALIGN</code> returns the absolute byte position regardless of multibyte character status. For example, in a Kanji system that contains double-byte characters, setting <code>NO_BYTE_ALIGN</code> can result in the selection of 1/2 character.</p>
<p><strong>FUNCTION RESULT:</strong> The function result is the text (character) position for the character found containing <code>point</code>. The function will always return a style and position even if the <code>point</code> is way beyond text (in which case the style for the last character is returned) or before text (where the first style is returned). Either style or range can be a null pointer if you don&#39;t need those values.</p>
<p><strong>NOTE:</strong> This function always finds some style_info even if <code>point</code> is nowhere near any text. Hence, to detect &quot;true&quot; cursor-over-text situations you should also call <code>pgPtInView()</code> to learn whether or not the point is actually over text.</p>
<h3 id='font-table'>Font table</h3>
<pre><code class='language-c' lang='c'>(memory_ref) pgGetFontTable (pg_ref pg);
</code></pre>
<p>FUNCTION RESULT: This function returns the memory allocation in $p g$ that contains all the fonts used for the text. The memory_ref will contain an array or one or more font_info records.</p>
<p>NOTE: The actual memory_ref that OpenPaige used for this <code>pg_ref</code> is returned, not a copy. Therefore do not dispose this allocation and do not delete any records it contains.</p>
<p>To learn how to access a memory_ref, see &quot;The Allocation Mgr&quot; on page 25-1.</p>
<h2 id='3011-record-structures'>30.11 Record Structures</h2>
<h3 id='styleinfo'><code>style_info</code></h3>
<pre><code class='language-c' lang='c'>#define MAX_STYLES32	// Maximum number of styles in style_info
typedef struct
{
	short	font_index;					// What font this style is in
	short	styles[MAX_STYLES];	// Stylisation extension
	short	char_bytes;					// Number of bytes per character less 1
	short	max_chars;					// Maximum chars before new style begins
	short ascent;							// This style&#39;s ascent
	short	descent;						// This style&#39;s descent
	short	leading;						// Regular leading
	short	shift_verb;					// Super/subscript verb
	short	class_bits;					// Defines selection and behaviour
	long	style_sheet_id;			// Used for style sheet features
	long	small_caps_index;		// style_info index for point size
	long	machine_var;				// Machine-specific
	long	machine_var2;				// Machine-specific
	long	left_overhang;			// Style&#39;s left overhang if any
	long	right_overhang;			// Style&#39;s right overhang if any
	long	top_extra;					// Style&#39;s top leading
	long	bot_extra;					// Style&#39;s bottom leading
	long	space_extra;				// Extra pixels for spaces (Fixed value)
	long	char_extra;					// Extra pixels for chars (Fixed value)
	long	user_id;						// Can be used by app to ID custom styles
	long	user_data;					// Add&#39;l space for app if style is custom
	long	user_data2;					// Add&#39;l space for app
	long	future[3];					// Reserved for future exp&#39;n
	long	embed_entry;				// App callback function for embed_refs
	long	embed_style_refcon;	// Used by embedded object ext&#39;n
	long	embed_refcon;				// Used by embedded object ext&#39;n
	long	embed_id;						// Used by embedded object ext&#39;n
	long	maintenance;				// Internal use
	long	used_ctr;						// Internal use
	color_value			fg_color;			// Foreground colour
	color_value			bk_color;			// Background colour
	pg_fixed				char_width;		// Character width (not used on Mac)
	pg_fixed				point;				// Point size (do &lt;&lt;16 on int value)
	memory_ref			embed_object;	// Used by embedded object ext&#39;n
	style_append_t	user_var;			// Arbitrary use
	pg_style_hooks	procs;				// Contains functions on how to draw
}
style_info, PG_FAR *style_info_ptr;
</code></pre>
<h3 id='field-descriptions'>Field descriptions</h3>
<ul>
<li><p><code>font_index</code> — The record number of the font that goes along with this style. (To obtain the actual font, see &quot;Getting Info Recs&quot;<!-- on page 30-647--> for information about <code>pgGetFontInfoRec</code>).</p>
<p><strong>NOTE:</strong> Do not change the <code>font_index</code> using <code>pgSetStyleInfo</code>. Instead, use <code>pgSetFontInfo</code> and the font_index values will be handled by OpenPaige appropriately.</p>
</li>
<li><p><code>styles</code> — An array of <code>short</code>s that correspond to 32 possible &quot;standard&quot; styles. Each element of <code>styles</code>, if non–zero, implies that style be applied to the text. An overall style of &quot;plain&quot; generally means all style elements are zero.</p>
<p>The standard styles supported by OpenPaige are defined by the following enumerates (each corresponding to one of the array elements):</p>
<pre><code>enum
{
	bold_var,
	italic_var,
	underline_var,
	outline_var,
	shadow_var,
	condense_var,
	extend_var,
	dbl_underline_var,
	word_underline_var,
	dotted_underline_var,
	hidden_text_var,
	strikeout_var,
	superscript_var,
	subscript_var,
	rotation_var,						// future, not currently supported
	all_caps_var,
	all_lower_var,
	small_caps_var,
	overline_var,
	boxed_var,
	relative_point_var,
	super_impose_var,
	dsi_custom_var = 27,		// Internal use by HERMES
	custom_var = 28
};
</code></pre>
</li>
<li><p><code>superscript</code>, <code>subscript</code> — If <code>styles[superscript_var]</code> or <code>styles[subscript_var]</code> apply, their values define the &quot;amount&quot; of shift.</p>
<p>For example, if <code>styles[sub_script_var]</code> contains a value of 3, the text is to be shifted down by 3 points (3 pixels). If <code>styles[super_script_var]</code> were 3, the text is to be shifted upwards by 3 points. However, the <code>shift_verb</code> (<em>infra</em>) defines whether or not the super/subscript is relative to the text baseline or relative to a percentage of the style&#39;s height.</p>
</li>
<li><p><code>small_caps</code> — If <code>styles[small_caps_var]</code> applies, the value in this style element indicates a percentage of the original point size to display lower case characters that get converted to ALL CAPS. Or, if this value is -1, the default is used (which is 75% of the original style).</p>
<p>For example, if <code>style_info -&gt; styles[small_caps_var]</code> is 50 and <code>style_info</code> point size is 24 , the lower case text is converted to uppercase 12 point; if <code>style_info -&gt; styles[small_caps_var]</code> is -1, the lower case text is converted to 18 (which is 75% of 24 ).</p>
</li>
<li><p><code>relative_point</code> — If <code>styles[relative_point_var]</code> applies, the value in this style element indicates a point size to display the text which is a ratio relative to 12 point times the original point size. The ratio is computed as: <code>style_info -&gt; styles[relative_point_var] / 12</code>. (The &quot;original point size&quot; is taken from the <code>point</code> field in <code>style_info</code>).</p>
<p>For example: If <code>style_info -&gt; styles[relative_point_var]</code> is 6 and the original point size is 12, the point size that displays is <code>12 * (6 / 12) = 6</code> point. If <code>style_info -&gt; styles[relative_point_var]</code> is 6 and the original point size is 24, the point size that displays is <code>24 * (6 / 12) = 12</code> point.</p>
<p><strong>NOTE:</strong> The <code>relative_point_var</code> element must not be -1 as there is no default.</p>
</li>
<li><p><code>super_impose</code> — If <code>styles[super_impose_var]</code> applies, the value represents a stylesheet ID that gets &quot;superimposed&quot; over the existing style. All fields in the stylesheet <code>style_info -&gt; styles[super_impose_var]</code> that are non–zero are temporarily forced into <code>style_info</code> to form a composite style of both.</p>
<p>For example, if <code>style_info -&gt; styles[super_impose_var]</code> record had all fields set to zero EXCEPT for the bold_var element, the resulting style would be whatever the original style_info contained but with boldface text.</p>
<p><strong>NOTE:</strong> <code>style_info -&gt; styles[super_impose_var]</code> can only be zero or a positive number representing a stylesheet ID that actually exists in the <code>pg_ref</code>.</p>
<p>See &quot;Style Sheets&quot;<!-- on page 31-1--> for more information.</p>
</li>
<li><p><code>char_bytes</code> — Defines the number of bytes per character minus 1. For &quot;normal&quot; text, this field will be zero.</p>
<p><strong>NOTE:</strong> If you are a <strong>Macintosh</strong> user, do not confuse this with double-byte scripts such as Kanji. This field is intended for situations where all character are <code>char_bytes</code> + 1 in size, such as a feature in which a <code>PicHandle</code> is embedded as a &quot;character&quot;. For Kanji, not every character is a double-byte so this field will always be zero.</p>
</li>
<li><p><code>max_chars</code> — <strong>Not currently supported.</strong> Eventually this will be used for something fancy. <!-- TODO: like what? --></p>
</li>
<li><p><code>ascent</code>, <code>descent</code>, <code>leading</code> — Define the style&#39;s ascent, descent and leading values. (For <strong>Macintosh</strong>, each value is obtained from the Toolbox call, <code>GetFontInfo</code>).</p>
<p><strong>NOTES:</strong> </p>
<ol start='' >
<li>You do not need to set these fields for &quot;normal&quot; (non-custom) styles because the machine-specific portion of OpenPaige will initialise these fields according to the composite style and font. </li>
<li>If you need to implement a &quot;set extra leading&quot; feature, use <code>top_extra</code> and <code>bot_extra</code> <em>infra</em>.</li>

</ol>
</li>
<li><p><code>shift_verb</code> — This value is used only if <code>styles[sub_script_var]</code> or <code>styles[subscript_var]</code> are non–zero. The <code>shift_verb</code> can be one of two values:</p>
<pre><code>typedef enum
{
	baseline_relative,	// Draw from line&#39;s baseline
	percent_of_style		// Draw relative to percentage of baseline
};
</code></pre>
<p>For <code>baseline_relative</code>, values in <code>styles[sub_script_var]</code> or <code>styles[subscript_var]</code> are considered to be point (pixel) values; for <code>percent_of_style</code>, the super/subscript point values are computed as a percent (value of <code>styles[sub_script_var]</code> or <code>styles[subscript_var]</code>) of the <code>style</code>&#39;s total height (ascent + descent + leading). Example: If <code>style</code>&#39;s total height is 32 and <code>styles[subscript_var]</code> contained 50, the point value to shift the text will be <code>32 * 0.50</code>, or 16.</p>
</li>
<li><p><code>class_bits</code> — Contains a set of bits defining specific attributes and behaviors for this style. The current attributes supported by OpenPaige are as follows:</p>
<pre><code>#define CANNOT_HILITE_BIT		0x00000000	// Can not highlight text of this style
#define CANNOT_BREAK				0x00000002	// Chars can not break with this
#define STYLE_IS_CONTROL		0x00000004	// Style is &quot;control&quot; type item
#define GROUP_CHARS_BIT			0x00000008	// All chars selected as one
#define STYLE_MERGED_BIT		0x00000010	// Style has been merged
#define STYLE_IS_CUSTOM			0x00000020	// Style is understood only by app
#define HILITE_RESTRICT_BIT	0x00000040	// Can not select outside of style
#define CANNOT_WRAP_BIT			0x00000080	// Can not wrap (for tables, etc)
#define IS_NOT_TEXT_BIT			0x00000100	// Data is not text at all
#define REQUIRES_COPY_BIT		0x00000200	// Text copy requires copy_proc callback
#define NO_SMART_DRAW_BIT		0x00000400	// Do not second-guess line drawing
#define ACTIVATE_ENABLE_BIT	0x00000800	// Causes activate_proc to be called
#define CANT_UNDERLINE_BIT	0x00001000	// The OS does not support underline
#define CANT_TRANS_BIT			0x00002000	// Text can&#39;t transliterate etc
#define RIGHTLEFT_BIT				0x00004000	// Text direction is RTL
#define VERTICAL_TEXT_BIT		0x00008000	// (unsupported - for )
#define TEXT_LOCKED					0x00010000	// (unsupported)
#define NO_EXTRA_SUPER_SUB	0x00020000	// (unsupported)
#define EMBED_SUBSET_BIT		0x00040000	// (for HERMES only)
#define NO_SAVEDOC_BIT			0x00080000	// Do not save this style_info
#define EMBED_INITED_BIT		0x00100000	// Used internally by embed_refs
</code></pre>
<!-- TODO: Right-to-left text, locked text, no-extra-super-sub whatever that is -->
<p>Each of the above bits, if set, cause the following (only the bits currently supported are explained):</p>
<ul>
<li><code>CANNOT_HILITE_BIT</code> causes highlighting <em>not</em> to show for the characters; even if the user does a &quot;Select All&quot;, text with this style attribute will not highlight.</li>
<li><code>CANNOT_BREAK</code> is essentially a &quot;non-breaking&quot; style; characters with this attribute will not break in the middle (unless the line is too large).</li>
<li><code>STYLE_IS_CONTROL</code> causes the track-control low-level function to be called when a &quot;mouse&quot; click is received (see &quot;Customizing OpenPaige&quot; <!-- on page 27-1-->).</li>
<li><code>GROUP_CHARS_BIT</code> causes all text in this style to be highlighted as one, i.e. a single click selects the whole group.</li>
<li><code>STYLE_MERGE_BIT</code> gets set by OpenPaige in &quot;mail merge mode&quot;; <em>do not</em> set this bit yourself.</li>
<li><code>STYLE_IS_CUSTOM</code> causes the text to be invisible <em>if</em> the standard display function is used. In other words, all text with this attribute will only display if you have provided your own display function.</li>
<li><code>HILITE_RESTRICT_BIT</code> forces a click/drag on this style to stay inside the boundaries of the style.</li>
<li><code>CANNOT_WRAP_BIT</code> causes text <em>not</em> to wrap regardless of width.</li>
<li><code>IS_NOT_TEXT_BIT</code> tells OpenPaige the character(s) aren&#39;t really text. If this is set, the standard text measuring and drawing functions do nothing (hence you would need to set your own hooks for both functions).</li>
<li><code>REQUIRES_COPY_BIT</code> causes the <code>copy_text_proc</code> (hook) to get called for these character(s); otherwise OpenPaige does not call this hook.</li>
<li><code>NO_SMART_DRAW_BIT</code> disables the &quot;second-guessing&quot; for fast character display. If this bit is set, the whole text line is drawn (instead of a partial line).</li>
<li><code>ACTIVATE_ENABLE_BIT</code> causes the <code>style_activate_proc</code> to get called, otherwise that hook is ignored.</li>
<li><code>CANT_UNDERLINE_BIT</code> informs the text drawing function that the OS will not display an underline style (used for Kanji characters in Macintosh). <strong>Obsolete!</strong></li>
<li><code>CANT_TRANS_BIT</code> informs the &quot;ALL CAPS&quot; and &quot;small caps&quot; functions that the text can&#39;t be translated to upper/lower case. This bit might be important for text that is not really text, e.g. a pointer or memory reference.</li>
<li><code>RIGHTLEFT_BIT</code> indicates the writing direction for the text is right-to-left.</li>
<li><code>NO_SAVEDOC_BIT</code> causes this <code>style_info</code> not to be included in <code>pgSaveDoc()</code>. One reason you might want to do this is for special applications that want to construct their own styles or stylesheets without saving <code>style_info</code> to each file.</li>

</ul>
</li>
<li><p><code>style_sheet_id</code> — Contains a unique ID used by style sheet support (see &quot;Style Sheets&quot;<!-- on page 31-1-->).</p>
</li>
<li><p><code>small_caps_index</code> — You should not alter this field; it is used by OpenPaige when <code>small_caps_var</code> style is set.</p>
</li>
<li><p><code>fg_color</code>, <code>bk_color</code> — Define the foreground and background color of the text. Both fields are structured as follows:</p>
<pre><code class='language-c' lang='c'>typedef struct
{
	unsigned short red;		// Red composite
	unsigned short green;	// Green composite
	unsigned short blue;	// Blue composite
	pg_short_t alpha;			// Optional value (machine dependent)
}
</code></pre>
<p><strong>NOTE:</strong> The <em>background</em> colour applies to the <strong>text</strong> background, not necessarily the <strong>window</strong> background. For example, a line of text drawn with a <em>blue</em> background colour on a white background window will result in a blue &quot;stripe&quot; of line height&#39;s size with the text foreground overlaying the stripe.</p>
</li>
<li><p><code>machine_var</code>, <code>machine_var2</code> — <em>Do not</em> alter these values; they are used internally by HERMES Paige.</p>
</li>
<li><p><code>char_width</code> — On <strong>Windows</strong>, this becomes the <code>ffWidth</code> value when setting up a <code>LOGFONT</code> for font selection.</p>
</li>
<li><p><code>point</code> — The point size for this style. This field is a <code>Fixed</code> type, i.e., the high-order word of the field is the integral part and the low-order word the fractional part of the value, if any. For more on setting point, see &quot;Setting / Getting Point Size&quot;<!-- on page 8-5--> and &quot;Changing point size&quot;<!-- on page 30-641-->.</p>
</li>
<li><p><code>left_overhang</code>, <code>right_overhang</code> — These are a form of indent for characters. These fields control how far a style overhangs to the left and/or right, the best example being italic that can overhang to the right.</p>
<p><strong>NOTE:</strong> OpenPaige sets the default for these values when the style is initialised.</p>
</li>
<li><p><code>top_extra</code>, <code>bot_extra</code> — Contains extra leading, in pixels, to add to the top or bottom of the style.</p>
<p><strong>NOTE:</strong> You should use these fields—<em>not</em> the ascent/descent fields—for &quot;add extra leading&quot; features.</p>
</li>
<li><p><code>space_extra</code> — The fractional amount to add to each space width. This value is a <code>Fixed</code> value (high order word is the integral part and low order word the fractional part).</p>
</li>
<li><p><code>char_extra</code> — The fractional amount to add to each non-space character. This value is a &quot;fixed&quot; fraction (high order word is the whole part and low order word the fraction part) and can be used for kerning.</p>
<p><strong>NOTE:</strong> This field is only supported on <strong>Macintosh</strong> if <strong>Color QuickDraw</strong> exists.</p>
</li>
<li><p><code>user_id</code>, <code>user_data</code>, <code>user_data2</code> — Use these fields for an arbitrary setting. These are of particular utility for customising styles.</p>
</li>
<li><p><code>future</code> - an <code>array</code> of <code>long</code>s reserved for future enhancement. Do not use these fields.</p>
</li>
<li><p><code>embed_entry</code>, <code>embed_style_refcon</code>, <code>embed_refcon</code>, <code>embed_id</code>, <code>embed_object</code> — Do not alter these values; they are used by the TEXT-embed extension. See chapter on &quot;Embedding Non-Text Characters&quot;<!-- on page 28-1-->.</p>
</li>
<li><p><code>user_var</code> — This can be used for anything. It is intended mainly, however, for source code users who want to append to the <code>style_info</code> record.</p>
</li>
<li><p><code>procs</code> — This is a record of many function pointers that get called by OpenPaige for drawing, text measuring, etc. The array of functions literally define the way this style behaves (OpenPaige will always call one of these functions to obtain information and/or to display text in this style). These are the essence and key to implementing special styles and text types. See &quot;Customizing OpenPaige&quot;<!-- on page 27-1-->.</p>
</li>
<li><p><code>maintenance</code>, <code>used_ctr</code> — Both of these are used only by OpenPaige for internal maintenance and must not be altered (actually, you cannot alter them anyway; when calling <code>pgSetStyleInfo</code>, bOpenPaige ignores anything you put into these two fields).</p>
</li>

</ul>
<h3 id='user-defined-styles-setting-invisible-markers'>User-defined styles, setting &quot;invisible markers&quot;</h3>
<p>A <code>style_info</code> is said to be <em>user-defined</em> if one or more fields contain information understood only by the application. Usually, in all other respects the style looks and feels like any other OpenPaige style.</p>
<p>For example, your application might want to &quot;mark&quot; various sections of text with some special attribute, but invisibly to the (human) user. You can set invisible &quot;marks&quot; for various sections of text by merely applying a <code>style_info</code> to the desired text with any of the user fields set to something your app will understand. The user fields are <code>user_id</code>, <code>user_data</code> and <code>user_data2</code>, each usable for any purpose whatsoever.</p>
<h3 id='fontinfo'><code>font_info</code></h3>
<pre><code class='language-c' lang='c'>typedef struct
{
	pg_char name[FONT_SIZE];						// &quot;Name&quot; of font
	pg_char	alternate_name[FONT_SIZE];	// Alternate if first not found
	short		environs;										// Machine-specific attributes
	short		typeface;										// Typography class
	short		family_id;									// Font ID code
	short		alternate_id;								// Alternate ID code if bad font
	short		char_type;									// Char type (machine-specific)
	long		platform;										// The platform this font originated
	long		language;										// Language
	long		machine_var[8];							// Machine-specific array
	font_append_t user_var;							// Arbitrary use
}
font_info, PG_FAR *font_info_ptr;
</code></pre>
<p>The <code>font_info</code> record is somewhat machine-dependent and what should be placed in each field may depend on the platform you are running.</p>
<p>When you set a <code>font_info</code> record, usually only the <code>name</code>, <code>alternate_name</code>, and <code>environs</code> fields need be changed; this is because OpenPaige will initialise all the other fields to their defaults when the font is applied to a <code>pg_ref</code>.</p>
<p>One exception to this is setting a Windows font and you require a special character set and/or special precision information (see &quot;Additional Font Info for Windows&quot; below).</p>
<p><strong>NOTE:</strong> On <strong>Macintosh</strong>, the <code>font_info.name</code> should be a pascal string terminated with the remaining bytes in <code>font_info.name</code> set to zero; the <code>font_info.environs</code> field should also be set to zero. For an example see &quot;Responding to font menu (Macintosh)&quot;<!-- on page 30-644-->.</p>
<p><strong>NOTE:</strong> On <strong>Windows</strong>, the <code>font_info.name</code> can be initially set to either a <code>pascal</code> string or a <code>cstring</code>, with all remaining bytes in <code>font_info.name</code> set to zero. Usually, due to Windows programming conventions, you will set the name to a <code>cstring</code>. In this case, before passing the <code>font_info</code> record to <code>pgSetFontInfo</code>, you must set <code>font_info.environs</code> to <code>NAME_IS_CSTR</code>.</p>
<p><strong>CAUTION:</strong> On <strong>Windows</strong>, OpenPaige converts <code>font_info.name</code> to a <code>pascal</code> string and clears the <code>NAME_IS_CSTR</code> bit when the font is stored in the <code>pg_ref</code>. This is done purely for cross-platform portability. This is important to remember, because if you examine the font thereafter with <code>pgGetFontInfo</code>, the font name will now be a <code>pascal</code> string (the first byte indicating the string length), not a <code>cstring</code>.</p>
<ul>
<li><p><code>name</code> - This should contain the name of the font. This can either be a <code>pascal</code> string (first byte is the length) or a <code>cstring</code> (terminated with zero). However, the assumption is made by OpenPaige that the string is a <code>pascal</code> string. Hence, you need to set the <code>environs</code> field accordingly if name is a <code>cstring</code> (see below).</p>
</li>
<li><p><code>alternate_name</code> — This should contain a font name to use as a second choice if the font defined in <code>name</code> does not exist. If OpenPaige can&#39;t find the first font, it will try using <code>alternate_name</code>. If you do not have an alternative, set <code>alternate_name</code> to all zeros.</p>
</li>
<li><p><code>environs</code> - Additional information about the font, which contains the following bit (or not):</p>
<pre><code class='language-c' lang='c'>#define NAME_IS_CSTR 1 // Font name is a cstring
</code></pre>
<p>All the other fields in <code>font_info</code> are initialised by OpenPaige when you set a font.</p>
<p><strong>NOTE:</strong> Fill the font name with all zeros before setting the string. This will allow applications more easily to shift between <code>pascal</code> strings and <code>cstring</code>s (because a <code>pascal</code> string will also be terminated with a zero).</p>
<p><strong>NOTE:</strong> For your reference, on <strong>Macintosh</strong>, the <code>family_id</code> will get initialised to the font ID and <code>char_type</code> will get set to the font script code (e.g., Roman, Kanji, etc.).</p>
</li>
<li><p><code>language</code> — This will contain the language ID for the font. In Windows NT and 95, this contains the langID and code page.</p>
</li>

</ul>
<p>The remaining fields are not supported for any particular purpose and might be used for future enhancements.</p>
<h3 id='additional-font-info-for-windows'>Additional Font Info for Windows</h3>
<p>In certain cases, it is necessary to map certain members of the font information to obtain the appropriate character set and drawing precision. The <code>machine_var</code> field in <code>font_info</code> is used for this purpose, the first four elements of which are defined as follows:</p>
<ul>
<li><code>machine_var[PG_OUT_PRECISION]</code> should contain output precision.</li>
<li><code>machine_var[PG_CLIP_PRECISION]</code> should contain clipping precision.</li>
<li><code>machine_var[PG_QUALITY]</code> should contain output quality.</li>
<li><code>machine_var[PG_CHARSET]</code> should contain the character set code.</li>

</ul>
<h3 id='setting-logfont-precision-info'>Setting LOGFONT precision info</h3>
<pre><code class='language-c' lang='c'>/* This code snippet shows the members of LOGFONT you should map across to font_info: */
font-&gt;machine_var[PG_OUT_PRECISION] = log_font -&gt; IfOutPrecision;
font-&gt;machine_var[PG_CLIP_PRECISION] = log_font -&gt; IfClipPrecision;
font-&gt;machine_var[PG_QUALITY] = log_font -&gt; IfQuality; 
font-&gt;machine_var[PG_CHARSET] = log_font-&gt;IfCharSet;
</code></pre>
<h3 id='parinfo'><code>par_info</code></h3>
<pre><code>struct par_info
{
	short				justification;	// How text is justified
	short				direction;			// Primary text direction
	short				class_info;			// Used to define para attributes
	pg_short_t	num_tabs;				// Number of active tabs
	tab_stop		tabs[TAB_ARRAY_SIZE];	// Tab stop information 
	long				style_sheet_id;	// Used for style sheet features
	pg_fixed		def_tab_space;	// Default tab space
	pg_indents	indents;				// Line spacing
	pg_fixed		leading_extra;	// Extra leading of lines
	pg_fixed		leading_fixed;	// Fixed leading (0 = auto)
	pg_fixed		top_extra;			// Extra space at top
	pg_fixed		bot_extra;			// Extra space at bottom
	pg_fixed		left_extra;			// Extra space at left
	pg_fixed		top_extra;			// Extra space at right
	long				user_id;				// Can be used by app to ID custom para sizes
	long				user_data;			// Add&#39;l space for app if par is custom
	long				user_data2;			// More space for app
	long				partial_just;		// Partial justify (future enhancement)
	long				future[PG_FUTURE];	// Reserved for future enhancement
	par_append_t	user_var;			// Arbitrary use
	pg_par_hooks	procs;				// Function pointers
	long				maintenance;		// Internal use
	long				used_ctr;				// Internal use
}
par_info, PG_FAR *par_info_ptr;
</code></pre>
<h3 id='field-descriptions-2'>Field descriptions</h3>
<ul>
<li><p><code>justification</code> - The justification (alignment) for the paragraph. This value can be any of the following:</p>
<pre><code class='language-c' lang='c'>typedef enum
{
	justify_left,		// Align left
	justify_center,	// Align centrally
	justify_right,	// Align right
	justify_full,		// Fully justify (pad spaces)
	force_left,			// Force left (notwithstanding writing direction)
	force_right,		// Force right (notwithstanding writing direction)
}
</code></pre>
<p><code>force_left</code> and <code>force_right</code> are used to force an alignment to one side or the other regardless of the writing direction.</p>
</li>
<li><p><code>direction</code> — Defines the writing direction (left to right or right to left), and can be one of the following:</p>
<pre><code class='language-c' lang='c'>typedef enum
{
  right_left_direction = -1,	// Right-to-left
  system_direction, // System-default direction
  left_right_direction	// Left-to-right
}
</code></pre>
<p><strong>NOTE:</strong> The <code>direction</code> parameter defines the writing direction of the paragraph(s) affected by the <code>par_info</code> style. In such paragraphs, bidirectional scripts can exist such as English and Hebrew. While each script has its own direction attribute, the writing direction defines the point of origin for all lines in the paragraph. If writing direction is right-to-left, all text is aligned to the right; if writing direction is left to right, all text is aligned to the left. In both cases, however, individual blocks of text can go either direction relative to the text they are aligned to. <!-- For more information on bidirectional scripts, see Inside Macintosh Volume 6 and Apple's Inside Macintosh Text manual.--></p>
</li>
<li><p><code>class_info</code> — Contains various bit setting(s) defining special attributes. Currently, the following attribute bits are supported:</p>
<pre><code>#define KEEP_PARS_TOGETHER	0x0001	// Keep paragraphs on same page
#define NO_SAVEDOC_PAR			0x0200	// Don&#39;t save par_info in pgSaveDoc()
</code></pre>
</li>
<li><p><code>num_tabs</code>, <code>tabs</code> — Define the tab stop(s). The tabs field contains an array of <code>tab_stop</code> records and <code>num_tabs</code> contains the number of valid elements. Tabs are described in &quot;Tab Support&quot;<!-- on page 9-1-->.</p>
</li>
<li><p><code>style_sheet_id</code> — Contains a unique ID for paragraph style sheets (see &quot;Style Sheets&quot;<!-- on page 31-1-->).</p>
</li>
<li><p><code>def_tab_space</code> — Defines the default tab spacing (when no preset tab stops exist). You can set this to anything.</p>
<p><strong>NOTE:</strong> The initial (default) setting is taken from <code>pg_globals</code> (see &quot;Changing Globals&quot; <!-- on page 3-21-->for more information about <code>pg_globals</code>).</p>
</li>
<li><p><code>indents</code> — These are the paragraph indentations; for information about indents see &quot;Set Indents&quot;<!-- on page 9-11--> and “Get Indents”<!-- on page 9-12-->.</p>
</li>
<li><p><code>spacing</code> — Defines the line spacing for the paragraph. This value is a mixed-number <code>Fixed</code> type in which the integral part is in the high-order word and the fractional part in the low-order word. This value is multiplied times the current line height (ascent + descent) and the result becomes the new height.</p>
<p>For example, to obtain <code>2*1</code> line spacing, the spacing value should be <code>0x00020000</code>. For <code>1.5*1</code> spacing, the value should be <code>0x00018000</code> (low-order word is 1/2 of an unsigned <code>short</code>).</p>
<p><strong>NOTE:</strong> A spacing value of zero implies &quot;auto&quot; spacing (lines spaced according to their style). You would also get the same effect if <code>spacing = 0x00010000</code>.</p>
</li>
<li><p><code>leading_extra</code>, <code>leading_fixed</code> — Both of these can also control line spacing. The <code>leading_extra</code> field is added to the line&#39;s height. The <code>leading_fixed</code> field, if non—zero, is forced as the line height. Both should never be set to non—zero at the same time since that would make no sense.</p>
</li>
<li><p><code>top_extra</code>, <code>bot_extra</code>, <code>left_extra</code>, <code>right_extra</code> — These are all added to the top, bottom, left and right of the paragraph, respectively.</p>
<p><strong>NOTE:</strong> These values are all pixel amounts (<code>point</code>) and they are added to the paragraph&#39;s boundaries in addition to everything else (in addition to indentations and spacing, etc.). Use these fields to obtain &quot;space before&quot; and &quot;space after&quot; for paragraphs.</p>
</li>
<li><p><code>user_id</code>, <code>user_data</code>, <code>user_data2</code> — Your app can use these fields for anything it wants. These come in handy for customising paragraphs.</p>
</li>
<li><p><code>partial_just</code>, <code>future</code> — These are reserved for future enhancement. Do not alter these fields. <!-- TO DO: flesh this out --></p>
</li>
<li><p><code>procs</code> - This is a record of many function pointers that get called by OpenPaige for paragraph formatting. The array of functions literally define the way this format behaves. See &quot;Customizing OpenPaige&quot;<!-- on page 27-1-->.</p>
</li>
<li><p><code>user_var</code> — This can be used for anything. It is intended mainly, however, for source code users who want to append to the <code>par_info</code> record.</p>
</li>
<li><p><code>maintenance</code>, <code>used_ctr</code> — Both of these are used only by OpenPaige for internal maintenance and must not be altered (actually, you can&#39;t alter them anyway with pgSetParInfo - OpenPaige simply ignores anything you put into these two fields)</p>
</li>

</ul>
<h2 id='3012-creating-a-simple-custom-style'>30.12 Creating a simple custom style</h2>
<p>One of the most important features of OpenPaige is the ability to create custom styles. There are several issues to be understood when doing custom styles. They involve customising how OpenPaige draws and measures the text. This is accomplished by using hooks, described in &quot;Customizing OpenPaige&quot;<!-- on page 27-1-->.</p>
<p>However, here simple custom styles can be created by changing just a few functions. The following example shows how to create a custom style that draws a box around some text. In this case, the only thing changing is how the text is drawn.</p>
<p>First of all, I must set the text to my custom style and install the hooks I will need. Second, I show how to initialize my style and my drawing hook. I even get to use the default OpenPaige functions for simply drawing the characters.</p>
<p>Other custom styles may have to use other custom hooks, including <code>measure_proc</code>, but nearly every custom style can be built changing only three:</p>
<ol start='' >
<li>The <code>measure_proc</code>. The (replaced) function must not only measure the character widths correctly, it must also fill in the <code>types</code> pointer (see &quot;measure_proc&quot;<!-- on page 27-9-->).</li>
<li>The <code>text_draw_proc</code>. The (replaced) function must be able to draw the text on demand (see &quot;text_draw_proc&quot;<!-- on page 27-17-->).</li>
<li>The <code>style_init_proc</code>. The (replaced) function probably needs to determine the style&#39;s ascent, descent and leading if that functionality for the character set in question does not already exist inherently in the OS. (See &quot;style_init_proc&quot;<!-- on page 27-7-->).</li>

</ol>
<p><strong>NOTE:</strong> Many improvements could be made to this code, such as drawing a single box around the text when boxes are adjacent, setting the box so the offset on the left and right of the style is not right next to the first and last character, using the <code>styles[var]</code> amount for various offsets or widths of the line or both, and implement scaling.</p>
<h3 id='set-some-text-to-a-custom-style-cross-platform'>Set some text to a custom style (Cross platform)</h3>
<pre><code class='language-c' lang='c'>void SetBoxStyle (pg_ref pg)
{
  style_info style={0}; // or use pgInitStyleMask
  style_info mask={0};
  /* it is zero because I don&#39;t necessarily want to set everything, only the procs I am interested in */
  style.styles[box_var] = -1;
  style.class_bits |= NO_SMART_DRAW_BIT;
  info -&gt; procs.init = box_init_proc;
  info -&gt; procs.draw = box_draw_proc;
  mask.procs.init = (style_init_proc) -1;
  mask.procs.draw = (text_draw_proc) -1;
  mask.class_bits = -1;
  mask.styles[box_var] = -1;
  
  pgSetStyleInfo(pg, NULL, &amp;style, &amp;mask, best_way);
  /* text inserted using pgInsert is now my custom boxed style */
}
</code></pre>
<h3 id='drawing-a-box-around-some-text-hook-cross-platform'>Drawing a box around some text hook (Cross-platform)</h3>
<pre><code class='language-c' lang='c'>/* This does the actual box and text drawing. */
/* Note: this does not handle multiple custom styles to do that we will need to build our own myMasterDrawProc with the major changes being 1) a huge if/then for each styles [], 2) possibly the order in which these are called, and 3) that the pgDrawProc be called only once. */

static PG_PASCAL (void) box_draw_proc (paige_rec_ptr pg, style_walk_ptr walker, pg_char_ptr data, pg_short_t offset, pg_short_t length, draw_points_ptr draw_position, long extra, short draw_mode)
style_info_ptr original_style = walker -&gt; cur_style;
pg_scale_factor scale = pg -&gt; scale_factor; // this is not implemented

Point start_pt;
Point end_pt;

pgDrawProc(pg, walker, data, offset, length, draw_position, extra, draw_mode); 
/* OpenPaige&#39;s standard draw */
start_pt.h = pgLongToShort(draw_position -&gt; from.h);
start_pt.v = pgLongToShort(draw_position -&gt; from.v);
end_pt.h = pgLongToShort(draw_position -&gt; to.h);
end_pt.v = pgLongToShort(draw_position -&gt; to.v);

draw_a_box_around_rectangle (start_pt.h, start_pt.v - original_style -&gt; ascent + 1, end_pt.h, end_pt.v + original_style -&gt; descent - 1 );
/* on Mac use FrameRect */
}
</code></pre>
<h3 id='figure-out-new-line-heights-due-to-the-box-cross-platform'>Figure out new line heights due to the box (Cross platform)</h3>
<pre><code>// This sets up the required info in the style record
static PG_PASCAL (void) box_init_proc (paige_rec_ptr pg, style_info_ptr style, font_ptr_info font)
{
	register short distance;
	pgStyleInitProc(pg, style, font); // first call standard proc
	distance = style -&gt; styles[box_var];
	style -&gt; ascent += distance;
	style -&gt; descent += distance
	
	// style -&gt; right_extra += distance;
	// style -&gt; left_extra += distance;
	
	style -&gt; class_bits |= NO_SMART_DRAW_BIT;
}
</code></pre>
<p>&nbsp;</p>
<h1 id='31-style-sheets'>31 STYLE SHEETS</h1>
<p>A style sheet in HERMES Paige is a text and/or paragraph format that is &quot;shared&quot; by various characters in a document. Although a style sheet contains the same info as regular formats, affected text essentially &quot;points&quot; to these styles. A change to a single style sheet will change every place in the text that uses that style.</p>
<p><strong>NOTE:</strong> The <code>style_info</code> record structure is described in &quot;<code>style_info</code>&quot;<!-- on page 30-21-->.</p>
<h2 id='311-new-sheets'>31.1 New sheets</h2>
<pre><code>(short) pgNewStyle (pg_ref pg, style_info_ptr new_style, font_info_ptr style_font);
</code></pre>
<p>Establishes a new style sheet and returns a unique ID code for that style.</p>
<p><strong>FUNCTION RESULT:</strong> No text is changed from this function; all that occurs is <code>new_style</code> is added internally to <code>pg</code>, <code>style_font</code> is added (if it does not already exist) and assigned to the new style; the style is assigned a unique number which can be referenced in subsequent calls that affect such styles. The reference number for the style will never equal zero.</p>
<p><code>new_style</code> can contain anything that a regular text style contains.</p>
<h2 id='312-remove-style'>31.2 Remove style</h2>
<pre><code>(void) pgRemoveStyle (pg_ref pg, short style_id);
</code></pre>
<p>Removes the style sheet referenced as <code>style_id</code>. Immediately after this call is made, <code>style_id</code> will no longer be valid.</p>
<p>However, the text is not affected. The <code>style_info</code> that used to be a style sheet simply changes to a regular style run item; locations in the text that are set to <code>style_id</code> will retain their styles but each occurrence will no longer be linked with the <code>style_sheet</code> reference.</p>
<h2 id='313-style-count--indexing'>31.3 Style count &amp; &quot;indexing&quot;</h2>
<pre><code>(short) pgNumStyles (pg_ref pg);
(short) pgNumParStyles (pg_ref pg);
</code></pre>
<p>Returns the total number of style sheets in <code>pg</code>; <code>pgNumParStyles()</code> returns the total number of paragraph style sheets.</p>
<pre><code>short pgGetIndStyleSheet (pg_ref pg, short index, style_info_ptr stylesheet);
short pgGetIndParStyleSheet (pg_ref pg, short index, style_info_ptr stylesheet);
</code></pre>
<p>Returns the <em>n</em>th style sheet found in <code>pg</code>. The style sheet to return is given in <code>index</code> (zero-indexed quantity); <code>pgGetIndStyleSheet()</code> returns a regular (text) style while <code>pgGetIndParStyleSheet()</code> returns a paragraph style sheet.</p>
<p>Using these in conjunction with <code>pgNumStyles()</code> and <code>pgNumParStyles()</code> can provide &quot;random access&quot; to style sheets existing in <code>pg</code>.</p>
<p>If the requested style sheet is found and <code>stylesheet</code> is non-null, this <code>style_info</code> or <code>par_info</code> is initialised to the settings of the sheet.</p>
<p><strong>FUNCTION RESULT:</strong> If <code>index</code> style sheet exists, its ID is returned. If no such style sheet exists, zero is returned.</p>
<h2 id='314-searching-for-a-style-sheet'>31.4 Searching for a Style Sheet</h2>
<pre><code>short pgFindStyleSheet (pg_ref pg, par_info_ptr compare_style, par_info_ptr mask);
</code></pre>
<p>This function returns the style sheet ID, if any, whose <code>style_info</code> fields <em>precisely</em> match <code>compare_style</code>. If no match is found, zero is returned.</p>
<p>The <code>mask</code> parameter can be used to do partial or selective comparisons. If <code>mask</code> is non-null, only the <code>style_info</code> fields that are non-zero in this structure are compared.</p>
<p>For example, to locate a style sheet that had a specific value in <code>style_info.user_id</code>, clear the mask to all zeros except <code>user_id</code> set to -1.</p>
<pre><code>short pgFindParStyleSheet (pg_ref pg, par_info_ptr compare_style, par_info_ptr mask);
</code></pre>
<p>This function is identical to pgFindStyleSheet except in that it is used for paragraph style sheets.</p>
<h2 id='315-get-set-change-a-style-in-a-style-sheet'>31.5 Get, set, change a style in a style sheet</h2>
<pre><code>(pg_boolean) pgGetStyle (pg_ref pg, short style_id, style_info_ptr style);
</code></pre>
<p>Returns the <code>style_info</code> record belonging to style sheet <code>style_id</code>. The <code>style_id</code> must be valid.</p>
<p><strong>NOTE:</strong> If you want to get the associated font, use <code>pgGetFontInfoRec</code>.</p>
<p>If <code>style_id</code> is not a valid stylesheet ID, the function returns <code>FALSE</code> and the <code>style_info</code> record is not set to anything certain.</p>
<pre><code>(void) pgChangeStyle (pg_ref pg, short style_id, style_info_ptr style, font_info_ptr style_font, short draw_mode);
</code></pre>
<p>Changes the style sheet <code>style_id</code> to the contents of <code>*style</code>. All text is affected that is set to this style sheet. Every character in the text that is set to this style—or subset thereof—will change as follows: if the <code>style_info</code> attribute is the same as the original stylesheet, that same attribute changes to the new setting. If the attribute is different (i.e. has been changed by user), that attribute remains unchanged.</p>
<p>For example, suppose you created a style sheet for Helvetica-Bold-Italic and applied that sheet to the whole document. The user underlines a word (making it Helvetica-BoldItalic-Underline), then you change the style sheet to Times-Italic. The underlined word will change to Times-Italic <em>but will retain the underline</em>.</p>
<p>If <code>style_font</code> is non-<code>NULL</code>, the font is also changed (otherwise the font already assigned to the style is retained).</p>
<p>If <code>draw_mode</code> is non-zero, the text is redrawn in the mode specified (see <a href='#draw-modes'>Draw Modes</a> under section 2.11 for more about the display modes for <code>pgDisplay</code>). In most cases, <code>draw_mode</code> should be <code>best_way</code>.</p>
<pre><code>(void) pgSetStyleSheet (pg_ref pg, select_pair_ptr selection, short style_id, short draw_mode);
(pg_boolean) pgGetStyleSheet (pg_ref pg, select_pair_ptr selection, short PG_FAR *style_id);
</code></pre>
<p>The <code>pgSetStyleSheet</code> function changes all the text in the specified selection to style sheet reference <code>style_id</code>.</p>
<p><strong>NOTE:</strong> This differs from <code>pgChangeStyle</code> since, in this case, you are changing a selection range to assume the format of a specific style sheet—you are not changing the style sheet itself.</p>
<p>The <code>selection</code> parameter operates in the same way as all functions that accept a <code>select_pair</code> (for more information about the <code>select_pair</code> record, see section 8.2, <a href='#82-selection-range'>Selection Range</a>).</p>
<p>If <code>draw_mode</code> is non-zero, the text is redrawn in the mode specified (see <a href='#draw-modes'>Draw Modes</a> under section 2.11 for more information about display modes for <code>pgDisplay</code>). In most cases, <code>draw_mode</code> should be <code>best_way</code>.</p>
<p>To find out what style sheet, if any, is applied to an area of text, use <code>pgGetStyleSheet</code>.</p>
<p><strong>FUNCTION RESULT:</strong> <code>pgGetStyleSheet</code> returns the style sheet belonging to the specified selection range. On return, if <code>*style_id</code> contains zero, no single style sheets affect the selected text, otherwise the stylesheet ID is placed in <code>*style_id</code>. Additionally, if the function result is <code>TRUE</code>, the style sheet is consistent throughout the selection range.</p>
<p>For more on styles and masks see “Changing Styles”<!-- on page 30-7-->.</p>
<p><strong>NOTE:</strong> If the function returns <code>TRUE</code>, yet <code>*style_id</code> is zero, that means there are no style sheets anywhere within the selection. But if the function returns <code>FALSE</code> and <code>*style_id</code> is zero, there are some style sheets within the selection but they are not consistent.</p>
<pre><code>(short) pgNewParStyle (pg_ref pg, par_info_ptr new_style);
(void) pgRemoveParStyle (pg_ref pg, short style_id);
(short) pgNumParStyles (pg_ref pg);
(short) pgGetParStyle (pg_ref pg, short style_id, par_info_ptr style);
(void) pgChangeParStyle (pg_ref pg, short style_id, par_info_ptr style, short draw_mode);
(void) pgSetParStyleSheet (pg_ref pg, select_pair_ptr selection, short style_id, short draw_mode);
(pg_boolean) pgGetParStyleSheet (pg_ref pg, select_pair_ptr selection, short PG_FAR *style_id);
</code></pre>
<p>All of the above functions are identical to their counterparts, but are used for paragraph format style sheets. HERMES Paige maintains a separate list for paragraph formats.</p>
<h3 id='tech-note-why-is-the-stylesheetid-negative'>TECH NOTE: Why is the <code>style_sheet_id</code> &quot;negative&quot;?</h3>
<blockquote><p>I was walking through the <code>style_info</code> records in the <code>pg_ref</code> and noticed that some of them have negative <code>style_sheet_id</code> values. How/why does this happen?</p>
</blockquote>
<p>If your <code>pg_ref</code> has any stylesheets applied to text, when you change any of that text to additional style attributes, HERMES Paige negates the <code>style_sheet_id</code>. This is how it keeps track of &quot;offspring&quot; style sheets; upōn closer inspection you might notice that the &quot;parent&quot; style sheet ID is the compliment (negation) of this value, i.e. of parent sheet is 17, a
<code>style_info.style_sheet</code> id of -17 was originally style number 17 before changes were made.</p>
<h3 id='tech-note-can-i-build-style-sheets-from-scratch'>TECH NOTE :Can I build style sheets from scratch?</h3>
<blockquote><p>Would it be possible for me to set up the style_info records myself and put my own <code>style_sheet</code> id, then use <code>pgAddStyleInfo</code>, or would this cause problems for HERMES Paige?</p>
</blockquote>
<p>Actually, I do not think that method will work… and in fact after investigating the source code more carefully there are some problems with my suggestions to implement &quot;global&quot; stylesheets.</p>
<p>First, I&#39;ll outline what the problems are and then I&#39;ll suggest workarounds.</p>
<p>Problem number 1 is the fact that HERMES Paige maintains style sheet ID&#39;s in ways that you might not expect. For example, to keep track of &quot;clone&quot; stylesheets (sheets that get altered slightly but still affected by global changes), HERMES Paige negates the stylesheet ID so it knows who the &quot;parent&quot; style is. Due to this, I have a feeling your <code>pg_ref</code> would get messed up if you start assigning your own ID&#39;s.</p>
<p>Problem number 2 has to do with a field in <code>style_info</code> called <code>used_ctr</code>. This field gets incremented for every occurrence of that style in the text stream and gets decremented every time that style is deleted from the text. Once it decrements to zero, HERMES Paige will <em>delete</em> the <code>style_info</code> record. For &quot;stylesheet&quot; info records, however, it starts the <code>used_ctr</code> at 1 so it doesn&#39;t get deleted, except at the moment of calling the delete-stylesheet function, in which case the <code>used_ctr</code> is decremented so it deletes once no text is using it.</p>
<p>The reason no. 3 is a problem is that HERMES Paige forces this field to zero when you add new <code>style_info</code> records, even if you only use the lower-level <code>pgAddStyleInfo</code>.</p>
<h4 id='workarounds'>Workarounds</h4>
<p>I think you will be better off by literally adding stylesheets the &quot;normal&quot; way (e.g. <code>pgNewStyle</code>, <code>pgChangeStyle</code>, etc.), also don&#39;t try to force your own &quot;ID&quot; into the <code>target pg_ref</code>.</p>
<p>When I say don&#39;t &quot;force your own ID&quot; I mean just let HERMES Paige assign ID&#39;s to the stylesheets. That doesn&#39;t mean you can&#39;t have your own ID&#39;s (such as your resource ID&#39;s) and it also does not mean you even need to do anything with the stylesheet ID&#39;s that HERMES Paige returns. But, I wouldn&#39;t mess with <code>stylesheet_id</code> in the style_info records.</p>
<p>In light of this, I would slightly modify my suggestions in the last message as follows:</p>
<ul>
<li>To find out if a stylesheet already exists in a <code>pg_ref</code>, use <code>pgFindStyleSheet</code> to do an actual comparison against your style(s).</li>
<li>To change a stylesheet &quot;globally&quot; (for example, opening a doc and applying a changed global stylesheet to the opened doc), also use <code>pgFindStyleSheet</code> to see if it exists, then change it by referring to it with the &quot;local&quot; ID HERMES Paige returns from that function.</li>
<li>To make it really solid, I would use one of the <code>refcon</code> fields in the <code>style_info</code> record to store my own &quot;ID&quot; numbers to identify exact style sheets. Specifically, the fields you can choose from in <code>style_info</code> for this purpose are <code>user_id</code>, <code>user_data</code>, and <code>user_data2</code>. Remember that HERMES Paige sees no significance on any of these fields, but they can mean something to your app—original resource ID&#39;s for example. Note that <code>pgFindStyleSheet</code> allows a <code>mask</code> to compare only certain fields. An interesting approach would be to slap in your own &quot;ID&quot; in one of the <code>user_</code><em>xxx</em> fields, then simply compare that one field for locating stylesheets in question.</li>

</ul>
<p>As for not using an &quot;invisible&quot; <code>pg_ref</code>, that&#39;s no problem if you do something along the line of my above suggestions.</p>
<h2 id='tech-note-building-paragraph-styles-from-scratch'>TECH NOTE: Building paragraph styles from scratch</h2>
<blockquote><p>When creating a Paragraph Style Sheet, does the <code>par_info</code> record need to be filled out completely?</p>
</blockquote>
<p>Yes.</p>
<blockquote><p>If so.... how does one fill in the fields in the <code>par_info</code> record such as <code>style_sheet_id</code>, <code>procs</code>, <code>maintenance</code>, and <code>used_ctr</code>?</p>
</blockquote>
<p>This is actually ultra-simple and takes only one line of code. You simply begin with a &quot;default <code>par_info</code>&quot; record that you get from HERMES Paige globals. If your potential style sheet is called <code>MyParStyleSheet</code>, you do the following to initialise:</p>
<pre><code>par_info MyParStyleSheet;
MyParStyleSheet = paige_globals.def_par;
</code></pre>
<p>The <code>paige_globals</code> is of course your <code>pg_globals</code> <code>struct</code> given originally to <code>pgInit</code>. The above statement copies the default paragraph style, including all the default hooks, etc., into your paragraph style. Furthermore this method guarantees compatibility with any future versions (even if we add stuff to <code>par_info</code> such as new hooks, your style will get initialised correctly).</p>
<blockquote><p>Does the paragraph style sheet mechanism ignore [some] fields?</p>
</blockquote>
<p>I think it might ignore <code>style_sheet_id</code> in this case and I know it always ignores <code>used_ctr</code> and <code>maintenance</code>. But that shouldn&#39;t matter if you do the above.</p>
<h2 id='316-named-styles'>31.6 &quot;Named&quot; Styles</h2>
<p>&quot;Named&quot; styles differ from HERMES Paige&#39;s ordinary style sheets by combining both <code>style_info</code> and <code>par_info</code> style sheets into one, composite format that can be applied to the document. The composite style sheet can be given a name, and can be applied by calling the appropriate HERMES Paige function using the name only.</p>
<h3 id='functions'>Functions</h3>
<pre><code>long pgNewNamedStyle (pg_ref pg, pg_char_ptr stylename, const style_info_ptr style, const font_info_ptr font, par_info_ptr par);
</code></pre>
<p>Creates a new, named style sheet and keeps the resulting style in <code>pg</code>.</p>
<p>The <code>stylename</code> parameter is the name of the style; this is a <code>cstring</code> and can be from 1 to 64 bytes long (including the terminating null character). If the same, exact named style already exists it is replaced by this style.</p>
<p>The <code>style</code>, <code>font</code>, and <code>par</code> parameters define the text style, font and paragraph formats, respectively. However, any of these parameters can be NULL, in which case only the non-NULL attributes are applied.</p>
<p>For example, a NULL <code>par</code> parameter indicates that only text formatting (not paragraph formatting) will be change when this stylesheet is applied to text. If <code>style</code> is <code>NULL</code>, only <code>font</code> and/or <code>par</code> would be applied; if font is <code>NULL</code>, the style (if non-<code>NULL</code>) is applied using the current font of the targeted text.</p>
<p>Creating a new named style sheet does not affect the document until you apply it to one or more characters using the functions listed below.</p>
<p>A value is returned from this function, which will be an &quot;index&quot; number, identifying this style, that you can use with some of the functions listed here that require an index value. This index number is optional; you can ignore it and still apply the style sheet to the text by using its name.</p>
<pre><code>long pgAddNamedStyle (pg_ref pg, pg_c_string_ptr stylename, const short style_id, const short par_id);
</code></pre>
<p>This function does the same thing as <code>pgNewNamedStyle</code> except that existing style sheet ID number(s) are provided instead of <code>style_info</code> and <code>par_info</code> records.</p>
<p>If the named style already exists, <code>style_id</code> and <code>par_id</code> replace the style and paragraph styles.</p>
<p>A value is returned from this function, which will be an &quot;index&quot; number, identifying this style, that you can use with some of the functions listed here that require an index value. This index number is optional — you can ignore it and still apply the stylesheet to the text by using its name.</p>
<pre><code>void pgApplyNamedStyle (pg_ref pg, select_pair_ptr selection, pg_char_ptr stylename, short draw_mode);
</code></pre>
<p>The style sheet identified by <code>stylename</code> is applied to the text within the specified <code>selection</code>. If <code>selection</code> is <code>NULL</code>, the current <code>selection</code> is used. Text is redrawn using the <code>draw_mode</code> parameter (or not redrawn if <code>draw_mode == draw_none</code>).</p>
<p>If <code>stylename</code> does not exist, this function does nothing.</p>
<p>Since <code>stylename</code> represents a composite style (text and paragraph), each of them get applied differently. If a text style (<code>style_info</code>) is part of the style, only the characters within the selection are changed; if a paragraph format (<code>par_info</code>) is part of the style, the whole paragraph(s) within the selection are changed.</p>
<p>Hence, if you want to apply the <code>style_info</code> to entire paragraph(s) you must provide a selection range that covers the paragraph(s), otherwise you may not get the expected results.</p>
<pre><code>void pgApplyNamedStyleIndex (pg_ref pg, select_pair_ptr selection, long index, short draw_mode);
</code></pre>
<p>This is identical to <code>pgApplyNamedStyle()</code> except the style sheet is identified by its index number (the value returned from <code>pgNewNamedStyle</code>.</p>
<pre><code>pg_boolean pgGetAppliedNamedStyle (pg_ref pg, select_pair_ptr selection, pg_char_ptr stylename);
</code></pre>
<p>Returns the named style, if any, that is currently applied to the specified selection.</p>
<p>If there is indeed a named style applied, the name is returned in <code>stylename</code>.</p>
<p><strong>NOTE:</strong> The selection range can have other style(s) applied, in which case <code>pgGetAppliedNamedStyle()</code> might still return <code>TRUE</code> if the text also contains the style sheet.</p>
<pre><code>long pgNumNamedStyles (pg_ref pg);
</code></pre>
<p>Returns the number of named style sheets in <code>pg</code>. The number of named stylesheets is simply the number you have created; it does not necessarily mean any of them are applied to any text in the document.</p>
<pre><code>pg_boolean pgGetNamedStyle (pg_ref pg, long named_style_index, named_stylesheet_ptr named_style);
</code></pre>
<p>Returns the named style record for <code>named_style_index</code>. The <code>index</code> is any value between 1 and <code>pgNumNamedStyles()</code>.</p>
<p>If the style sheet exists, the <code>named_style</code> record is initialised and the function returns <code>TRUE</code>. If <code>named_style</code> is <code>NULL</code>, the function merely returns <code>TRUE</code> if <code>named_style_index</code> is valid. The <code>named_style</code> structure is defined as follows:</p>
<pre><code>struct named_stylesheet
{
	pg_char name[FONT_SIZE];
	short stylesheet_id;
	short par_stylesheet_id;
};
</code></pre>
<p>The <code>stylesheet_id</code> and <code>par_stylesheet_id</code> are the style and paragraph stylesheets, respectively. If either are zero they are not a part of this composite style.</p>
<pre><code>long pgGetNamedStyleIndex (pg_ref pg, pg_char_ptr stylename);
</code></pre>
<p>Returns the <code>index</code> value for style sheet <code>stylename</code>, if one exists. This will be a number between 1 and <code>pgNumNamedStyles()</code> if <code>stylename</code> was found; else, zero.</p>
<pre><code>void pgDeleteNamedStyle (pg_ref pg, long named_style_index);
</code></pre>
<p>Deletes the named style indicated by <code>named_style_index</code>. The &quot;index&quot; value can be anything between 1 and <code>pgNumNamedStyles()</code>.</p>
<p><strong>NOTE:</strong> The text is not affected by this function, even if a style is deleted that has been applied to one or more characters. (The characters will still retain that style until some other action changes their format).</p>
<pre><code>void pgRenameStyle (pg_ref pg, long named_style_index, pg_char_ptr style_name);
</code></pre>
<p>Renames the style indicated by <code>named_style_index</code> to a new name given as <code>style_name</code>. The <code>index</code> value can be anything between 1 and <code>pgNumNamedStyles()</code>.</p>
<h1 id='32-style-walkers'>32 STYLE WALKERS</h1>
<h2 id='321-walker-record-structure'>32.1 Walker record structure</h2>
<p>The following record structure is passed to certain low-level hooks (and can also be used for complex style and format manipulations):</p>
<!-- typedef 1 -->
<p>HERMES Paige uses this structure to &quot;walk&quot; through a run of style (including paragraph styles). In other words, given a starting position in text, HERMES Paige will initialise a <code>style_walk</code> to reflect that position&#39;s style, font and paragraph format; then, by calling special &quot;style walker&quot; functions, the style information can increment or decrement so the current formatting is always known. The purpose of the <code>style_walk</code> method is to avoid the necessity to constantly look up the style, font or paragraph info while walking through a series of text bytes.</p>
<p>From top to bottom, each field can be described as follows:</p>
<ul>
<li><p><code>current_offset</code> — Indicates the current, absolute offset (from beginning of text) in the <code>pg_ref</code>.</p>
</li>
<li><p><code>cur_style</code> — A pointer to the <em>current</em> <code>style_info</code> record.</p>
</li>
<li><p><code>cur_par_style</code> — A pointer to the <em>current</em> <code>par_info</code> record.</p>
</li>
<li><p><code>cur_font</code> — A pointer to the <em>current</em> <code>font_info</code> record.</p>
</li>
<li><p><code>next_style_run</code> — A pointer to the <em>next</em> <code>style_run</code> record for styles. To determine the number of bytes from current position to next style, the formula is:</p>
<pre><code>style_walk.next_style_run -&gt; offset - style_walk.current_offset;
</code></pre>
</li>
<li><p><code>next_par_run</code> — A pointer to the <em>next</em> <code>style_run</code> record for paragraph styles. To determine the number of bytes from current position to next paragraph style, the formula is:</p>
<pre><code>style_walk.next_par_run -&gt; offset - style_walk.current_offset;
</code></pre>
</li>
<li><p><code>prev_style_run</code> — A pointer to the <em>previous</em> (or &quot;current&quot;) <code>style_run</code> record for styles. To determine the total number of bytes for this style (number of bytes this style applies to), the formula is:</p>
<pre><code>style_walk.next_style_run -&gt; offset - style_walk.prev_style_run -&gt; offset;
</code></pre>
</li>
<li><p><code>prev_par_run</code> — A pointer to the <em>previous</em> (or &quot;current&quot;) <code>style_run</code> record for paragraph styles. To determine the total number of bytes for this paragraph style (number of bytes this paragraph style applies to), the formula is:</p>
<pre><code>style_walk.next_par_run -&gt; offset - style_walk.prev_par_run -&gt; offset;
</code></pre>
</li>
<li><p><code>style_base</code> — A pointer to the first <code>style_info</code> record (element 0 of <code>style_info</code> array). This is used to index the <code>style_info</code> records quickly.</p>
</li>
<li><p><code>par_base</code> — pointer to the first <code>par_info</code> record (element 0 of <code>par_info</code> array). This is used to index the <code>par_info</code> records quickly.</p>
</li>
<li><p><code>font_base</code> — A pointer to the first <code>font_info</code> record (element 0 of <code>font_info</code> array). This is used to index the <code>font_info</code> records quickly.</p>
</li>
<li><p><code>last_font</code> — Contains the font index number for the pointer at <code>cur_font</code>. The purpose of this is to avoid reïnitialising <code>cur_font</code> for every style change if the font remains the same.</p>
</li>
<li><p><code>t_length</code> — The <em>total</em> length of text for the <code>pg_ref</code> associated to this <code>style_walk</code>.</p>
</li>
<li><p><code>superimpose</code> — Used for a temporary workspace when building a subset of style_info based on super_impose_var, all_caps_var, small_caps_var or all_lower_var.</p>
</li>

</ul>
<h2 id='322-note-on-stylerun-records'>32.2 Note on <code>style_run</code> records</h2>
<p>The last element in a <code>style_run</code> array is a &quot;dummy&quot; entry whose <code>offset</code> field will be greater than the total text size of the <code>pg_ref</code>. For example, if the total text size of a <code>pg_ref</code> is 100 bytes, the final element in the array of <code>style_run</code> records will contain a value in <code>style_run.offset</code> of &gt; 100.</p>
<p>Hence, if you are examining a walker to determine the amount of text that applies to a style, be sure to account for this.</p>
<p>For example, if <code>walker.next_style_run -&gt; offset</code> is <em>greater than</em> <code>walker.t_length</code>, use <code>walker.t_length</code> in your calculations. The same is true for <code>walker.next_par_run</code>.</p>
<h2 id='323-walker-functions'>32.3 Walker Functions</h2>
<p>HERMES Paige provides the following functions to support a <code>style_walk</code> record:</p>
<h3 id='prepare-style-walk'>Prepare style walk</h3>
<pre><code>(void) pgPrepareStyleWalk (paige_rec_ptr pg, long offset, style_walk_ptr walker, pg_boolean include_pars);
</code></pre>
<p>To initialise a <code>style_walk</code> record, call <code>pgPrepareStyleWalk</code>. The <code>offset</code> parameter should contain the starting text offset (relative to the start of all text). When this function returns, the <code>style_walk</code> pointed to by <code>walker</code> will be initialised to the styles of <code>offset</code>.</p>
<p>Once you are through using the <code>style_walk</code>, make one more call to <code>pgPrepareStyleWalk</code>, but pass <code>NULL</code> for <code>walker</code>; this tells the HERMES Paige code you are through using the fields. Every <code>pgPrepareStyleWalk</code> must eventually be <em>balanced</em> with a second call with NULL.</p>
<p>The purpose of the <code>include_pars</code> parameter is to enhance the speed when walking through style runs, but the caller does not care about paragraph format runs: if <code>include_pars</code> is <code>FALSE</code>, <code>pgPrepareStyleWalk</code> will only initialise the walker for style runs (not paragraph formats)—in which case all paragraph format-related fields in the walker will be null pointers. If <code>include_pars</code> is <code>TRUE</code> then all paragraph format runs will be included. Generally, if the intention is to examine only <code>style_info</code> runs, <code>include_pars</code> should be FALSE.</p>
<h3 id='using-pgpreparestylewalk'>Using pgPrepareStyleWalk</h3>
<pre><code>style_walk walker;
pgPrepareStyleWalk(pg, 0, &amp;walker);
// style_walk code goes here
pgPrepareStyleWalk(pg, 0, NULL);
// tells HERMES Paige I&#39;m through
</code></pre>
<p>This function advances the styles in <code>walker</code> by amount bytes. The <code>amount</code> parameter can be negative, in which case the styles are <em>decremented</em>.</p>
<p>All this does is reset the fields in <code>walker</code> to reflect the styles that apply to the current text position (in <code>walker</code>) + <code>amount</code>. If the same style, font and paragraph format applies to all text, you would keep getting the same answers regardless of the value in amount. The function result from <code>pgSetWalkStyle</code> returns <code>TRUE</code> if the style has changed from the previous setting. For example, if the style applied to the current text position (before <code>pgSetWalkStyle</code>) is Plain, and calling <code>pgSetWalkStyle</code> now sits on text that is <strong>Bold</strong>, the function returns <code>TRUE</code>.</p>
<h3 id='walk-nextprevious-style'>Walk next/previous style</h3>
<pre><code>(pg_boolean) pgWalkNextStyle (style_walk_ptr walker);
(pg_boolean) pgWalkPreviousStyle (style_walk_ptr walker);
</code></pre>
<p>These function advance <code>walker</code> forward to the next or previous text style, respectively, and, if appropriate, to the next or previous paragraph style. The amount from the current position to the next text style is passed to <code>PgWalkStyle</code> for <code>amount</code>. It is the developer&#39;s responsibility to determine that there really <em>is</em> another style before making this call. (Another style exists if <code>walker.next_style_run -&gt; offset</code> is less than <code>walker.t_length</code>). The function result from <code>pgSetWalkStyle</code> returns <code>TRUE</code> if the style has changed from the previous setting. For example, if the style applied to the current text position (before <code>pgSetWalkStyle</code>) is Plain, and calling pgSetWalkStyle now sits on text that is <strong>Bold</strong>, the function returns <code>TRUE</code>.</p>
<h3 id='set-walk-style'>Set walk style</h3>
<pre><code>(pg_boolean) pgSetWalkStyle (style_walk_ptr walker, long position);
</code></pre>
<p>This function sets all fields in <code>walker</code> to reflect the styles that apply to <code>position</code>. The <code>position</code> parameter is absolute, <em>i.e.</em> it is the amount in bytes from the beginning of all text. The result of this function is identical to <code>pgPrepareStyleWalk</code> except <code>walker</code> must already be initialised. The function result from <code>pgSetWalkStyle</code> returns <code>TRUE</code> if the style has changed from the previous setting. For example, if the style applied to the current text position (before <code>pgSetWalkStyle</code>) is Plain, and calling <code>pgSetWalkStyle</code> now sits on text that is <strong>Bold</strong>, the function returns TRUE.</p>
<h1 id='33-windows-character-widths'>33 WINDOWS CHARACTER WIDTHS</h1>
<p>HERMES Paige contains a low-level function you can use to force specific character widths for any given text format.</p>
<p>For example, a cross-platform, HERMES Paige-based application might need to render exact, identical placement of characters drawn in the same font between Macintosh and Windows. As most developers realise, the subtle differences between fonts, even between fonts that are supposedly the same family and type, will not always render the same text widths between platforms, or between changing resolution or printers.</p>
<p>The following function has been created to help with a solution:</p>
<pre><code>void SetFontCharWidths (pg_ref pg, style_info_ptr style, int PG_FAR *charwidths);
</code></pre>
<p>This function causes the rendering of all text drawing in <code>style</code> to match pre-determined character widths defined in <code>charwidths</code>.</p>
<p>The <code>charwidths</code> table must be a pointer to 256 <code>int</code> values, each element must correspond to that same ordinal value of the style&#39;s character set. For example, <code>charwidths[0]</code> represents the width of a null (0) character; <code>charwidths[&#39; &#39;]</code> represents the width of a space character, <code>charwidths[&#39;A&#39;]</code> represents the width for an &quot;A&quot; character, etc.</p>
<p><strong>NOTE:</strong> The character table applies only the precise, composite text format represented by the style parameter. This includes the associated <code>font_info</code> record (which is defined by the value in <code>style -&gt; font_index</code>).</p>
<p>After this function is called, any text that is drawn in the precise format represented by <code>style</code> will be rendered using the widths in <code>charwidths</code>.</p>
<h5 id='notes-30'>NOTES:</h5>
<ol start='' >
<li>The function prototype for <code>SetFontCharWidths()</code> is defined in <code>pgtraps.h</code>.</li>
<li><code>SetFontCharWidths()</code> makes a copy of the character widths; hence, you do not need to keep its array of <code>int</code> values around.</li>
<li>The <code>pg</code> parameter is required to have access to HERMES Paige globals as well as access to a font table (unique to the <code>pg_ref</code>). However, the character table you set becomes universal and global for all <code>pg_ref</code>s that use exactly the same style.</li>

</ol>
<h1 id='34-file-handlers'>34 FILE HANDLERS</h1>
<p><strong>CAUTION:</strong> Nearly every file input/output issue can be addressed by referring to chapter 22, <a href='#22-file-standards-input-and-output'>File Standards, Input, and Output</a>. Rarely will a developer need this chapter on File Handlers.</p>
<p>In fact, if you are looking to this chapter to help solve an input/output issue, you should probably contact<!-- DataPak--> Tech Support <!-- via email--> to see if it is absolutely necessary. In nearly every case, the content of chapter 22 (see above) will be sufficient to handle file saving and retrieving.</p>
<h2 id='341-file-sub-system'>34.1 File Sub-system</h2>
<p>The basic ingredients necessary to achieve the feature set listed above are:</p>
<ol start='' >
<li>Documents are saved exclusively as a series of components, where each component contains a standard &quot;header&quot; identifying the data type and length followed by the data, and</li>
<li>HERMES Paige structures are saved and read as a series of component values, never as a single structure. Hence, upward compatibility and even backward compatibility becomes possible since every version reads only the field(s) it understands.</li>
<li>Numbers (or relative addresses) are stored as hexadecimal characters.</li>
<li>For specialized cases that require the application to bypass normal sequential i/o within a data component, an alternate read and write function can be privately assigned to that data component.</li>

</ol>
<h3 id='data-components'>Data Components</h3>
<p>A HERMES Paige document is saved to a file as a series of data components, each component being independent of the other. It does not matter what order they are saved (or what order they are read when the file is open) and it does not matter if strange or unrecognized components are embedded anywhere in the file stream.</p>
<p>Every component consists of:</p>
<ul>
<li>A header defining the data type and its length</li>
<li>The data, which immediately follows the header</li>

</ul>
<p>When a file is &quot;opened&quot; and each component is scanned, if HERMES Paige recognizes the data type (in the component header) it processes the information; if it does not recognize the data type it can simply skip over it. Thus, compatibility between versions, platforms and applications become possible since no single unknown component can throw HERMES Paige for a spin or crash the application.</p>
<p><strong>NOTE:</strong> The term <em>file</em> is being used here only to describe sequentially stored data. This does not always imply a physical file on disc. An HERMES Paige &quot;file&quot; can just as well be a block of memory such as the system scrap or &quot;clipboard&quot; or it could be a sequence of bytes sent over a modem, or any other type of medium that might support data transfer.</p>
<h2 id='342-hermes-paige-handler-functions'>34.2 HERMES Paige &quot;Handler&quot; Functions</h2>
<h3 id='how-file-data-is-recognized'>How File Data is Recognized</h3>
<p>The term <em>handler</em> is used here to describe a function which handles reading or writing a specific data component. Within HERMES Paige, there are specific functions to handle each piece of data from a HERMES Paige object; a set of pointers to these functions are maintained using the following record:</p>
<pre><code>typedef struct
{
	pg_file_key key;		// Parameter file key
	pg_short_t flags;	// Internal use
	pg_handler_proc read_handler;	// Called to handle &quot;read&quot; data
	pg_handler_proc write_handler;	// Called to handle &quot;write&quot; data
	file_io_proc read_data_proc;		// To read data
	file_io_proc write_data_proc;		// To write data
}
pg_handler, PG_FAR *pg_handler_ptr;
</code></pre>
<p>HERMES Paige maintains an array of <code>pg_handler</code>, essentially one element for each data component that can be saved to a file. The key field in the <code>pg_handler</code> record contains a unique code that is included in the data component for which the handler is responsible.</p>
<p><code>write_handler</code> and <code>read_handler</code> — contain pointers to functions that will process the data component that is transferred to or from the file, respectively.</p>
<p>Both handler functions are declared as follows:</p>
<pre><code>PG_PASCAL (pg_boolean) pg_handler_proc (paige_rec_ptr pg, pg_file_key key, memory_ref key_data, long PG_FAR *element_info, void* aux_data, long *unpacked_size);
</code></pre>
<p>When a <code>pg_handler_proc</code> is called, <code>pg</code> contains the record structure of the HERMES Paige object being written (or read into). The <code>key</code> parameter will contain the key code that will be written to the data component header (if writing) or the key code that has been found in the header (if reading). The key will be identical to the value found in the <code>pg_handler</code> associated with this function.</p>
<p><code>key_data</code> — is a <code>memory_ref</code> (memory allocation) that must be filled in with data to write (when writing) or contains the data that has been read (when reading).</p>
<p><code>element_info</code> — parameter is an optional value that can be included in the header when writing and will be read and provided to this function when reading; <code>aux_data</code> is used by HERMES Paige internally to provide information for some of the standard handlers (<code>aux_data</code> is ignored for all &quot;custom&quot; handlers added to the <code>pg_handler</code> list by the app) — see the Table <!-- on page 730-->&quot;Standard Handlers&quot;, which describes what each of these parameters will hold for standard handlers.</p>
<p><code>unpacked_size</code> — parameter is a pointer to a <code>long</code> which the handler function must set to the actual (physical) size of the data being read or written, in bytes. This may differ from the byte size in <code>key_data</code>.</p>
<p>For example, suppose a special read handler is used for compressed text (ASCII text compressed in some way). The size of <code>key_data</code> might be much smaller than the uncompressed text size that is inserted into the <code>pg_ref</code>. In this case, <code>*actual_size</code> should be set to the uncompressed size, since it is the &quot;real&quot; size of the data.</p>
<p>For writing, <code>*actual_size</code> should be set to the original size of the data that will be written to the file. In a similar example of compressed text, <code>*actual_size</code> in the case of a write handler should be the uncompressed size of text (text size before it is compressed into <code>key_data</code>).</p>
<p><strong>FUNCTION RESULT:</strong> Both functions must return <code>TRUE</code> if it is through handling this key.</p>
<p><strong>NOTE:</strong> A <code>TRUE</code> is the usual and normally expected response; the purpose of a possible <code>TRUE</code> or <code>FALSE</code> result is for special read/write cases where the same key is handled more than once. A <code>FALSE</code> result essentially tells HERMES Paige to call the handler function again (see “Repetitive Handler Loops&quot; below).</p>
<p><strong>CAUTION:</strong> For simple read or write handlers, be sure to return <code>TRUE</code> or an endless loop can result! See <a href='#repetitive-handler-loops'>Repetitive Handler Loops</a> under section 34.2.</p>
<h3 id='read-and-write-data-functions'>Read and Write Data Functions</h3>
<p>The <code>read_data_proc</code> and <code>write_data_proc</code> contain the function that will physically read the data to be processed by the handler function or to write the data processed by the handler function, respectively. For &quot;normal&quot; HERMES Paige data components, these will get set to the standard i/o function, but either can be changed by the application for custom data transferring that is local and private to the respective component.</p>
<h3 id='writing'>Writing</h3>
<p>When writing to a file, each individual &quot;handler&quot; function is called to write its own data component. This is fairly straightforward because HERMES Paige simply walks through the list of available <code>pg_handler</code> records and calls each <code>write_handler</code> function, one at a time.</p>
<h3 id='reading'>Reading</h3>
<p>When reading a file, if the component is recognized (i.e., if HERMES Paige can find a <code>pg_handler</code> that contains the same key as found in the component header), the handler is called to process the data.</p>
<p>For example, when a file was saved, the write handlers typically saved blocks of text, style records, paragraph formats, font records, etc., all as individual components, each with its own code (from the <code>key</code> field in its <code>pg_handler</code> record) to identify the data type. When this file is &quot;opened&quot;, the components are read, one by one; if the data type is recognized, which is to say if a <code>pg_handler</code> record can be found that contains its code, its <code>read_handler</code> function is called to process the data; if the type is not recognised, i.e. if no handler can be found to match, it is skipped.</p>
<p>This simultaneously guarantees future compatibility since no single data element involves hardcodes recognition and allows applications to save their own data structures by installing their own <code>pg_handler</code>s. If some other application or platform read the file, the unrecognized data components are simply skipped with no adverse effect!</p>
<h3 id='repetitive-handler-loops'>Repetitive Handler Loops</h3>
<p>In certain situations, it may be required for HERMES Paige to call the same read or write handler more than once.</p>
<p>An example of this would be saving a huge data structure by breaking it into smaller components, writing each component as a separate &quot;key.&quot;</p>
<p>One way to accomplish this is to return <code>FALSE</code> from a write handler which results in the same handler function to get called again; HERMES Paige will keep calling the handlers until <code>TRUE</code> is returned.</p>
<p>Additionally, the value set (by you) in <code>*element_info</code> will remain unchanged between repetitive read-handler calls, so you can use that feature to know what to do (or where you are in the data, etc.) for each repetitive loop. The first time the handler function gets called, HERMES Paige will set <code>*element_info</code> to zero.</p>
<h3 id='repetitive-write-handlers'>Repetitive Write Handlers</h3>
<p>Writing more than one data component using the same write handler is accomplished in the same way as repeating read handlers (by returning <code>FALSE</code> and using <code>*element_info</code>).</p>
<p>However, when using a write handler in this fashion, it may be important to observe the following:</p>
<ul>
<li>The value your write handler places in <code>*element_info</code> will be what gets written to the data component&#39;s header. Later when your read handler is called, the same value in <code>*element_info</code> that was associated with the same data component will be given to you.</li>
<li>Remember that your data component is written after you return from the write handler (whereas data has already been read when a read handler is called). While this may seem obvious, it could prove to be an important point (see next item below).</li>
<li>When you return from your write handler, HERMES Paige will not write any additional data if the data component you just processed has a byte size of zero. This is an important &quot;feature&quot; since you can terminate the repetitive loop if there is no more data to write by setting <code>key_data</code> to zero size and returning <code>TRUE</code>.</li>

</ul>
<p>For example, you could set up the first data component in a series of (potentially) many and return <code>FALSE</code> (indicating you want to get called again). On the subsequent call, however, you discover there are no more data components to be written; therefore, you can simply call <code>SetMemorySize(key_data, 0)</code> and return <code>TRUE</code> indicating you are through.</p>
<h2 id='343-installing-handlers'>34.3 Installing Handlers</h2>
<p><strong>NOTE:</strong> If you will simply be saving HERMES Paige documents in the standard manner without any additional data, you may skip this section completely.</p>
<p>The most basic method of saving an HERMES Paige document is to use only the standard, &quot;built-in” handlers. If that is all your application needs to do (if you simply want to save HERMES Paige objects with no special data types or custom handlers), you do not need to install any handlers as the defaults will be initialised automatically.</p>
<p>If you need to save or read additional data types, you can install your own handler(s) by calling the following function:</p>
<pre><code>(void) pgSetHandler (pg_globals_ptr globals, pg_file_key key, pg_handler_proc read_handler, pg_handler_proc write_handler, file_io_proc read_data_proc, file_io_proc write_data_proc);
</code></pre>
<ul>
<li><p><code>globals</code> - must point to the same structure given to <code>pgInit</code>.</p>
</li>
<li><p><code>key</code> — is the handler ID number you wish to install; this can be one of the predefined handler keys or it can be a custom ID specific to your application.</p>
</li>
<li><p><code>read_handler</code> and <code>write_handler</code> — should contain a pointer to a valid <code>pg_handler_proc</code> function, or <code>NULL</code>. These are the functions that will get called to handle data components that have been read or components that are to be written, respectively. If either parameter is <code>NULL</code> then the existing function for that key, if any, is left unchanged (or, if no handler yet exists for that key the standard, i.e., default, function is assumed). For example, to change only the read handler for a specific key, you would pass a pointer in <code>read_handler</code> and <code>NULL</code> for <code>write_handler</code>.</p>
</li>
<li><p><code>read_data_proc</code> and <code>write_data_proc</code> — should be either a <code>NULL</code> pointer, or point to a valid <code>file_io_proc</code> (see section 34.5, <a href='#The-`file_io_proc`'>The <code>file_io_proc</code></a>). If non-<code>NULL</code>, the respective function will get called to physically read or write the data to the file for that key; if <code>NULL</code>, the existing I/O function for that key remains unchanged (or, if no handler yet exists for that key the standard, i.e., default, function is assumed).</p>
<p><strong>NOTE:</strong> Setting a handler that already exists simply replaces the function pointers in that handler per the parameters given above; if the handler does not exist, it is added.</p>
<p>If you want to get a copy of an existing handler, call the following:</p>
<pre><code>(pg_error) pgGetHandler (pg_globals_ptr globals, pg_handler_ptr handler);
</code></pre>
</li>

</ul>
<ul>
<li><p><code>globals</code> — must be a pointer to the same structure given to <code>pgInit</code>.</p>
</li>
<li><p><code>handler</code> — parameter must point to a <code>pg_handler</code> record (cannot be null); however, you only need to set the key field for the handler you wish to get a copy of. When the function returns, a copy of the <code>read_handler</code> and <code>write_handler</code> will be put into the handler record provided.</p>
<p>If the handler is not found (if no existing handler matches with the value you put in the <code>pg_handler</code>&#39;s key field), <code>NO_HANDLER_ERR</code> is returned.</p>
</li>

</ul>
<p>The following is a list of the standard handler &quot;key&quot; codes; if you want to read and write special data using your own unique code, you should always define it at least greater or equal to the <code>#define</code> <code>CUSTOM_HANDLER_KEY</code>.</p>
<p><code>CONTROL_MOD_BIT</code> is used mainly with &quot;arrow&quot; keys. This causes the selection to advance to the next word (right arrow) or to the previous word (left arrow).</p>
<pre><code>// Macintosh-specific keys

typedef enum
{
	mac_pict_key = PLATFORM_SPECIFIC_KEY,	// Mac Pictures
	mac_control_key,						// Mac Control
	mac_sound,								// Sound record
	mac_quicktime, 							// Quicktime Pic
	mac_print_key,							// Mac print record
	mac_rgb_key,							// RGBColor
	mac_code_rsrc,							// Mac code resource
	mac_quickdraw,							// QuickDraw object
	mac_custom_object,						// Custom object
	mac_dsi_extend1,						// Reserved DSI 1
	mac_dsi_extend2							// Reserved DSI 2
};
#define CUSTOM_HANDLER_KEY(PLATFORM_SPECIFIC_KEY + 1024)
// App can use this for keys.
</code></pre>
<p><code>key</code> codes can be any 16-bit value but must be positive numbers.</p>
<p><strong>NOTE:</strong> Contact <!-- DataPak Software via electronic mail or fax --> regarding registering keys which you wish to make public with <!-- DataPak -->. <!-- DataPak--> will assist you in assigning numbers which will prevent duplication between applications. Those wanting to read custom data <em>must</em> use the author signature settings.</p>
<p>When used against keys, the author will let you know when you have your own document and not some other app&#39;s. See section 34.14, <a href='#3414-application-signature'>Application Signature</a>.</p>
<h3 id='removing-handlers'>Removing Handlers</h3>
<p>To completely remove a handler, call the following:</p>
<pre><code>(pg_error) pgRemoveHandler(pg_globals_ptr globals, pg_file_key key);
</code></pre>
<p>This function removes the handler indicated in <code>key</code>. If no such handler exists, the function returns <code>NO_HANDLER_ERR</code>.</p>
<h3 id='settingresetting-standard-handlers'>Setting/Resetting Standard Handlers</h3>
<p>If you want to restore the list of <code>pg_handlers</code> to the defaults, call the following:</p>
<pre><code>(void) pgInitStandardHandlers (pg_globals_ptr globals);
</code></pre>
<p><code>globals</code> is a pointer to the same structure given to <code>pgInit</code>.</p>
<p>This function reinitialises the list of <code>pg_handlers</code> to the defaults, and it will remove all custom handlers that have been installed.</p>
<p>The usual reason for calling <code>pgInitStandardHandlers</code> is to remove all custom handlers you have installed and/or to restore any you might have deleted.</p>
<p>You do not need to call <code>pgInitStandardHandlers</code> if you have not installed, changed or deleted any handlers, nor do you need to call <code>pgInitStandardHandlers</code> if you want to leave the handlers as-is throughout the application session.</p>
<h2 id='344-reading-certain-data-only'>34.4 Reading certain data only</h2>
<p>This feature is for using HERMES Paige to open only a few file keys in a document. For example one might want to open format and shapes of a document, but not the text, or perhaps display the text using a different format. This is used to implement stationery or templates.</p>
<p>HERMES Paige handles such partial reads as follows:</p>
<p>Reading only certain data elements—but not all—is possible by passing a list of file keys to <code>pgReadDoc</code> that specify which elements to include for reading; HERMES Paige will skip over all other keys that are not in this list.</p>
<p>However, reading only certain data components from an HERMES Paige file might require some knowledge of dependencies among these components.</p>
<p><strong>CAUTION:</strong> For example, if you read the HERMES Paige text (by virtue of including <code>text_key</code> in the list of file keys to be read), you <em>must</em> also include <code>text_block_key</code> or the file can crash; yet if you read no text at all then you <em>must not</em> include <code>text_block_key</code>.</p>
<p>On the other hand, if you elect to read only <code>style_info</code> records but no text, then you <em>must not</em> read the style run information (because the &quot;run&quot; info will contain offsets into text that will not exist).</p>
<p>The following guidelines should therefore be observed:</p>
<ul>
<li><p>You must always include <code>paige_key</code> regardless of how many (or how few) other keys are used. The <code>paige_key</code> must also be the first element in the key list given to <code>pgReadDoc</code>.</p>
</li>
<li><p>To read &quot;text only&quot; without any styles, include ONLY the following keys, in this order:</p>
<ul>
<li><code>paige_key</code></li>
<li><code>text_block_key</code></li>
<li><code>text_key</code></li>

</ul>
</li>
<li><p>You can also read &quot;text only&quot; without styles and include certain other data items such as &quot;shapes&quot; by including:</p>
<ul>
<li><code>paige_key</code></li>
<li><code>text_block_key</code></li>
<li><code>text_key</code></li>
<li><code>vis_shape_key</code></li>
<li><code>page_shape_key</code></li>
<li><code>exclude_shape_key</code></li>

</ul>
</li>
<li><p>To read everything <em>except</em> text, include all the keys you want to read <em>except for</em> the following:</p>
<ul>
<li><code>text_block_key</code></li>
<li><code>text_key</code></li>
<li><code>line_key</code></li>
<li><code>style_run_key</code></li>
<li><code>par_run_key</code></li>
<li><code>selections_key</code></li>

</ul>
</li>
<li><p>If you read <code>style_info</code> records (by including <code>style_info_key</code> in the read), you <em>must</em> also include <code>font_info_key</code> or else using the styles <em>will</em> crash.</p>
</li>

</ul>
<h3 id='using-pgreaddoc-for-only-the-style-info-from-an-hermes-paige-file-saved-with-pgsavedoc'>Using <code>pgReadDoc</code> for only the style info from an HERMES Paige file saved with <code>pgSaveDoc</code></h3>
<p>The following is an example of reading only the styles from an HERMES Paige file and omitting the text:</p>
<pre><code>pg_ref newPG;
pg_file_key keys[3];
keys[0] = paige_key;	// Always include this one
keys[1] = style_info_key;
keys[2] = font_info_key;	// Must include this if style_key wanted

newPG = pgNewShell(&amp;paige_globals);
pgReadDoc(newPG, &amp;filePosition, keys, 3, NULL, filemap);
</code></pre>
<p><strong>CAUTION:</strong> IN ABOVE EXAMPLE: The usual reason for reading style_info records is to obtain a list of styles to apply to some other <code>pg_ref</code>. If you start &quot;using&quot; the <code>pg_ref</code> above, i.e. if text is inserted and formatted, many of its <code>style_info</code> records will be removed! This is because HERMES Paige will delete
style_info records that are not applied to any text (which will not occur until you attempt to apply new styles or change the text). The exception to this is the existence of stylesheet records: those will not be deleted.</p>
<h2 id='345-the-fileioproc'>34.5 The <code>file_io_proc</code></h2>
<p>If you want to provide your own function for reading or writing, the function pointer given to <code>pgSaveDoc</code> or <code>pgReadDoc</code> must be declared as follows:</p>
<pre><code>PG_PASCAL (pg_error) file_io_proc (void* PG_FAR data, short verb, long PG_FAR *position, long * data_size, file_ref filemap);
</code></pre>
<p>This will get called whenever <code>pgSaveDoc</code> wants to write something, or when <code>pgReadDoc</code> wants to read something.</p>
<p>The <code>data</code> parameter points to the data to be written (if this is a write function), or a pointer to the data to be read (if this is a read function); for read functions, <code>*data</code> will contain enough space to read the data requested.</p>
<p><strong>CAUTION:</strong> The <code>data</code> parameter is not always a pointer, sometimes it is a <code>memory_ref</code> indicated by the <code>verb</code> <code>parameters</code> - see below.</p>
<pre><code>typedef enum
{
	io_data_direct,		// Read or write data directly
	io_data_indirect,	// Read or write data in/from memory_ref
	io_get_eof			// Return file size
};
</code></pre>
<p>If <code>verb</code> is <code>io_data_direct</code>, <code>data</code> is a pointer to the contents to be read to or written from.</p>
<p>If <code>verb</code> is <code>io_data_indirect</code>, the <code>data</code> parameter is a <code>memory_ref</code> (not a pointer to the data). Read functions must set the appropriate memory size of data and set its contents to the bytes read from the file; for write functions, the byte to be written are contained in data.</p>
<p>If <code>verb</code> is <code>io_get_eof</code>, this function should set <code>*data</code> to the byte offset for end-of-file. (HERMES Paige will call this function with <code>verb == io_get_eof</code> to know how large the input file is; hence, if you require any kind of logical end of file, such as reading only a part of a file, you can set that value at this time).</p>
<p>position - is a pointer to the file offset to read or write. The file offset is always relative to the start of the file.</p>
<p>data_size — will point to a long word containing the number of bytes to transfer.</p>
<p>filemap — contains the machine-specific reference to use for file I/O. (The standard Macintosh file_io_proc assumes filemap contains a file reference).</p>
<p>For reading or writing (as opposed to getting end of file for <code>verb = io_get_eof</code>), this function must do the following: </p>
<ol start='' >
<li>Transfer the data,</li>
<li>Update the <code>*position</code> by adding to it the number of bytes transferred,</li>
<li>Set <code>*data_size</code> to the actual bytes transferred (which will usually be the same as requested, barring file errors), and </li>
<li>Return any errors, or 0 for no errors.</li>

</ol>
<p>The function result must be 0 for no errors (successful) or some kind of error code (unsuccessful). The error code should be a HERMES Paige-defined error—see chapter 39, <a href='#39-error-codes'>Error Codes</a>.</p>
<h3 id='tech-note-will-the-file-fit'>TECH NOTE: Will the file fit?</h3>
<blockquote><p>I want to be able to check the disk to see if my file will fit before I call pgSaveDoc. How do I check to see if my data will fit on the disk?</p>
</blockquote>
<p>You can check for the actual size that will be created before a save simply by using a custom <code>write_io_proc</code>. The <code>proc</code> will simply increment the offset for each of the kinds of data you want to save. It will count the times it is called and be multiplied by the size of the data being saved. You don&#39;t actually write during the proc, just advance the counter. It will then pass back the eventual position and will be very fast.</p>
<h2 id='346-reading--writing-soft-files-and-transferring-to-the-scrap'>34.6 Reading &amp; Writing &quot;Soft&quot; Files (and transferring to the &quot;scrap&quot;)</h2>
<p>It may be desirable to transfer a file to something other than a disc file, such as to and from a block of memory, some communication line, etc.</p>
<p>To do so, you simply replace the <code>file_io_proc</code> with one of your own, or if you simply read and write to &quot;memory&quot; you can pass a built-in function for this purpose, <code>pgScrapMemoryRead</code> (for reading) and <code>pgScrapMemoryWrite</code> (for writing).</p>
<p>The following is an example of &quot;writing&quot; a document to the Macintosh &quot;scrap&quot; by simply replacing the <code>file_io_proc</code> with a custom version to fill in a <code>Handle</code> and calling <code>pgSaveDoc</code>:</p>
<pre><code>// This function &quot;writes&quot; HERMES Paige object pg to the scrap.
#include &quot;defprocs.h&quot;	// must include this for prototype of pgScrapMemoryWrite

void PutToScrap (pg_ref pg)
{
	file_ref data_ref;
	Ptr scrap_data;
	long file_position;
	
	/* Our &quot;filemap&quot; will simply be a memory_ref that will get filled with the data that is &quot;written&quot; */
	
	filemap = MemoryAlloc(&amp;paige_rsrv.mem_globals, sizeof(pg_char), 0, 0);
	file_position = 0;
	pgSaveDoc(pg, &amp;file_position, NULL, 0, memory_write_proc, filemap, 0);
	scrap_data = UseMemory (filemap);
	PutScrap(file_position, PG_SCRAP_TYPE, scrap_data);
	UnuseMemory(filemap);
	DisposeMemory(filemap);
}
</code></pre>
<h5 id='notes-31'>NOTES</h5>
<ol start='' >
<li>For a thorough understanding of the memory functions in the above example, see chapter 25, <a href='#25-the-allocation-manager'>The Allocation Manager</a>.</li>
<li>Both <code>pgScrapMemoryRead</code> and <code>pgScrapMemoryWrite</code> are defined in <code>defprocs.h</code>. For both functions, the <code>filemap</code> is simply a <code>memory_ref</code> created by your application; pgScrapMemoryRead will &quot;read&quot; from the contents of the <code>memory_ref</code> as if it were a file, and <code>pgScrapMemoryWrite</code> will set the <code>memory_ref</code>&#39;s contents as if it were a file being written to.</li>
<li>We encourage <em>Macintosh</em> developers to use the above method—or a similar method—for transferring HERMES Paige objects to the scrap, because the read/write handler scheme can be ultra compatible between diverse applications, and even between platforms, hence it could be an excellent standard.</li>

</ol>
<h2 id='347-writing-your-own-handlers'>34.7 Writing your Own Handlers</h2>
<p>Almost without exception, applications will usually have one or more data elements that need to be saved along with an HERMES Paige document. If nothing else, an app will typically want to save the window size or position and other similar items.</p>
<p>The best (and most compatible) way to save your own data elements is to save each data type (using the function provided below), and create your own &quot;read&quot; handlers that will recognize the data when the file is opened.</p>
<h3 id='writing--saving'>Writing / Saving</h3>
<p>In actual practice, you don&#39;t really need to create a &quot;write handler&quot; function as such for saving custom data. In fact, in many situations the creation of a write handler function (given to <code>pgSaveDoc</code> to call) will reveal difficult situations for your application.</p>
<p>While this may appear inconsistent with the information in this section, it is not. To write your data components, you should first call <code>pgSaveDoc</code> and then save your data using the following low-level function that HERMES Paige provides for this purpose:</p>
<pre><code>#include &quot;pgFiles.h&quot;
(pg_error) pgWriteKeyData (pg_ref, pg_file_key key, void PG_FAR *data, long data_length, long element_info, file_io_proc io_proc, file_io_proc data_io_proc, long PG_FAR *file_position, file_ref filemap);
</code></pre>
<p><strong>NOTE:</strong> You need to <code>#include</code> <code>pgFiles.h</code> to use the above function.</p>
<p>This function takes a data component and a file key and writes them to the specified file offset in the standard HERMES Paige format (so it can be processed later from <code>pgReadDoc</code>).</p>
<ul>
<li><code>key</code> - parameter must be your file key (the value to be recognized later, during <code>pgReadDoc</code>, that will match up with your installed read handler).</li>
<li><code>data</code> — must point to the data you wish to save and data_length must contain the data size, in bytes; the data can be anything and length can be any size (assuming it will successfully fit on file).</li>
<li><code>element_info</code> — can also be any value you want; whatever this is, it gets saved in the data component header and will be returned to you in the <code>element_info</code> parameter when your read handler function is called later on.</li>
<li><code>io_proc</code>, <code>file_position</code> and <code>filemap</code> — are (and should be) identical to the same parameters you would gave to <code>pgSaveDoc</code>.</li>
<li><code>data_io_proc</code> — is an optional pointer to a different function that should write the physical data to the file. This function is effectively the same as the <code>write_data_proc</code> function that exists in a handler record. If this function is <code>NULL</code> then the same I/O function given in <code>io_proc</code> is used (or if <code>io_proc</code> is also <code>NULL</code> then the standard default write function is used).</li>
<li><code>file_position</code> — parameter, in particular, should point to the value of the file offset that was set when <code>pgSaveDoc</code> returned—it is assumed that you first called <code>pgSaveDoc</code>, then called $p g$ WriteKeyData above, hence the ending file offset after <code>pgSaveDoc</code> should be the starting file offset of <code>pgWriteKeyData</code>.</li>

</ul>
<h3 id='reading-2'>Reading</h3>
<p>To read the document saved above, you must install your own read handlers to process all the custom data elements saved. Each read handler should contain the same code given to the key parameter when the data was written with <code>pgWriteKeyData</code>.</p>
<p>The read handler you install will contain a pointer to a function (which you create) declared as follows:</p>
<pre><code>PG_PASCAL (pg_boolean) pg_handler_proc (paige_rec_ptr pg, pg_file_key key, memory_ref key_data, long PG_FAR *element_info, void* aux_data, long PG_FAR *unpacked_size);
</code></pre>
<p>In the process of reading the document (by <code>pgReadDoc</code>), when a file key is found to match one of your handlers, your function, as defined above, will get called.</p>
<ul>
<li><p><code>key</code> — parameter will be the file key that matched your handler (which could be important if you installed, say, the same function for several different data components).</p>
</li>
<li><p><code>key_data</code> — will contain the data — the same data you wrote when you called <code>pgWriteKeyData</code>. The data size will be:</p>
<pre><code>size_of_data = GetMemorySize(key_data);
</code></pre>
</li>
<li><p><code>element_info</code> — will point to a long word containing the value you originally gave to <code>element_info</code> when calling <code>pgWriteKeyData</code>.</p>
</li>
<li><p><code>aux_data</code> — is to be ignored (except in special cases noted elsewhere in this document).</p>
</li>

</ul>
<p>The way you process the data, what you do with it, etc., is completely up to you; pgReadDoc does not care what happens with this data.</p>
<p><strong>CAUTION:</strong> The <code>key_data</code> allocation will get disposed when you return from this function; therefore you need to copy its data if necessary because it will not be preserved.</p>
<h5 id='notes-32'>NOTES:</h5>
<ol start='' >
<li>When you install your read handler, be sure to include a function pointer to the &quot;write handler&quot; even though it won&#39;t get called, otherwise HERMES Paige will try to delete the handler. You can simply plug the same function pointer in both read and write handler fields.</li>
<li>By not installing one or more appropriate read handlers for your data, those data items in the file will simply be skipped; <code>pgReadDoc</code> will not crash. (Your app, however, might crash if you completely depend on the items saved if it never sees them).</li>

</ol>
<h3 id='using-hermes-paige-to-save-and-read-a-picture'>Using HERMES Paige to save and read a picture</h3>
<p>The following is an example of saving a Macintosh picture to an HERMES Paige file, then reading that picture from the file when it is opened:</p>
<h4 id='saving'>Saving</h4>
<pre><code class='language-c' lang='c'>/* This function accepts a PicHandle and all the other things previously given to pgSaveDoc and writes the picture to the file in the standard HERMES Paige fashion. An error, if any, is returned. */

short save_mac_pict (pg_ref pg, PicHandle the_pict, file_position *offset, file_io_proc io_proc, file_ref filemap)
{
	short error;
	long data_size;
	data_size = GetHandleSize((Handle) the_pict);
	HLock((Handle) the_pict);
	error = pgWriteKeyData(pg, mac_pict_key, *pict, data_size, 0, io_proc, NULL, offset, filemap);
	HUnlock((Handle) the_pict);
	return error;
}
</code></pre>
<h4 id='reading-3'>Reading</h4>
<pre><code class='language-c' lang='c'>// The read handler I need to install:

PG_PASCAL (void) ReadPictHandler (paige_rec_ptr pg, pg_file_key key, memory_ref key_data, long PG_FAR *element_info, void *aux_data);

/* This function gets called BEFORE pgReadDoc to install the readpicture handler.*/

void setup_pict_handler (void)
{
	pgSetHandler(&amp;paige_rsrv, mac_pict_key, ReadPictHandler, NULL, NULL, NULL);
}

/* The function below will get called by HERMES Paige sometime during the pgReadDoc */

PG_PASCAL (void) ReadPictHandler (paige_rec_ptr pg, pg_file_key key, memory_ref key_data, long PG_FAR *element_info, void *aux_data)
{
	PicHandle read_pict;
	Ptr data_ptr;
	long data_size;
	data_size = GetMemorySize(key_data);
	read_pict = (PicHandle) NewHandle(data_size);
	data_ptr = UseMemory(key_data);
	BlockMove(data_ptr, *read_pict, data_size);
	UnuseMemory(key_data);
	
/* At this point, you would do &lt;&lt; whatever &gt;&gt; with the PicHandle, such as place it in a global, insert it into the text stream, etc. */
}
</code></pre>
<p>NOTE: The sample does not install a &quot;write handler&quot; since the data was written with <code>pgWriteKeyData</code>.</p>
<h2 id='348-about-pgrefs-in-handler-functions'>34.8 About <code>pg_ref</code>(s) in Handler Functions</h2>
<p>It is often necessary to obtain the <code>pg_ref</code> from within a handler function. However, you will notice that the handler function provides you with a <code>paige_rec_ptr</code>, not a <code>pg_ref</code>.</p>
<h3 id='getting-a-pgref-from-an-hermes-paige-record-pointer'>Getting a <code>pg_ref</code> from an HERMES Paige record pointer</h3>
<p>To get the <code>pg_ref</code>, assuming the <code>paige_rec_ptr</code> parameter is called &quot;pg&quot;, simply do this:</p>
<pre><code>pg_ref the_pg_ref;
the_pg_ref = pg -&gt; myself;
</code></pre>
<h2 id='349-special-initialising-handlers'>34.9 Special &quot;Initialising&quot; Handlers</h2>
<p>Not all of the handler key codes are used to transfer data to and from files.</p>
<p><code>format_init_key</code> — is used to signal the application that a style, paragraph or font record has been loaded from a file. This gives an application a chance to initialise any of these records, setting custom function pointers, etc.</p>
<p>Also, the <code>format_init_key</code> is used to inform your application when the file begins and ends, i.e. &quot;prepare-to-read/prepare-to-write&quot; and &quot;end-read/end-write&quot;.</p>
<p>The <code>format_init_key</code> has a <code>verb</code> which indicates which is being initialised; this <code>verb</code> value is given in <code>key_data</code>. Coërcing <code>key_data</code> will indicate one of the following:</p>
<pre><code>enum
{
	init_start_verb,	// Prepare for file read
	init_style_verb,	// style_info init
	init_font_verb,		// font_info init
	init_par_verb,		// par_info init
	init_end_verb		// File is done
}
</code></pre>
<p><code>init_start_verb</code> and <code>init_end_verb</code> — are given to flag &quot;begin&quot; and &quot;end&quot; of the read or write session for the file.</p>
<p>The other <code>verb</code>s work as follows: For every <code>style_info</code>, <code>par_info</code>, or <code>font_info</code> record that is fully reconstructed after reading data from a file, the appropriate handler function is called (if one exists) for the respective key (<code>style_init_key</code>, <code>par_init_key</code>, or <code>font_init_key</code>).</p>
<p>When this occurs, the <code>aux_data</code> parameter points to the appropriate structure to initialise; the <code>element_info</code> parameter points to the structure element number (which element in the array of the styles, paragraph styles or fonts).</p>
<p>For example, if the handler for <code>format_init_key</code> is called, <code>*aux_data</code> will be a <code>style_info_ptr</code>, which you would coërce as follows:</p>
<pre><code>style_info_ptr style_to_init;
style_to_init = *aux_data;
</code></pre>
<p>Function pointers in <code>style_info</code> and <code>par_info</code> records will be set to the default functions before being passed to the initialisation handler.</p>
<h3 id='the-extra-struct-handler'>The &quot;Extra Struct&quot; Handler</h3>
<p>Since application-specific elements usually comprise the contents of <code>extra struct</code> (set with <code>pgSetExtraStruct</code>, etc. See section 3.10, <a href='#310-storing-arbitrary-references-and-structures'>Storing Arbitrary References and Structures</a>), when HERMES Paige writes this data it makes consecutive calls to the write handler for each extra <code>struct</code> entry.</p>
<p>When doing so, the parameters are set as follows:</p>
<ul>
<li><code>element_info</code> points to the extra <code>struct</code> ID number</li>
<li><code>aux_data</code> points to the long data set in extra <code>struct</code>.</li>

</ul>
<p>When the write handler is called, you must fill <code>key_data</code> with the appropriate data to write.</p>
<p>When the extra <code>struct</code> data is read later on, HERMES Paige will call the read handler, passing the data in <code>key_data</code>, and <code>*element_info</code> with the original <code>element_info</code> given to you (and possibly modified by your function). However, for read handlers, HERMES Paige won&#39;t do anything with the data — you must call <code>pgSetExtraStruct</code>, or whatever else is appropriate from within your extra struct read handler.</p>
<h5 id='notes-33'>NOTES:</h5>
<ol start='' >
<li>HERMES Paige does not call the write handler for extra <code>struct</code>s that are zero.</li>
<li>When returning from a write handler for extra struct, HERMES Paige will write whatever is contained in <code>*element_info</code>. You can therefore modify <code>*element_info</code> contents, if so desired, and you will be fed that information during a read handler when the document is opened.</li>

</ol>
<h2 id='3410-the-exception-handler'>34.10 The Exception Handler</h2>
<p>There is one additional handler key—the <code>exception_key</code>—that does not transfer data; rather, it is used to report an error.</p>
<p>If any errors occur during file transfer, HERMES Paige will call the <code>exception_key</code> handler function, if any. When this occurs, it is the responsibility of the handler function to handle the error as follows: upon entry, the <code>element_info</code> parameter will point to the error code (which will be one of the values defined in <code>pgErrors.h</code>).</p>
<p>If the handler function decides to continue the file transfer, it must set <code>*element_info</code> to zero (i.e., <code>*element_info = 0</code>); to abort the transfer, leave <code>*element_info</code> alone (or set some other appropriate non-zero error code).</p>
<p><strong>NOTE:</strong> It is generally a good idea to continue file transfer, i.e. set <code>*element_info</code> to zero, if <code>NO_HANDLER_ERROR</code> is given. It is also a good idea to set <code>*element_info</code> to zero if <code>GLOBALS_MISMATCH_ERROR</code> is given (see next section). Otherwise, you will defeat the ability to &quot;skip&quot; over unrecognised data elements. The <code>NO_HANDLER_ERROR</code> is passed to the exception handler mostly as a debugging tool.</p>
<p>(See also chapter 39, <a href='#39-error-codes'>Error Codes</a>.)</p>
<h2 id='3411-document-specific-pgglobals'>34.11 Document-specific <code>pg_globals</code></h2>
<p>There might be certain cases when you want to change the behavior of an application if an HERMES Paige-based document is opened which was originally saved with a different <code>pg_globals</code> than the defaults.</p>
<p>Considering localisation issues, for example, might demand that you keep a set of <code>pg_globals</code> for each document in case different values were used for decimal tab, a different default script such as Kanji, etc.</p>
<p>A file saved (in version 1.01 and greater) includes a copy of the critical fields of <code>pg_globals</code> at the time it was saved; when that file is reopened and one or more critical field(s) of the original globals does not match the current fields in <code>pg_globals</code>, the exception_key handler is called indicating the mismatch.</p>
<p>By &quot;critical fields&quot; is meant the portions of <code>pg_globals</code> that are typically changed by the application (as opposed to volatile static values such as function pointers) such as character values, default style and default font.</p>
<p>To recognize a &quot;globals mismatch&quot; between the current settings and the document currently being read, set a handler for the exception_key and observe the following:</p>
<ul>
<li>When and if document-specific globals do not match the current globals, the <code>exception_key</code> handler is called.</li>
<li>The &quot;error&quot; given to the <code>exception_key</code> handler is <code>GLOBALS_MISMATCH_ERROR</code>.</li>
<li>The document-specific globals (just read) will be contained in a <code>memory_ref</code> in the &quot;last_message&quot; field of the memory globals.</li>

</ul>
<h3 id='access-globals-record'>Access globals record</h3>
<p>To access the &quot;new&quot; globals record you would do something like the following (the &quot;<code>pg</code>&quot; parameter is assumed to be the <code>paige_rec_ptr</code> passed to the <code>exception_key</code> handler function):</p>
<pre><code>memory_refdoc_globals_ref;
pg_globals_ptr doc_globals;
doc_globals_ref = (memory_ref) pg -&gt; globals -&gt; mem_globals -&gt; last_message;
doc_globals = UseMemory(doc_globals_ref);

// do whatever you want with these doc-specific globals

UnuseMemory(doc_globals_ref);
</code></pre>
<ul>
<li>HERMES Paige does not change any existing globals, rather it is your responsibility and/or decision to handle the globals mismatch any way you see fit. HERMES Paige merely reports that the globals are different and provides those settings in the last_message field.</li>
<li>The usual response before returning from the exception_key handler is to set *element_info to NO_ERROR (i.e., claim the exception was handled and therefore no file errors are pending - bsee previous section). Otherwise pgReadDoc will raise an exception and abort the reading process (which is probably not what you want).</li>

</ul>
<h2 id='3412-saving--reading-multiple-pgrefs'>34.12 Saving &amp; Reading Multiple <code>pg_ref</code>(s)</h2>
<p>Many applications have the need to save more than one <code>pg_ref</code> to a file. For example, an application that employs &quot;headers&quot; (each one a <code>pg_ref</code>) may need to save these along with the main body.</p>
<h3 id='saving-multiple-refs'>Saving Multiple Refs</h3>
<p>Steps to saving multiple <code>pg_ref</code>s to one file are as follows:—</p>
<ol start='' >
<li>Set a long-word variable to zero (or to the desired file position if you aren&#39;t saving the document to position 0). Let&#39;s call this variable <code>filePosition</code>.</li>
<li>Call <code>pgSaveDoc()</code> for the first <code>pg_ref</code>, passing <code>filePosition</code> for the <code>file_position</code> parameter. You do not need to set any special file handlers (unless you are saving something else that requires it); just pass <code>NULL</code> for the <code>keys</code> parameter.</li>
<li>Call <code>pgTerminateFile()</code>, passing filePosition once again.</li>
<li>If you have another <code>pg_ref</code> to save, simply repeat steps 2 and 3 above.</li>

</ol>
<p>That is all there is to saving multiple <code>pg_ref</code>s. The only important thing to remember is to leave <code>filePosition</code> alone after step 1.</p>
<h3 id='reading-multiple-refs'>Reading Multiple Refs</h3>
<p>The method outlined below for reading multiple <code>pg_ref</code>s assumes you already know in advance how many <code>pg_ref</code>s there are in the file (if this is not the case see the section below, “Unknown HERMES Paige Object Quantities”).</p>
<ol start='' >
<li>As in saving, set a long-word variable to zero (or to whatever the first file position is for the first pg_ref that was saved). We will call this <code>filePosition</code>.</li>
<li>Create a new <code>pg_ref</code> if you have not already (you can use <code>pgNew()</code> or <code>pgNewShell()</code> depending upon your requirements).</li>
<li>Call <code>pgReadDoc()</code> passing <code>filePosition</code> and the newly created <code>pg_ref</code>.</li>
<li>If there is another <code>pg_ref</code> to read, repeat 2 and 3.</li>

</ol>
<h3 id='unknown-hermes-paige-ref-quantities'>Unknown HERMES Paige Ref Quantities</h3>
<p>The steps to retrieve multiple <code>pg_ref</code>s shown above assumes you know, in advance, how many <code>pg_ref</code>s are contained in the file. If that is not the case, the recommended method for determining the number of <code>pg_ref</code>s is to use <code>pgVerifyFile()</code> after each <code>pgReadDoc()</code> to verify whether or not there is another valid HERMES Paige element.</p>
<p>The intended purpose for using <code>pgVerifyFile()</code> is to verify whether or not a file is truly an HERMES Paige file as opposed to something else (like a text file). However, this function can also be used as a test for multiple <code>pg_ref</code>s: after each <code>pgReadDoc()</code>, if <code>pgVerifyFile()</code> returns <code>NO_ERROR</code>, then the current file position is, in fact, another HERMES Paige file.</p>
<h4 id='example-of-method-2-unknown-hermes-paige-ref-quantities'>Example of Method 2, Unknown HERMES Paige Ref Quantities</h4>
<pre><code>#include &quot;pgErrors.h&quot;
/* The following function reads an undetermined number of multiple pg_refs written to a file. For demonstration purposes we are assuming the first pg_ref was written to the physical beginning of the file. Upon entry, fileRef is the file ID (a file opened for read access, specific to your OS). The &quot;refs&quot; parameter is a pointer to an array of pg_refs, large enough to hold the most possible pg_refs that will be in a file. The function result is the number ofpg_refs successfully read. */

int ReadMultiplePG (int fileRef, pg_ref *refs)
{
	long filePosition, oldPosition;
	memory_ref fileMap;
	short PG_FAR *file;
	int readQty;
	pg_ref pg;
	
	// Set up what HERMES Paige expects for the &quot;filemap&quot; param:
	
	fileMap = MemoryAlloc(&amp;mem_globals, sizeof(short), 1, 0);	
	file = (*short *) UseMemory(fileMap);
	*file = (short)fileRef;
	UnuseMemory(fileMap);
	filePosition = oldPosition = 0; // Set first file pos
	// (Note, &quot;oldPosition&quot; is only used for a work-around to a 1.2 bug)
	readQty = 0;

	while (pgVerifyFile(fileMap, NULL, &amp;filePosition) != NO_ERROR
	{
		pg = MakeNewPG(); // This would be whatever your app does for new pg_ref
		refs[readQty] = pg; // Place in caller&#39;s array
		
		// Read the next object:
		if (pgReadDoc (pg, &amp;filePosition, NULL, 0, NULL, filemap) != NO_ERROR)
			break;		// Exit if errorΩ
			
		// Since successful read, increment the quantity read
		
		readQty++;
	}
	DisposeMemory(fileMap);
	return readQty;
}
</code></pre>
<h2 id='3413-bypassing-standard-io'>34.13 Bypassing Standard I/O</h2>
<p>There are certain cases when you need to write your own data structure directly to the file.</p>
<p>For <em>Macintosh</em>, an example might be writing a QuickTime movie in which a built-in system function is required that will write its own data by passing a file reference. For such cases it is desirable to temporarily bypass HERMES Paige&#39;s standard I/O function when the physical data for a specific key is read or written.</p>
<p>As mentioned earlier, and handler can have its own private io_proc for reading and/or writing. Hence, the way to bypass the standard function for a specific key is to set the read or write function to one of your own.</p>
<h3 id='how-it-works'>How It Works</h3>
<p>The private read or write function for a handler is called only to read or write the physical contents of the data element, not the key actual header. For example, if you set a private write function for a picture, HERMES Paige will call your write function when it comes time to write the picture contents but after it has already written the key header (key ID, element info and data size), at which time the next file position will be passed to your write function.</p>
<p>The data size you write does not need to match the data size already written to the key header; HERMES Paige will adjust the header&#39;s data size if you return a new file position that is different than it expected.</p>
<p>Additionally, the &quot;data&quot; processed by the write handler (the handler for the file key, not the <code>io_proc</code>) does not necessarily need to be the same data that gets written by the I/O function.</p>
<p>For example, suppose you wanted to write the contents of a picture directly to the file. This could done by a write handler placing a mere reference to the picture into the data buffer (for Macintosh, the 4-byte <code>PicHandle</code> itself could be returned from the write handler as the <code>data</code> to be saved); then the private I/O function associated with the picture handler could take this <code>data</code> and write the real picture to the file. Note that the real data—the picture contents—might be hundreds of kilobytes but the data returned from the write handler was only 4 bytes. This &quot;trick&quot; is therefore a good way to write large data structures without the need to make a copy of the data.</p>
<h3 id='writing-pictures-directly'>Writing Pictures Directly</h3>
<p>The following example shows how a write handler + an associated private I/O function would write pictures directly to a file. You can use this example as a starting &quot;shell&quot; to write any similar structure.</p>
<pre><code>/* Prototype for the private write function for the picture data:*/
PG_PASCAL (pg_error) WritePictProc (void* data, short verb, long *position, long PG_FAR *data_size, file_ref filemap);

// The io_proc to write

/* The following function accepts a PicHandle to be written to the data file defined by the rest of the parameters. The &quot;refcon_info&quot; is &lt;whatever&gt; so you can identify what the picture is for later when the file is opened. In this example, the basic I/O proc is NULL (implying the standard) but the data-write function is WritePictProc -- which gets called to physically write the data. Note that I am passing off as &quot;data&quot; a pointer to the PicHandle itself. But what really happens eventually, by virtue of the WritePictProc is the contents the picture get written instead. */

static pg_error SavePicture (pg_ref pg, PicHandle the_pic, long *file_position, file_ref filemap, long refcon_info)
{ 
	return pgWriteKeyData(pg, mac_pict_key, &amp;the_pic, sizeof(PicHandle), refcon_info, NULL, WritePictProc, file_position, filemap);
}

/* WritePictProc gets called by HERMES Paige to physically write some data to the file. In this &lt; special&gt; case I have passed a PicHandle as the &quot;data&quot; whose size is sizeof(PicHandle) but I will really end up writing the picture contents. HERMES Paige will adjust the data element header to reflect the correct written size. */

PG_PASCAL (pg_error) WritePictProc (void* data, short verb, long *position, long PG_FAR *data_size, file_ref filemap)
{
	Handle pict, *data_ptr;
	pg_error error;
	
	data_ptr = data;	// This points to a PicHandle
	pict = *data_ptr;
	
	/* I will now make it easy on myself and call HERMES Paige&#39;s standard write function, but this time I am giving it the real data instead of the dummy &quot;data&quot; which was a pointer to a PicHandle */
	*data_size = GetHandleSize(pict);
	HLock (pict);
	error = pgStandardWriteProc(*pict, io_data_direct, position, data_size, filemap);
	HUnlock(pict);
	return error;
}
</code></pre>
<h3 id='important-tips--cautions'>Important Tips &amp; Cautions</h3>
<p>When writing your own I/O remember the following:</p>
<ul>
<li>When doing custom writes, HERMES Paige will not call your I/O write function if the write handler does not set <code>key_data</code>&#39;s memory size to at least 1 byte. This is because HERMES Paige will think there is nothing to write (which is a correct assumption since &quot;<code>zero data</code>&quot; is one of the legitimate ways to terminate a write handler being called repetitively). It is therefore necessary to return some kind of <code>data</code> from your handler even if it is only dummy &quot;data&quot; (consult the example above where a <code>PicHandle</code> is being used as the &quot;data&quot; so HERMES Paige is sure to call the write function).</li>
<li>The data and its byte size that is physically written when a write function is called can be completely different than what HERMES Paige thinks is being written. However, it is important to update the <code>*position</code> parameter to reflect correct, next sequential file positions—that is how HERMES Paige knows you write a different number of bytes than was originally expected.</li>
<li>You do not update the key header information—HERMES Paige does that for you if you wrote a different size than originally asked when the write function got called.</li>
<li>For read functions, the data size given to your function should be considered the literal, physical size of the data component. Regardless what/how you read the data you should always return with <code>*position</code> updated to <code>*position</code> + data size or <code>pgRead</code> might crash. Unlike write functions you must not try to change the file position to anything other than its starting position upon entry + data size upon entry.</li>
<li>When your io_proc is called, upon entry the file position will be the starting location after the key header. For write functions, that will be the next physical location following the header; for read functions, HERMES Paige will have already read the header information, the data size given will be the physical data size of the data component and the file position will be the first byte to read.</li>
<li>If you use <code>pgScrapMemoryWrite</code> or <code>pgScrapMemoryRead</code>—or some other special I/O function for general writing, make sure your private I/O functions for individual keys will handle this appropriately. For example, in the sample shown above for writing pictures, a call to <code>pgStandardWriteProc</code> will fail if <code>pgSaveDoc</code> gave <code>pgScrapMemoryWrite</code> as the general I/O function.</li>

</ul>
<h2 id='3414-application-signature'>34.14 Application Signature</h2>
<p>To avoid any possible conflict between your own custom handler ID&#39;s and other HERMES Paige-based files, you can set a unique <code>author</code> ID that gets saved with the document and that ID can be examined at any time during or after <code>pgReadDoc</code>.</p>
<p>To set or access such an identifier, use the following functions:</p>
<pre><code>(void) pgSetAuthor (pg_ref pg, long author);
(long) pgGetAuthor (pg_ref pg);
</code></pre>
<p>Calling <code>pgSetAuthor</code> stores author into <code>pg</code>; this value can be anything and is always saved along with a document if <code>pgSaveDoc</code> is called.</p>
<p>To get the current author value, call <code>pgGetAuthor</code>.</p>
<p>Both functions can be called at any time and can be called from within handler functions.</p>
<p><strong>NOTE (Macintosh):</strong> It is recommended that you use the same &quot;author&quot; ID that you are using to identify your own application signature (i.e. the &quot;creator&quot; <code>OSType</code>).</p>
<h3 id='reading-hermes-paige-files-from-other-developers'>Reading HERMES Paige files from other developers</h3>
<p>If you might be reading someone else&#39;s HERMES Paige file (that might have identical custom key values that you used), you should check your signature in the <code>author</code> field of the <code>paige_rec</code> given to you in the read handler:</p>
<pre><code>pg_boolean MyReadHandler(paige_rec_ptr pg, pg_file_key key, memory_ref key, memory_ref key_data, long PG_FAR *element_info, void PG_FAR *aux_data, long PG_FAR *unpacked_size)
{
	if (pg -&gt; author == ME)
	{
		// process the data...
	}
	// else do nothing
	return TRUE;
}
</code></pre>
<p><strong>NOTE:</strong> When your own file is saved, call <code>pgSetAuthor</code> to set a unique &quot;ID&quot; so you will recognise your own signature per the above example. The &quot;author&quot; field gets saved with the file.</p>
<h2 id='3415-a-quick-and-easy-empty-hermes-paige-object'>34.15 A Quick and Easy Empty HERMES Paige Object</h2>
<p>For the purposes of reading a file (<code>pgReadDoc</code>), it might be desirable to create a completely empty <code>pg_ref</code> without the requirement to pass many parameters to <code>pgNew</code>. To do so, you can call the following:</p>
<pre><code>(pg_ref) pgNewShell (pg_globals_ptr globals);
</code></pre>
<p>The <code>globals</code> parameter must be a pointer to the same structure given to <code>pgInit</code>.</p>
<p><strong>FUNCTION RESULT:</strong> This function will returns a new <code>pg_ref</code> that has nothing in it, including all shapes that are completely empty.</p>
<p>The idea is to pass this <code>pg_ref</code> to <code>pgReadDoc</code>, in which case every important data component, including <code>wrap_area</code> and <code>vis_area</code>, will get initialised.</p>
<p><strong>CAUTION:</strong> If for some reason you have suppressed the read handler for <code>vis_shape_key</code> and/or <code>page_shape_key</code> (which process the vis_area and shape_area), or if one of these shapes do not exist in the file, your <code>pg_ref</code> will result in an empty shape for the <code>vis_area</code> and/or page_area. This is because <code>pgNewShell</code> simply creates empty shapes assuming they will get set in <code>pgReadDoc</code>. An empty <code>vis_shape</code> will cause an HERMES Paige object to be completely &quot;invisible&quot; and an empty <code>page_area</code> can cause an HERMES Paige object to hang, crash or also be invisible.</p>
<h2 id='3416-examining-incoming-data'>34.16 Examining Incoming Data</h2>
<p>At times it may be necessary or desirable to examine some of the incoming data during the <code>pgReadDoc</code> process.</p>
<p>The way you can do this is to set your own handler function for the data you wish to examine, but call HERMES Paige&#39;s standard handler function to actually process it.</p>
<p>Although a unique function can be set for any handler key, HERMES Paige only uses one function for handling all standard keys for reading and one for all writing. The function for handling all standard keys, which is made public in <code>defprocs.h</code> is declared as follows:</p>
<pre><code>#include &quot;defprocs.h&quot;

(pg_boolean) pgReadHandlerProc (paige_rec_ptr pg, pg_file_key key, memory_ref key_data, long PG_FAR *element_info, void *aux_data, long PG_FAR *unpacked_size);
</code></pre>
<p>From your own handler function, you could first call <code>pgReadHandler</code> to bring in the information then you could examine the resulting contents within <code>pg</code>.</p>
<p><strong>NOTE:</strong> The read handler places the appropriate data into <code>pg</code>. (To learn exactly what is transferred for each file key, consult the table &quot;STANDARD HANDLERS&quot;<!-- on page 34-730 below-->).</p>
<h2 id='3417-standard-handler-data'>34.17 Standard Handler Data</h2>
<p>The following table shows what is transferred into a <code>paige_rec</code> for every call to the standard read handler. This information can be useful when implementing the <a href='#3416-examining-incoming-data'>Examining Incoming Data</a> method as given in section 34.16.</p>
<p>Generally, the table shows what each parameter contains when the read handler is called; this is assuming that the standard write handler originally saved the data. The associated data will exist within the <code>pg_ref</code> after the read handler returns.</p>
<p>NOTE: Unless specified otherwise, the contents of <code>key_data</code> are always &quot;packed&quot; into a special compressed format. If necessary, you can &quot;unpack&quot; the data by calling the standard read handler (see section 34.16, <a href='#3416-examining-incoming-data'>Examining Incoming Data</a>).</p>
<p> TABLE #7 | STANDARD HANDLERS |  |  |</p>
<figure class='table-figure'><table>
<thead>
<tr><th style='text-align:center;' >Handler Key</th><th style='text-align:left;' ><code>key_data</code> contents</th><th style='text-align:left;' ><code>*element_info</code></th><th style='text-align:center;' ><code>aux_data</code></th></tr></thead>
<tbody><tr><td style='text-align:center;' ><code>paige_key</code></td><td style='text-align:left;' >All non-<code>memory_ref</code> fields such as version, platform attributes, etc.</td><td style='text-align:left;' >— not used —</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>text_block_key</code></td><td style='text-align:left;' >Array of text blocks (<em>no text</em> or other mem structures will exist yet within the blocks).</td><td style='text-align:left;' >Number of records</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>text_key</code></td><td style='text-align:left;' >Text for <em>one</em> block (each block of text is saved separately, one belonging to each text block  record).</td><td style='text-align:left;' >Absolute byte offset for beginning of text</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>line_key</code></td><td style='text-align:left;' >Same as <code>text_key</code> except data is <code>array</code> of <code>point_start</code> records instead of text.</td><td style='text-align:left;' >Absolute byte offset for first record.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>style_run_key</code></td><td style='text-align:left;' >Array of <code>style_run</code> records.</td><td style='text-align:left;' >Number of records.</td><td style='text-align:center;' >- not used -</td></tr><tr><td style='text-align:center;' ><code>par_run_key</code></td><td style='text-align:left;' >(Same as <code>styles</code>).</td><td style='text-align:left;' >Number of records.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>style_info_key</code></td><td style='text-align:left;' >(Same as <code>styles</code> but data is <code>style_info</code>s).</td><td style='text-align:left;' >Number of records.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>par_info_key</code></td><td style='text-align:left;' >(Same as <code>styles</code> but data is <code>par_info</code>s).</td><td style='text-align:left;' >Number of records.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>font_info_key</code></td><td style='text-align:left;' >(Same as styles but data is  <code>font_info</code>s).</td><td style='text-align:left;' >Number of records.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>vis_shape_key</code></td><td style='text-align:left;' >Array of rectangles</td><td style='text-align:left;' >Number of rectangles.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>page_shape_key</code></td><td style='text-align:left;' >(Same as <code>vis_shape_key</code>).</td><td style='text-align:left;' >Number of rectangles.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>exclude_shape_key</code></td><td style='text-align:left;' >(Same as <code>vis_shape_key</code>).</td><td style='text-align:left;' >Number of rectangles.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>selections_key</code></td><td style='text-align:left;' >Array of <code>t_select</code> records.</td><td style='text-align:left;' >Number of records. (<strong>Note:</strong> this is number of <code>t_select</code>s, not pairs. Selection pairs will be <code>*element_info</code> / 2.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>extra_struct_key</code></td><td style='text-align:left;' >set by app only</td><td style='text-align:left;' >extra <code>struct</code> ID</td><td style='text-align:center;' ><code>*long</code> as set in extra <code>struct</code></td></tr><tr><td style='text-align:center;' ><code>applied_range_key</code></td><td style='text-align:left;' ><code>array</code> of <code>long</code>s</td><td style='text-align:left;' >Number of <code>long</code>s.</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>doc_info_keys</code></td><td style='text-align:left;' >The <code>doc_info</code> record</td><td style='text-align:left;' >— not used —</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>exception_key</code></td><td style='text-align:left;' >— not used —</td><td style='text-align:left;' >Error code</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>containers_key</code></td><td style='text-align:left;' ><code>array</code> of <code>long</code>s (<code>refCon</code>)</td><td style='text-align:left;' >— not used —</td><td style='text-align:center;' >— not used —</td></tr><tr><td style='text-align:center;' ><code>exclusion_key</code></td><td style='text-align:left;' ><code>array</code> of <code>long</code>s (<code>refCon</code>)</td><td style='text-align:left;' >— not used —</td><td style='text-align:center;' >— not used —</td></tr></tbody>
</table></figure>
<h2 id='3418-repetitive-write-handler-trick'>34.18 Repetitive Write Handler &quot;Trick&quot;</h2>
<p>Occasionally, if you write data from a write handler (as opposed to the &quot;direct&quot; approach of calling <code>pgWriteKeyData</code>) but need to do repetitive writes for several different data elements, it becomes necessary to write some data, return <code>FALSE</code> from the write handler, then get called again until you finally return <code>TRUE</code>.</p>
<p>For example, suppose you create a write handler to save multiple items embedded in a style run. Sometimes it proves useful to perform the &quot;repetitive write&quot;loop by returning <code>FALSE</code> from the handler so HERMES Paige calls your function repeatedly until all elements are written.</p>
<p>To help this situation, HERMES Paige always sets the <code>aux_data</code> parameter to a <code>long*</code> (pointer to a <code>long</code>), with the <code>long</code> set to zero the first time it calls your handler but left as is for the remaining calls.</p>
<p>What this provides is the ability to monitor your own reentrance.</p>
<p>For example, in the case of writing elements from each <code>style_info</code> record in the <code>pg_ref</code>, you might want to know which element was last written (so you know when to end the callbacks to the write handler). Basically, <code>aux_data</code> points to a <code>refcon</code> value that you can set to anything, and that value can be examined in each callback.</p>
<h3 id='using-auxdata-in-write-handlers-to-pass-data-to-yourself'>Using <code>aux_data</code> in write handlers to pass data to yourself</h3>
<pre><code>pg_boolean MyWriteHandler(paige_rec_ptr pg, pg_file_key key, memory_ref key_data, long PG_FAR *element_info, void PG_FAR *aux_data, long PG_FAR *unpacked_size)
{
long PG_FAR *counter;
counter = (long PG_FAR *)aux_data;
if (*counter == 0)	// being called for first time 
						// do whatever if called first time
counter += 1;			// This value will be in tact next time

// We might terminate when, say, the counter hits 10:
return (*counter == 10);
</code></pre>
<p><strong>CAUTION:</strong> The <code>aux_data</code> parameter only points to a long when it is not being used for something else, i.e. if the file key is one of the standard HERMES Paige keys that uses <code>aux_data</code> the above example will not work. As a rule, all &quot;custom&quot; key values are guaranteed to give you <code>aux_data</code> as a <code>long*</code>	to a <code>refCon</code> value initialised to zero when your handler is called for the first time, but all standard HERMES Paige keys (non-custom) will not necessarily provide this feature.</p>
<h1 id='35-shared-styles'>35 SHARED STYLES</h1>
<p>You can create ???putrefies??? that all &quot;share&quot; a common set of style, paragraph, font records and named style sheets. The purpose of this feature is to minimise the extra overhead required to save a large quantity of individual HERMES Paige documents and/or to provide a method to create a &quot;master document&quot;.</p>
<h2 id='351-setting-up'>35.1 Setting Up</h2>
<p>This feature is enabled by programming the following steps:</p>
<ol start='' >
<li><p>Create an empty <code>pg_ref</code> which you will keep in memory. This will be the &quot;master&quot; set of all text formats; subsequent <code>pg_ref</code> creations will &quot;share&quot; all the formats from the master. You probably won&#39;t ever display or draw the master <code>pg_ref</code> so you can create it with <code>pgNewShell(&amp;paige_globals)</code>.</p>
</li>
<li><p>All subsequent <code>pg_ref</code>s should be created for &quot;shared&quot; formatting (shared with the master <code>pg_ref</code>. If using the direct API, you call the following function <em>in lieu of</em> <code>pgNew()</code>:</p>
<pre><code>pg_ref pgNewShared (pgNewShared (pg_ref shared_from, const generic_var def_device, shape_ref vis_area, shape_ref page_area, shape_ref exclude_area, long attributes);
</code></pre>
</li>

</ol>
<p>This is identical to <code>pgNew()</code> except the first parameter — <code>shared_from</code> — is a <code>pg_ref</code> instead of a pointer to HERMES Paige globals. This should be the master <code>pg_ref</code> (the one created in step 1).</p>
<p>All other parameters are the same as <code>pgNew()</code>. However, for any parameter that is <code>NULL</code>, those structures are also &quot;shared&quot;.</p>
<p>For example, if <code>def_device</code> is <code>0L</code>, the same window device in the master <code>pg_ref</code> is used; if <code>vis_area</code> is <code>OL</code> then the same physical <code>vis_area</code> shape is shared from the master <code>pg_ref</code>, and so on. If you don&#39;t want the new <code>pg_ref</code> to share its <code>vis_area</code>, <code>page_area</code>, or <code>exclusion_area</code>, do not pass <code>0L</code> for these values.</p>
<p><strong>NOTE:</strong> about exclusion area(s): Most often, you won&#39;t be creating a <code>pg_ref</code> that begins with an exclusion shape. For shared <code>pg_ref</code>s, however, not providing an exclusion shape to <code>pgNewShared()</code> will result in the inability to create a non-shared exclusion later on. The work-around is to create an empty shape for the <code>exclude_area</code> parameter.</p>
<h2 id='352-custom-control'>35.2 Custom Control</h2>
<p>If you create a custom control (instead of using HERMES Paige API), you can share the control with the master <code>pg_ref</code> by sending the following message:</p>
<pre><code>SendMessage(hWnd, PG_SHAREREFS, flags, master_pg);
</code></pre>
<p>After this message is sent, the <code>hWnd</code> (control) will be sharing the structures from <code>master_pg</code> (the <code>pg_ref</code> created in step 1).</p>
<p>The <code>flags</code> parameter indicates which structure(s) you wish to share, which can be any of the following bit settings:</p>
<pre><code>#define PGSHARED_FORMATS		0x0001	// Style, font, para infos shared
#define PGSHARED_GRAF_DEVICE	0x0002	// Common graphics content
#define PGSHARED_VIS_AREA		0x0004	// Shared vis area
#define PGSHARED_PAGE_AREA		0x0008	// Shared page area
#define PGSHARED_EXCLUDE_AREA	0x0010	// Shared exclusion area
</code></pre>
<p>Probably, you only want to set <code>PGSHARED_FORMATS</code>.</p>
<h2 id='353-disposing'>35.3 Disposing</h2>
<p>You <em>do not</em> need to do anything special to dispose a &quot;shared&quot; <code>pg_ref</code> or control. Just dispose the <code>pg_ref</code> (or close the control) in the same way that you would if they were not shared.</p>
<p>However, you must never dispose the master <code>pg_ref</code> while any shared <code>pg_ref</code>s or controls are still alive.</p>
<h2 id='354-saving--reading'>35.4 Saving &amp; Reading</h2>
<p>Saving the individual shared <code>pg_ref</code>s or controls works the same as before: when you call <code>pgSaveDoc()</code> or <code>pgCacheSaveDoc()</code>, HERMES Paige realises that some of the} structures are shared with a master <code>pg_ref</code>, and therefore those structures are not saved to the disk file. Hence, you eliminate excess file overhead. This is also true for saving a control with <code>PG_SAVEFILE</code> or <code>PG_CACHESAVEFILE</code>, as well as saving with the HERMES Paige Export extension to &quot;native&quot; format.</p>
<p>Reading a shared <code>pg_ref</code> or control also works as before (<code>pgReadDoc()</code>, <code>pgCacheReadDoc()</code>, or <code>PG_READFILE</code> and <code>PG_CACHEREADFILE</code>). However, you must first create an empty &quot;shared&quot; <code>pg_ref</code> or control before reading the file.</p>
<h2 id='355-saving-the-master'>35.5 Saving the Master</h2>
<p>The ability to read a shared document assumes that the master <code>pg_ref</code> is intact, <em>i.e.</em> that it contains all the appropriate styles and formatting that existed at the time you saved each document. </p>
<p>To accomplish this you merely save the master <code>pg_ref</code> (using <code>pgSaveDoc</code>). Then later (probably when your application initialises), create an empty <code>pg_ref</code> then read it in with <code>pgReadDoc()</code>. The file-read sequence for shared $p g _r e f(s)$ is therefore:</p>
<ol start='' >
<li>Open the &quot;master&quot; <code>pg_ref</code>, residing in memory.</li>
<li>For each <code>pg_ref</code> that you read from a file, create the <code>pg_ref</code> with <code>pgNewShared()</code> then read the file.</li>

</ol>
<h1 id='36-anatomy-of-text-blocks'>36 ANATOMY OF TEXT BLOCKS</h1>
<h2 id='361-access-to-the-text-block-array'>36.1 Access to the text block array</h2>
<p>The information in this section has been provided for HERMES Paige users who need to access a <code>pg_ref</code>&#39;s text block array.</p>
<p>One of the more common reasons to access a text block is to examine an array of line records to determine specific locations of characters and/or to alter line positions.</p>
<p>For performance and portability reasons, HERMES Paige splits large blocks of text into smaller portions rather than maintain one continuous text stream. The approximate size of a block is determined by the <code>max_block_size</code> in <code>pg_globals</code>: when any block of text exceeds <code>pg_globals.max_block_size</code>, HERMES Paige will split it into two or more new blocks.</p>
<h3 id='text-block-record'>Text block record</h3>
<p>Every block of text in a <code>pg_ref</code> is represented by the following record:</p>
<pre><code>typedef struct
{
	long		begin;			// Relative offset beginning
	long		end;			// Relative offset ending
	rectangle	bounds;			// Entire area this includes
	text_ref	text;			// Actual text data
	line_ref	lines;			// Point_start run for lines
	pg_short_t	flags;			// Used internally by HERMES Paige
	short		extra;			// Reserved
	pg_short_t	num_lines;		// Number of lines
	pg_short_t	num_pars;		// Number of paragraphs
	long		first_line_num;	// First line number
	long		first_par_num;	// First par number
	point_start	end_start;		// Copy of ending point_start in block
	memory_ref	isam_end_ref;	// Used by DSI (do not co-opt)
	tb_append_t	user_var;	// Can be used for anything
}
</code></pre>
<p>Each field, from top to bottom, has the following meaning:</p>
<ul>
<li><p><code>begin</code>, <code>end</code> — defines the absolute beginning and ending offsets for this block of text (relative to the beginning of all text). The text size:</p>
<pre><code>text_block.end - text_block.begin. }
</code></pre>
</li>
<li><p><code>bounds</code> — defines the outermost bounds, as a rectangle, for the calculated text (by &quot;calculated&quot; is meant how the text will appear once all word wrapping, etc. is computed for this block). This is not necessarily the actual shape of the drawn text, rather the rectangle&#39;s four sides represent the leftmost, topmost, rightmost and bottommost areas.</p>
</li>
<li><p><code>text</code> — the <code>memory_ref</code> containing the text. Passing this value to UseMemory would return a pointer to the first text byte.</p>
</li>
<li><p><code>lines</code> — the <code>memory_ref</code> containing an array of <code>point_start</code>	 records (see below). Passing this value to <code>UseMemory</code> would return a pointer to the first point_start.</p>
</li>
<li><p><code>flags</code> — define certain states of the block with one or more of the following bit settings:</p>
<pre><code>#define NEEDS_CALC				0x0001 // One or more lines need recalc
#define NEEDS_PAGINATE 			0x0002 // Needs re-pagination
#define SOME_LINES_GOOD			0x0004 // One or more lines probably OK
#define SOME_LINES_BAD			0x0008 // One or more lines not calculated		
#define BROKE_BLOCK				0x0010 // Terminator char deleted		
#define ALL_TEXT_HIDDEN			0x0020 // All text in block is hidden!
#define BOUNDS_GUESSED			0x0040 // Best guess only for bounds rect		
#define LINES_PURGED			0x0080 // Lines purged but block OK		
#define BELOW_CONTAINERS		0x0100 // Lines below last container		
/* FLAG 0x0200 NOT USED */
#define NO_CR_BREAK				0x0400 // Does not break on a CR 		
#define SWITCHED_DIRECTIONS		0x0800 // System text direction has switched!	
#define LINES_NOT_HORIZONTAL	0x1000 // Point starts are not always horizontal		
#define JUMPED_4_EXCLUSIONS		0x2000 // One or more lines hop across exclusions		
#define NEEDS_PARNUMS			0x4000 // Requires paragraph &quot;line&quot; computation		
/* FLAG 0x8000 NOT USED */
</code></pre>
</li>
<li><p><code>num_lines</code> through <code>first_par_num</code> — If <code>COUNT_LINES_BIT</code> is set in the <code>pg_ref</code> attributes, these fields are used to track line and paragraph numbering. The <code>first_line_num</code> and <code>first_par_num</code> values define the first line number and paragraph number in this block, respectively, while <code>num_lines</code> and <code>num_pars</code> indicate the number of lines and paragraphs found in this block only. If <code>COUNT_LINES_BIT</code> is not set, all these fields are zero.</p>
</li>
<li><p><code>end_start</code> — Contains a copy of the ending <code>point_start</code> record (<code>point_start</code> for the ending line of text in this block).</p>
<p><strong>NOTE:</strong> Most of the fields in a <code>text_block</code> are only accurate if the flags field has neither <code>NEEDS_CALC</code>, <code>NEEDS_PAGINATE</code> nor <code>SOME_LINES_BAD</code> set.</p>
</li>

</ul>
<h2 id='362-line-records'>36.2 Line Records</h2>
<p>Text lines are represented by a series of <code>point_start</code> records; for every text block, an array of <code>point_start</code>s are maintained in the <code>lines</code> <code>memory_ref</code>.</p>
<pre><code>typedef struct
{
	pg_short_t	offset;		// Position into text
	short_t		extra;		// Tab record if 0x8000, otherwise full-justify
	short		baseline;	// Distance from bottom to draw
	pg_short_t	flags;		// Various attribute flags
	long		r_num;		// Wrap rectangle record where this sits
	rectangle	bounds;		// Points that enclose text piece exactly
	}
point_start, PG_FAR *point_start_ptr;
</code></pre>
<p>Any line of text might have a number of <code>point_start</code> records to represent its character positions. Generally, a <code>point_start</code> will exist for every display change in a line. This includes style changes, tab positions and of course line-feed and line-wrap changes.</p>
<p>The meaning of each field, from top to bottom, is as follows:</p>
<ul>
<li><code>offset</code> — the text byte position for this <code>point_start</code>, relative to the start of text for this block. Hence, an <code>offset</code> of zero implies the first byte for the block.</li>
<li><code>r_num</code> — the rectangle element in <code>page_area</code> where this <code>point_start</code> first intersects. If zero, it intersects the first rectangle in <code>page_area</code> (a shape, such as <code>page_area</code>, is a series of rectangles). If the <code>pg_ref</code> is set for repeating shapes, the actual physical rectangle number can be computed as <code>r_num / rect_qty</code> (where <code>rect_qty</code> is the number of rectangles in the <code>page_shape</code>). To determine &quot;page number&quot;, compute the modular value of <code>r_num</code> and add one.</li>
<li><code>extra</code> - either a tab record element <em>or</em> a full justification value. If high bit is set (<code>0x8000</code>), the low-order bits define a tab record element index from the paragraph style applying to this text. If high-bit is not set (<code>0x0000</code>), the value in <code>extra</code> defines the amount of <code>slop</code>, in pixels, to compensate for full justification drawing.</li>
<li><code>baseline</code> - amount of offset from line&#39;s bottom to draw the text, in pixels.</li>
<li><code>flags</code> — contains bit setting(s) for various attributes for the text within this point_start (see <a href='#line-flags'>Line Flags</a> in this section).</li>
<li><code>bounds</code> — defines the bounding rectangle around the text for this <code>point_start</code>.</li>

</ul>
<h3 id='text-length-of-a-line'>Text &quot;Length&quot; of a Line</h3>
<p>The length of text for each <code>point_start</code> is determined by the <em>next</em> point start in the <code>array</code>, i.e., text length of <code>array[0]</code> is <code>array[1].offset - array[0].offset</code>. The <code>point_start</code> <code>array</code> is always terminated with a dummy &quot;record&quot; for this purpose.</p>
<h3 id='line-flags'>Line Flags</h3>
<p>If you examined any array of <code>point_start</code> records, a <code>point_start</code>&#39;s <code>flags</code> field will reveal much of the information you often want to know. The flags will be a combination of bit settings as follows:</p>
<pre><code class='language-c' lang='c'>#define NO_LINEFEED_BIT			0x0001 // Line does not advance vertically
#define LINE_HIDDEN_BIT			0x0002 // Line is invisible
#define BREAK_PAGE_BIT			0x0004 // Line broke for exclusion
#define BREAK_CONTAINER_BIT	0x0008 // Line breaks for next container
#define SOFT_BREAK_BIT			0x0010 // Start breaks on soft hyphen
#define CUSTOM_CHARS_BIT		0x0020 // Style(s) are custom, not HERMES Paige 
#define HAS_WORDS_BIT				0x0040 // One or more word separators exist
#define TAB_BREAK_BIT				0x0080 // Tab character terminates this line
#define WORD_HYPHEN_BIT			0x0100 // Draw a hyphen after this text
#define NEW_PAR_BIT					0x0200 // New paragraph starts here
#define NEW_LINE_BIT				0x0400 // New line starts here
#define LINE_GOOD_BIT				0x0800 // This line requires no re–calculation
#define RIGHT_DIRECTION_BIT	0x1000 // Text in this start is right-to-left
#define SOFT_PAR_BIT				0x2000 // Soft carriage return ends line
#define PAR_BREAK_BIT				0x4000 // Paragraph ends here
#define LINE_BREAK_BIT			0x8000 // Line ends here
#define TERMINATOR_BITS			0xFFFF // Flagged only as terminator record

#defube HARD_BREAK_BITS (PAR_BREAK_BIT | SOFT_PAR_BIT | BREAK_CONTAINER_BIT | BREAK_PAGE_BIT)
</code></pre>
<p>As mentioned, every <code>array</code> of <code>point_start</code> records has at least one dummy &quot;record&quot; as a terminator. This record will always have the value <code>TERMINATOR_BITS</code> in the <code>flags</code> field.</p>
<p>For any <code>point_start</code>, if <code>LINE_GOOD_BIT</code> is <em>not</em> set, all remaining fields are not to be considered valid.</p>
<h2 id='363-text-block-support-functions'>36.3 Text Block Support Functions</h2>
<p>The following functions are available to find and otherwise access text blocks in a <code>pg_ref</code>:</p>
<pre><code>(long) pgNumTextblocks (pg_ref pg);
(long) pgGetTextblock (pg_ref pg, long offset, text_block_ptr block, pg_boolean want_pagination);
</code></pre>
<p><code>pgNumTextBlocks</code> returns the total number of text block records in <code>pg</code>. There will always be at least one, even if no text exists.</p>
<p><code>pgGetTextBlock</code> will return a copy of the <code>text_block</code> record in <code>*block</code> that contains <code>offset</code> (which is an absolute position relative to the start of all text).</p>
<p>If <code>want_pagination</code> is <code>TRUE</code>, the block is calculated if necessary. Note that if <code>want_pagination</code> is <code>FALSE</code>, there it is possible to get a block whose line records are not intact; paginating the block, however, can be time consuming particularly if it is are down the list of many blocks.</p>
<p>The function result of <code>pgGetTextBlock</code> is the record number (element number from the array of text blocks within <code>pg</code>).</p>
<h3 id='tech-note-hacking-the-text'>TECH NOTE: HACKING THE TEXT</h3>
<blockquote><p>I want to write a &quot;Find&quot; function; I therefore need to walk through the text within a <code>pg_ref</code>. I do not want to &quot;copy&quot; the text to look at it; that would be too slow. Is there a way to do this?</p>
</blockquote>
<p>When speed is a critical issue and you have the need to look at HERMES Paige text, you are best off looking at these structures directly. The following code sample shows various &quot;hacks&quot; to do this:</p>
<pre><code>/* To look at the text_block records, we need to get access to the paige_rec within the pg_ref: */

paige_rec_ptr pg_rec;
text_block_ptr blocks;
long num_blocks, num_bytes;
char *text;

pg_rec = UseMemory(pg);
// Then get the pointer to the text_block array:
blocks = UseMemory(pg_rec -&gt; t_blocks);
/* To know how many text_block records exist, get memory sized of t_blocks: */
num_blocks = GetMemorySize(pg_rec -&gt; t_blocks);
/* Also note that &quot;blocks&quot; is also an array, i.e.: blocks[1] is next block, if any blocks[2] is the one after that, etc. ~OR~ blocks += 1 advances to next block.
Now, to get the text, just do UseMemory(blocks -&gt; text), as: */
text = UseMemory(blocks -&gt; text);

// To get size of text in bytes, we can compute either as:
num_bytes = GetMemorySize(blocks -&gt; text);
// or as:
num_bytes = blocks -&gt; end - blocks -&gt; begin;

// Once we are done, make sure to UnuseMemory()
UnuseMemory(blocks -&gt; text);
UnuseMemory(pg_rec -&gt; t_blocks);
UnuseMemory(pg);
</code></pre>
<h1 id='37-advanced-text-placement'>37 Advanced Text Placement</h1>
<h2 id='371-hermes-paige-custom-placement-of-lines-and-paragraphs'>37.1 HERMES Paige Custom Placement of Lines and Paragraphs</h2>
<p>Occasionally, a HERMES Paige user needs to enhance a word processing environment beyond the built-in feature set of HERMES Paige. This particular chapter discusses the methods required to provide <em>widows</em> and <em>orphans</em>, keep paragraphs together, and other forms of paragraph and line manipulation.</p>
<p>For basic pagination techniques and how to build repeating shapes to contain your text, see chapter 13, <a href='#13-pagination-support'>Pagination Support</a>. For information about the <code>line_adjust_proc</code> hook, which is the key hook used in this chapter, see section 27.2, <a href='#27.2-`line_adjust_proc`'><code>line_adjust_proc</code></a>.</p>
<p>For purposes of clarity, we will define the following technical terms used in this discussion:</p>
<ul>
<li><strong>Line</strong> — a row of characters in a document. The reason we feel it necessary to define the word <em>line</em> is to avoid confusion with CR/LF-breaking text. In HERMES Paige, a line is any row of characters that break due <em>either</em> to word wrapping <em>or</em> because of the presence of a CR character. Thus, in a word-wrapping environment, a line and a paragraph are not <strong>necessarily</strong> synonymous (in applications that do not word-wrap lines, they <em>are</em> synonymous).</li>
<li><strong>Page</strong> — the area in a <code>pg_ref</code> (usually a rectangle) in which text will flow. For the purposes of this discussion, we assume that the <code>pg_ref</code> contains multiple pages, i.e. &quot;repeating shape&quot; feature is enabled, providing the appearance of multiple page breaks.</li>
<li><strong>Pagination</strong> — the computation and vertical placement of lines. While the term <em>pagination</em> derives from the word <em>page</em> and often implies formatting of text across multiple page boundaries, we use the term <em>pagination</em> here to mean any vertical placement of lines, with or within multiple page breaks.</li>
<li><strong>Paragraph</strong> — a block of text that terminates with a CR character (or the last block of text in the document if no CR character). If HERMES Paige is set for word-wrapping, a paragraph can consist of many lines (in which the ending line is terminated with a CR). If HERMES Paige is not set for wrapping, a paragraph and line are synonymous.</li>

</ul>
<h2 id='373-how-pagination-occurs'>37.3 How Pagination Occurs</h2>
<p>HERMES Paige formats the drawing positions for each line of text by building an array of records that define the text offset and bounding coördinates for groups of characters. If no changing styles or tabs exist in the text, a single line is usually represented by one of these records; for lines that change styles and/or contain tab characters, a line will consist of many of these records.</p>
<p>The record that composes a line (or part of a line) is called the <code>point_start</code>, which is defined as follows:</p>
<pre><code class='language-c' lang='c'>typedef struct
{
	pg_short_t offset;	// Position into text
	short extra;				// Tab record if &amp;0xC000 = 0
	short	baseline;			// Distance from bottom to draw
	pg_short_t flags;		// Various attributes flags
	long r_num;					// Wrap rectangle
	rectangle	bounds;		// Rect enclosing text exactly
}
point_start, PG_FAR *point_start_ptr;
</code></pre>
<p>For a block of fully paginated text, HERMES Paige will create a <code>point_start</code> record for <em>all</em> style and screen position changes. By <em>screen position changes</em>, we mean either some extra horizontal jump (such as a tab character), or a new line (from word-wrapping or CR).</p>
<p>The <code>bounds</code> field in the <code>point_start</code> always represents the exact display location and dimensions of the text, i.e. <code>bounds.top_left</code> will contain the top-left pixel coördinate of the text, and <code>bounds.bot_right</code> will contain the bottom-right pixel coördinate of the text.</p>
<p><strong>NOTE:</strong> The <code>bounds</code> dimensions always represent the display dimensions, not necessarily the character dimensions (for example, if extra line spacing or leading has been added to the text, <code>bounds.bot_right.v</code> might be larger than the actual characters&#39; descent).</p>
<p>The display positions represented by the bounds rectangle are always unscaled and unscrolled. In other words, their coördinates always reflect the position of the text relative to the top-left origin of your window, whether or not the document is &quot;scrolled&quot; and whether or not the document is &quot;scaled&quot;.</p>
<h2 id='374-intercepting-pagination'>37.4 Intercepting Pagination</h2>
<p>Implementing widows and orphans, keeping paragraphs together, etc., can be accomplished dynamically by intercepting the <code>point_start</code> array for each <code>text_block</code> record that is paginated, and making the necessary adjustments.</p>
<p>The recommended method for doing this is to set the <code>paginate_proc</code> within the <code>pg_ref</code>. HERMES Paige will call this function after it is through paginating a <code>text_block</code> record.</p>
<p><strong>NOTE:</strong> HERMES Paige performs pagination on a <code>text_block</code> level, not a &quot;page&quot; or &quot;line&quot; level. For example, if a large document had to be paginated, HERMES Paige would walk through the <code>text_block</code> array and paginate the text for one <code>text_block</code> record at a time; the <code>paginate_proc</code> hook gets called after the completion of pagination for each <code>text_block</code>.</p>
<p>The concept of using the <code>paginate_proc</code> is to make adjustments to the line <code>array</code> (<code>point_start</code> records) after HERMES Paige is done calculating the lines within a block; several code examples are shown below for typical applications.</p>
<h2 id='375-changing-the-pointstart-array'>37.5 Changing the <code>point_start</code> Array</h2>
<p>Although we can&#39;t tell you how to write your custom feature, we will attempt to provide enough information here to do almost any form of paragraph or line adjustments.</p>
<h3 id='matching-textblock-members-important'>Matching <code>text_block</code> Members (IMPORTANT!)</h3>
<p>If you alter any of the <code>point_start</code> records within a <code>text_block</code> it is important to also make adjustments to the following members:</p>
<ul>
<li><code>text_block.bounds</code> — This defines the bounding rectangle for all text within the block. Essentially, <code>text_block.bounds</code> is the union of all <code>point_start.bounds</code>. Hence if you move some lines up or down you should also adjust the bounding area as recorded in the <code>text_block</code>.</li>
<li><code>text_block.end_start</code> — This is a copy of the last <code>point_start</code> in the block. If you change the last <code>point_start</code>, copy its contents to this member.</li>

</ul>
<h3 id='determining-type-of-line'>Determining type of line</h3>
<p>An obvious requirement for manipulating paragraphs or lines is to determine what kind of line you are looking at, i.e. is the line at the beginning of the paragraph, somewhere in the middle, or at the end.</p>
<h3 id='examining-flag-fields-of-a-line'>Examining flag fields of a line</h3>
<p>The easiest way is to examine the <code>flags</code> field of the first and last <code>point_start</code> of the line as follows:</p>
<p>If <code>NEW_PAR_BIT</code> is set in the first point_start, the line is the BEGINNING OF A PARAGRAPH.</p>
<h4 id='example-1-3'>Example 1</h4>
<pre><code>if (starts-&gt;flags &amp; NEW_PAR_BIT)
// line begins a paragraph
</code></pre>
<p>If <code>PAR_BREAK_BIT</code> is set in the last <code>point_start</code>, the line is the <em>ending of a paragraph</em>.</p>
<h4 id='example-2-3'>Example 2</h4>
<pre><code>if (starts[num_starts - 1].flags &amp; PAR_BREAK_BIT)
// line is last one in paragraph, i.e. ends with CR.
</code></pre>
<p>NOTE: A line can, of course, have both <code>NEW_PAR_BIT</code> and <code>PAR_BREAK_BIT</code> set at the same time, which means the paragraph has only one line (or is no more or less than a CR character).</p>
<h3 id='adjusting-vertical-position'>Adjusting vertical position</h3>
<p>Another obvious requirement is the ability to move a line up or down (to adjust for a page break or to force the line to begin on the next page, etc.).</p>
<p>The easiest way to adjust the line&#39;s vertical position is to walk through <code>num_starts</code> records and move each bounds rectangle with <code>pgOffsetRect</code>. Suppose you wanted to move the line &quot;down&quot; 10 pixels; you would do so thus:</p>
<pre><code>pg_short_t counter;
for (counter = 0; counter &lt; num_starts; ++counter)
pgOffsetRect(&amp;starts[counter].bounds, 0, 10);
</code></pre>
<p>However, you <em>must</em> also adjust the <code>line_fit</code> rectangle, because HERMES Paige uses that rectangle to place the next line it computes. Hence, in addition to the above, you must also do:</p>
<pre><code>pgOffsetRect(line_fit, 0, 10);
</code></pre>
<p><em>All subsequent lines</em> will follow suit (vertically) from the bottom position of <code>line_fit</code> when your function returns. In other words, HERMES Paige starts the top of the next line at the precise position of <code>line_fit -&gt; bot_right.v</code>. Hence, if you want your line adjustment to affect future lines as well (i.e., if you move a line down you want all subsequent lines to move down by the same amount), you do nothing except adjust the current line and HERMES Paige will handle the rest.</p>
<h2 id='examining-lines-before-the-current'>Examining line(s) before the current</h2>
<p>It may become necessary to examine one or more lines prior to the current line given in the <code>adjust_proc</code>.</p>
<p>One example might be a situation where the current line is the middle of a paragraph but you need to know the position of the first line in the paragraph.</p>
<p>Since the starts pointer actually points to a specific element in the entire <code>array</code> of <code>point_starts</code> that have been computed thus far, you can simply decrement it to examine line(s) before the current position, if they exist.</p>
<p>However, the only <code>point_start</code> elements that are <em>guaranteed</em> to exist in the <code>array</code> are all the elements for the current paragraph; this is due to the fact that HERMES Paige breaks apart large blocks of text into smaller sections—but never in the middle of a paragraph.</p>
<h3 id='obtaining-the-pointstarts-of-the-current-paragraph'>Obtaining the point_starts of the current paragraph</h3>
<p>To obtain the first <code>point_start</code> of the current paragraph, you can decrement the <code>starts</code> pointer until the <code>flags</code> field contains <code>NEW_PAR_BIT</code>. Here is an example:</p>
<pre><code>for (;;)
{
	if (starts -&gt; flags &amp; NEW_PAR_BIT)
		break;
	--starts;
}
</code></pre>
<p>You can do the same thing to back up to start of the previous line, with a slight alteration:</p>
<pre><code>for (;;)
{
	--starts;
	if (starts -&gt; flags &amp; NEW_LINE_BIT)
		break;
}
</code></pre>
<p><strong>CAUTION:</strong> Be sure there are truly previous <code>point_start</code> elements before backing up the <code>starts</code> pointer. The simplest way to check this is to examine the <code>offset</code> field of the <code>start</code>; if it is zero, there are no elements before it.</p>
<h4 id='example-12'>Example</h4>
<pre><code>if (starts -&gt; offset == 0)
	/* We must not &quot;back up&quot; because starts is the FIRST START.*/
</code></pre>
<p><strong>NOTE:</strong> The &quot;first <code>start</code>&quot; does not necessarily mean the start of the whole document, rather the start of the current block of text. The first <code>start</code> however will always be the beginning of a paragraph.</p>
<h3 id='376-page-rectangles'>37.6 Page Rectangles</h3>
<p>For purposes of custom pagination of paragraphs, you probably need to compute the vertical location of page boundaries.</p>
<p><strong>CAUTION:</strong> The information given here assumes that <em>repeating shapes are enabled</em> to achieve a multiple-page effect. If you are using some other method for page breaks, this information might not apply (mainly because we do not know how you have implemented page sizes and breaks).</p>
<p>The following is a list of very useful low-level utility functions that you can use to find out about the current &quot;page&quot; that a line will display in:</p>
<pre><code>#include &quot;pgShapes.h&quot;
pg_short_t pgGetWrapRect (paige_rec_ptr pg, long r_num, co_ordinate_ptr offset_extra);
</code></pre>
<p>This function returns sufficient information to construct the exact &quot;page&quot; rectangle for a given line of text. (<strong>NOTE:</strong> it is prototyped in <code>pgShapes.h</code> and is intended to be called from low-level hooks such as <code>adjust_proc</code>).</p>
<p>The <code>r_num</code> field must be the value in <code>r_num</code> from the first <code>point_start</code> of the line. When this function returns, <code>offset_extra</code> gets set to the amount to adjust the original page rectangle to obtain the actual, physical page location (remember we are dealing with &quot;repeating shapes&quot;, which means the <code>pg_ref</code> has only one page shape which repeats; this function computes the physical page position based on that information).</p>
<p>For purposes of obtaining only the vertical positions of the page, the function result can be ignored.</p>
<p>Here is an example of obtaining the page rect for a line of text in question (while in the adjust_proc):</p>
<pre><code>rectangle page;
co_ordinate offset_adjust;

pgShapeBounds(pg -&gt; wrap_area, &amp;page);
/* start with actual page area */

pgGetWrapRect(pg, starts -&gt; r_num, &amp;offset_adjust);
pgOffsetRect(&amp;page, offset_adjust.h, offset_adjust.v);

/* We now have the &quot;real&quot; page area for the line beginning at &quot;starts&quot; */
</code></pre>
<h2 id='377-page-break-characters'>37.7 Page Break Characters</h2>
<p>If your application implements page break characters, you can determine if the line has terminated with a forced page break by examining the ending point_start flags field:</p>
<pre><code>if (starts[num_starts - 1].flags &amp; BREAK_PAGE_BIT)
// line ends with forced page break char.
</code></pre>
<p><code>BREAK_PAGE_BIT</code> only gets set if the line terminates with a physical page-break character (it does not get set just because more lines won&#39;t fit on the page.</p>
<h1 id='38-unicode-support'>38 UNICODE SUPPORT</h1>
<p>Using the appropriate HERMES Paige library (or compiling HERMES Paige with <code>#define UNICODE</code>) will help you create a Unicode-aware application.</p>
<h2 id='381-compiler-settings'>38.1 Compiler Settings</h2>
<p>To compile an application using the HERMES Paige Unicode library (or to build the HERMES Paige Unicode library) you must provide the pre-definitions <code>UNICODE</code> and <code>_UNICODE</code>. It is best to use the preprocessor settings in your compiler for these definitions (not <code>CPUDEFS.H</code>) because your Windows headers require these definitions to resolve various macros.</p>
<h2 id='382-absolute-unicode'>38.2 Absolute Unicode</h2>
<p>HERMES Paige Unicode expects absolute Unicode in every respect. This includes anything whatsoever that has previously been declared as a <code>char</code> or <code>unsigned char</code>.</p>
<p>For example, <code>pgInsert()</code> expects your character(s) insertions to be wide characters (16 bit). The font name(s) in <code>font_info</code> are expected to be 16-bit characters as well. If you are using the custom control, all strings are assumed to be Unicode (the &quot;HERMES Paige&quot; window class, the default font name, etc.).</p>
<p>Text positions and offsets are also Unicode-aware; they therefore must be considered character offsets and not byte offsets. For example, if the insertion point (caret) is sitting between characters 4 and 5, <code>pgGetSelection()</code> will return position 4 even though the physical byte position is 8. Similarly, <code>pgTextSize()</code> will return the total (Unicode) character size, not the physical byte size. Every structure within HERMES Paige Unicode assumes Unicode-based text; this design has been implemented for transparency and ease of upgrading.</p>
<h2 id='383-hermes-paige-character-types'>38.3 HERMES Paige Character Types</h2>
<p>To support both Unicode and non-Unicode in a portable fashion, a new generic type has been declared:</p>
<pre><code>#ifdef UNICODE
typedef unsigned short pg_char, *pg_char_ptr
#else
typedef unsigned pg_char, *pg_char_ptr
</code></pre>
<p>Most parameters in HERMES Paige API have changed from <code>pg_byte</code> and <code>pg_byte_ptr</code> to <code>pg_char</code> and <code>pg_char_ptr</code>.</p>
<p>For historical purposes, the older type <code>pg_byte</code> is still valid but it maps to <code>pg_char</code>.</p>
<p>If you need to declare a true byte (8-bit value), HERMES Paige provides the following:</p>
<pre><code>typedef unsigned char pg_bits8, *pg_bits8_ptr;
</code></pre>
<h2 id='384-io-and-text-files'>38.4 I/O and Text Files</h2>
<p>Most of the file I/O supported by HERMES Paige Unicode will be transparent to your application. If an older HERMES Paige file is opened and/or if an HERMES Paige Unicode-aware program opens a non-Unicode HERMES Paige file, the text will be translated appropriately with no required intervention from your application.</p>
<p>Even if you are running the non-Unicode version of HERMES Paige, reading HERMES Paige Unicode files will still be converted to 8-bit ASCII text.</p>
<h2 id='385-importexport'>38.5 Import/Export</h2>
<p>The HERMES Paige import/export extension will translate Unicode to ASCII or ASCII to Unicode, whichever is appropriate. For example, when importing a text file the importer checks for the existence of Unicode (or not) and will convert the characters as necessary during the import. This will work (more or less) even if you are running the non-Unicode HERMES Paige library - if Unicode text is being imported it will be converted to nonUnicode, 8-bit ASCII.</p>
<h3 id='exceptions'>Exceptions</h3>
<p>Exporting text and RTF, however, will export non-Unicode ASCII by default. If you need to export Unicode text, the following flag has been added to the export definitions:</p>
<pre><code># EXPORT_UNICODE_FLAG
</code></pre>
<p>After you have created the export object, set <code>EXPORT_UNICODE_FLAG</code> in the <code>export_bits</code> member.</p>
<pre><code class='language-c' lang='c'>filter = (PaigeExportObject) new PaigeRTFExportFilter(); 
filter -&gt; feature_bits |= EXPORT_UNICODE_FLAG;
</code></pre>
<h2 id='386-unicode-support-utilities'>38.6 Unicode Support Utilities</h2>
<p><strong>NOTE:</strong> Unless specified otherwise, these support utilities can be called even if the runtime HERMES Paige library is non-Unicode (version 2.0 or above).</p>
<pre><code class='language-c' lang='c'>pg_boolean pgIsPaigeUnicode (void);
</code></pre>
<p>Returns <code>TRUE</code> if the current runtime HERMES Paige library supports Unicode. This function works for all 2.0b1+ versions, with or without Unicode support.</p>
<p><strong>NOTE:</strong> A &quot;TRUE&quot; merely means that the library — not necessarily the OS — supports Unicode.</p>
<pre><code class='language-c' lang='c'>pg_boolean pgInsertBytes (pg_ref pg, const pg_bits8_ptr data, long length, long position, short insert_mode, short modifiers, short draw_mode);
</code></pre>
<p>This function is identical to <code>pgInsert()</code> except the data to be inserted is considered to be 8-bit characters. The purpose of this function is to provide a way for a Unicode application to (still) be able to insert 8-bit ASCII if necessary (calling <code>pgInsert()</code> assumes Unicode characters).</p>
<p>Calling this function in a non-Unicode HERMES Paige library will do the same thing as <code>pgInsert()</code>. If called in a Unicode HERMES Paige library, the bytes are converted internally to 16-bit Unicode characters.</p>
<p>You can force text to be saved as Unicode even if you are running in a non-Unicode environment. To do so, set the extended attribute <code>SAVE_AS_UNICODE</code> using <code>pgSetAttributes2()</code> before calling <code>pgSaveDoc()</code>. When this attribute is set, the text is converted to Unicode (16 bit characters).</p>
<p><strong>NOTE:</strong> While converting Roman or &quot;English&quot; characters will generally convert to 16 bit characters properly, complex double byte languages such as Japanese may not convert correctly. To work around this problem you need to supply the necessary character conversion functions as described below.</p>
<h2 id='388-unicode-conversion-hooks'>38.8 Unicode Conversion Hooks</h2>
<p>In certain cases, HERMES Paige is required to convert Unicode to non-Unicode, or non-Unicode to Unicode. In every case, one of the two low-level &quot;hook&quot; functions are called as shown below.</p>
<p>Both of these functions are <code>style_info</code> hooks, i.e. they apply to individual text formats. Initially, an internal function is used as the default. For <code>bytes_to_unicode_proc</code> the standard (default) function merely converts 8 bit characters to 16 bit characters and <code>unicode_to_bytes_proc</code> performs the reverse. For special languages, scripts, etc. you would need to provide your own conversion functions to replace the defaults.</p>
<h2 id='389-non-unicode-to-unicode'>38.9 Non-Unicode to Unicode</h2>
<pre><code class='language-c' lang='c'>long bytes_to_unicode_proc (pg_bits8_ptr input_bytes, pg_short_t PG_FAR *output_chars, font_info_ptr font, long input_byte_size);
</code></pre>
<p>Upon entry, <code>input_bytes</code> is a pointer to a buffer of bytes (8 bit characters); <code>input_byte_size</code> defines the number of bytes.</p>
<p><strong>NOTE:</strong> The input is considered a byte stream even if they are logically &quot;double byte characters” such as Japanese text.</p>
<p>If <code>output_chars</code> is NULL, no conversion is to occur; instead, this function should simply return the number of characters that would result from a conversion to Unicode.</p>
<p>If <code>output_chars</code> is not NULL, the converted characters are to be output to this buffer; note that the actual size of the <code>output_chars</code> buffer will be large enough to accommodate the conversion, assuming that each and every byte in <code>input_bytes</code> will be converted to a 16 bit value.</p>
<p>The font parameter will contain the current font of the text (which typically will contain language and script information).</p>
<p><strong>NOTE:</strong> All the characters provided are guaranteed to be rendered in this font, i.e. the conversion function will never be called with &quot;mixed&quot; fonts.</p>
<p><strong>FUNCTION RESULT:</strong> The function should return the total number of characters converted (that were placed into <code>output_chars</code>) or the number of characters that would be converted (if <code>output_chars</code> is NULL).</p>
<p><strong>NOTE:</strong> This is a character count, not a byte count.</p>
<h2 id='3810-unicode-to-non-unicode'>38.10 Unicode to Non-Unicode</h2>
<pre><code>long unicode_to_bytes_proc (pg_short_t PG_FAR *input_chars, pg_bits8_ptr output_bytes, font_info_ptr font, long input_char_size);
</code></pre>
<p>Upon entry, <code>input_chars</code> is a pointer to a buffer of 16-bit characters; the number of characters is given in <code>input_char_size</code>.</p>
<p><strong>NOTE:</strong> <code>input_char_size</code> is a character count, not a byte count.</p>
<p>The converted characters are to be output to the <code>output_bytes</code> buffer.</p>
<p>NOTE: The actual size of the <code>output_bytes</code> buffer will be large enough to accommodate the conversion, assuming the possibility that all characters might result in double byte sizes (e.g., Japanese conversions, etc.).</p>
<p>This function only gets called if the characters in <code>input_chars</code> are, in fact, Unicode; a call will never occur otherwise.</p>
<p>The <code>font</code> parameter will contain the current font of the text (which typically will contain language and script information).</p>
<p><strong>NOTE:</strong> All the characters provided are guaranteed to be rendered in this font, i.e. the conversion function will never be called with &quot;mixed&quot; fonts.</p>
<p><strong>FUNCTION RESULT:</strong> The function should return the total number of bytes converted (that were placed into output_bytes.</p>
<p><strong>NOTE:</strong> This is a byte count, not necessarily a character count.</p>
<h3 id='3811-hook-names'>38.11 Hook Names</h3>
<p>The Unicode conversion hooks are members of style_info.procs; their respective names are:</p>
<pre><code>style_info.procs.bytes_to_unicode; // Non-Unicode to Unicode 
style_info.procs.unicode_to_bytes; // Unicode to Non-Unicode
</code></pre>
<h1 id='39-error-codes'>39 ERROR CODES</h1>
<h2 id='391-the-define-error-codes'>39.1 The <code>#define</code> error codes</h2>
<p>The following error codes are defined in <code>pgErrors.h</code>.</p>
<p><strong>NOTE:</strong> These defines are not brought in by <code>Paige.h</code>: In addition, they vary slightly from platform to platform.</p>
<h3 id='000-no-error'>000 No error</h3>
<pre><code>//						Mac				Windows
NO_ERROR				0x0000			0x0000 // No error
</code></pre>
<h3 id='1xx-allocation-manager-errors'>1xx Allocation Manager Errors</h3>
<pre><code>//						Mac				Windows
NO_MEMORY_ERR			MemFullErr		0x0000 // Insufficient memory
NOT_ENOUGH_PURGED_ERR	0x0101			0x0101 // Can not purge enough space
NO_PURGE_FILE_ERR		0x0102			0x0102 // Purge file not available
LOCKED_BLOCK_ERR		0x0103			0x0103 // Can not resize locked block
NIL_ADDRESS_ERR			nilHandleErr	0x0104 // Address is NIL (not valid)
BAD_ADDRESS_ERR			0x0104			0x0105 // Address is bogus (not valid)
BAD_LINK_ERR			0x0105			0x0106 // Something wrong with internal ref
</code></pre>
<h3 id='2xx-hermes-paige-memoryref-specific-errors'>2xx HERMES Paige <code>memory_ref</code>-specific errors</h3>
<pre><code>//						Mac				Windows
CHECKSUM_ERR			0x0200			0x0200 // memory_ref checksum error
ACCESS_ERR				0x0201			0x0201 // Access failed on memory_ref
BAD_REF_ERR				0x0202			0x0202 // Bogus memory_ref
REF_DISPOSED_ERR		0x0203			0x0203 // memory_ref has been disposed
FILE_PURGE_ERR			0x0204			0x0204 // Error on file when purging
FILE_UNPURGE_ERR		0x0205			0x0205 // Error reading purged file
RANGE_ERR				0x0206			0x0206 // Access out of range
PURGED_MEMORY_ERR		0x0207			0x0207 // Attempt to operate on a purged block
DEBUG_ZERO_ERR			0x0208			0x0208 // Access is zero debug check
DEBUG_NZ_ERR			0x0209			0x0209 // Access is non-zero debug check
NO_ERR_HANDLER_ERR		0x020A			0x020A // No exception handler
PG_PSTRING_TOO_BIG_ERR	0x020B			0x020B // Conversion to Pascal string error
</code></pre>
<h3 id='3xx-file-io-errors'>3xx File i/o errors</h3>
<pre><code>//						Mac				Windows
NO_HANDLER_ERR			0x0300			0x0300 // Key handler not found
NO_SPACE_ERR			fnOpnErr		0x0301 // File has insufficient space
NOT_OPEN_ERR			fnOpnErr		0x0302 // Requested file not open
FILE_LOCK_ERR			fLckdErr		0x0303 // Disc write-protected
WRITE_PROTECT_ERR		wPrErr			0x0304 // Medium write-protected
ACCESS_DENIED_ERR		permErr			0x0305 // Access permission denied
EOF_ERR					eofErr			0x0305 // Attempt to go past end of file
IO_ERR					ioErr			0x0306 // Hard input-output error
BAD_TYPE_ERR			0x0301			0x0308 // File of inappropriate type
UNICODE_ERR				0x0309			0x0309 // File is Unicode, platform can&#39;t handle
NO_FILE_ERR				0x03FE			0x03FF // File not found
SOFT_EOF_ERR			0x03FF			0x03FF // Logical end-of-file &quot;error&quot; abort
</code></pre>
<h3 id='4xx-runtime-debugging-errors-not-allocation-manager-related'>4xx Runtime debugging errors (not Allocation Manager related)</h3>
<pre><code>LOCKED_PG_ERROR			0x0400 // Attempt to change a locked pg_ref
ILLEGAL_RE_ENTER_ERROR	0x0401 // Illegal re-entry
BAD_PARAM_ERROR			0x0402 // Bad parameter in function
GLOBALS_MISMATCH_ERROR	0x0403 // Globals in doc don&#39;t match pg_globals
DUP_KEY_HANDLER_ERROR	0x0404 // pgWrite or pgRead key that already exists
BAD_REFCON_ID_ERROR		0x0405 // Bad refCon number of exclusion
STRUCT_INTEGRITY_ERR	0x0406 // Style structures bad
USER_BREAK_ERR			0x0407 // User-invoked debug break
CARET_SYNC_ERR			0x0408 // Caret and caret bit out of synch
</code></pre>
<p>&nbsp;</p>
</body>
</html>
